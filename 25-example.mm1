import "24-words-derivatives.mm1";

def fp_root : Pattern CCCCaDxCaDxDpCCaDxCaDxDDpCCCaDxCaDxDpCCaDxCaDxDDD nCzD
  = $(mu CCCCaDxCaDxDpCCaDxCaDxDDpCCCaDxCaDxDpCCaDxCaDxDDD (epsilon \/ ((a . (mu
    CCCCaDxCaDxDpCCaDxCaDxDDpCCCaDxCaDxDpCCaDxCaDxDDD (epsilon \/ ((a . sVar (CCCCaDxCaDxDpCCaDxCaDxDDpCCCaDxCaDxDpCCaDxCaDxDDD)) \/
    (b . (mu nCzD (epsilon \/ ((a . sVar (nCzD)) \/ (b . sVar (nCzD)))))))))) \/ (b . (mu nCzD (epsilon \/ ((a . sVar (nCzD)) \/ (b
    . sVar (nCzD)))))))))$;

def label_root : Pattern
  =  $(kleene X (a . a)) -> (((kleene X a) . a) \/ epsilon)$;

theorem shortcut1:
    $((derivative a a . a \/ (epsilon /\ a) . derivative a a) . kleene X (a . a) -> derivative a (kleene X a) . a \/ (epsilon /\ kleene X a) . bot \/ bot)
 <-> (a . kleene X (a . a) -> ((kleene X a) . a \/ epsilon))
    $;

theorem e_implies_label_root : $epsilon -> label_root$;
theorem example : $fp_root X Y -> label_root$
 = '( --- For each interior node of the derivative tree, we apply main_goal_interior 
     main_goal_interior
         e_implies_label_root
         (norm (norm_imp (norm_sym sSubstitution_in_same_mu) norm_refl) --- Push substitutions all the way down
            ( apply_equiv eq_der_a_imp
            @ apply_equiv (cong_of_equiv_imp_l eq_der_a_kleene)
            @ apply_equiv (cong_of_equiv_imp_l @ cong_of_equiv_concat_l @ eq_der_a_concat)
            @ apply_equiv (cong_of_equiv_imp_r eq_der_a_or)
            @ apply_equiv (cong_of_equiv_imp_r @ cong_of_equiv_or_l @ eq_der_a_concat)
            @ apply_equiv (cong_of_equiv_imp_r @ cong_of_equiv_or_r @ eq_der_a_epsilon)
            @ apply_equiv (cong_of_equiv_imp_r @ cong_of_equiv_or_l @ cong_of_equiv_or_r @ cong_of_equiv_concat_r @ eq_der_a_a)
            --- and so on...
            @ apply_equiv shortcut1

            @ main_goal_interior _ _ _
            )
         )
         _
    );


