import "22-words-salomaa.mm1";
import "23-words-fixedpoints.mm1";

def derivative (l : Pattern) (phi : Pattern) : Pattern
    = $ctximp_app box (l . sVar box) phi dummy $;
--- = $exists w (eVar w)  /\ (l . eVar w C_ phi)$;

theorem der_equality:
    $phi == (epsilon /\ phi) \/ (a . (derivative a phi)) \/ (b . (derivative b phi))$;

theorem eq_der_a_emptyset: $(derivative a bot)         == bot$;
theorem eq_der_a_epsilon:  $(derivative a epsilon)     == bot$;
theorem eq_der_a_b:        $(derivative a b)           == bot$;
theorem eq_der_a_concat:
    $(derivative a (phi . psi)) ==    (derivative a phi) . psi
                                   \/ ((epsilon /\ phi) . (derivative a psi))$;
theorem eq_der_a_choice:
    $(derivative a (phi \/ psi)) == (derivative a phi) \/ (derivative a psi)$;
theorem eq_der_a_kleene:
    $(derivative a (kleene X phi)) == (derivative a phi) . (kleene X phi)$;
theorem eq_der_a_not:
    $(derivative a (~ phi)) == ~ (derivative a phi)$;


theorem fp_implies_l :
    (he: $epsilon -> rho$)
    (ha: $s[rho / X] phi_a -> (derivative a rho)$)
    (hb: $s[rho / X] phi_b -> (derivative b rho)$)
    ----------------------------------------------
    $(mu X epsilon \/ a . phi_a \/ b . phi_b) -> rho$;
