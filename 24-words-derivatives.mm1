import "00-matching-logic.mm0";
import "01-propositional.mm1";
import "02-ml-normalization.mm1";
import "12-proof-system-p.mm1";
import "13-fixedpoints.mm1";
import "20-theory-words.mm1";
import "22-words-salomaa.mm1";
import "23-words-fixedpoints.mm1";

--- Helpers
-----------

theorem positive_in_kleene_body {X: SVar} (phi: Pattern X)
  (h: $ _Positive X phi $):
  $ _Positive X (epsilon \/ phi . sVar X) $ =
  '(positive_in_or positive_triv @ positive_in_app (positive_in_app positive_triv h) positive_in_same_sVar);

theorem positive_in_concat {X: SVar} (phi1 phi2: Pattern X)
  (h1: $ _Positive X phi1 $)
  (h2: $ _Positive X phi2 $):
  $ _Positive X (phi1 . phi2) $ =
  '(positive_in_app (positive_in_app positive_triv h1) h2);

--- Derivatives
---------------

def derivative (l: Pattern) (phi: Pattern) : Pattern
    = $ctximp_app box (l . sVar box) phi dummy $;
--- = $exists w (eVar w)  /\ (l . eVar w C_ phi)$;

theorem l_der_phi_imp_phi (l phi: Pattern):
  $ (l . derivative l phi) -> phi $ =
  '(norm (norm_imp_l appCtxRVar) (! unwrap box _ _ _ dummy id));

axiom der_equality:
    $phi == (epsilon /\ phi) \/ ((a . (derivative a phi)) \/ (b . (derivative b phi)))$;

axiom eq_der_a_concat:
    $(derivative a (phi . psi)) <->    (derivative a phi) . psi
                                   \/ ((epsilon /\ phi) . (derivative a psi))$;
axiom eq_der_a_or:
    $(derivative a (phi \/ psi)) <-> (derivative a phi) \/ (derivative a psi)$;
axiom eq_der_a_kleene {X: SVar} (phi: Pattern X):
    $(derivative a (kleene X phi)) <-> (derivative a phi) . (kleene X phi)$;
axiom eq_der_a_not:
    $(derivative a (~ phi)) <-> ~ (derivative a phi)$;
axiom eq_der_a_imp:
    $(derivative a (phi -> psi)) <-> ((derivative a phi) -> (derivative a psi))$;

--- Contextual reasoning
------------------------

theorem cong_of_equiv_concat_l (h: $phi1 <-> phi2$): $(phi1 . psi) <-> (phi2 . psi)$ =
  '(ibii (framing_concat_l @ anl h) (framing_concat_l @ anr h));
theorem cong_of_equiv_concat_r (h: $phi1 <-> phi2$): $(psi . phi1) <-> (psi . phi2)$ =
  '(ibii (framing_concat_r @ anl h) (framing_concat_r @ anr h));
theorem cong_of_equiv_kleene {X: SVar} (phi1 phi2: Pattern X)
  (h1: $ _Positive X phi1 $)
  (h2: $ _Positive X phi2 $)
  (h: $ phi1 <-> phi2 $):
  $ (kleene X phi1) <-> (kleene X phi2) $ =
  '(cong_of_equiv_mu
    (positive_in_kleene_body h1)
    (positive_in_kleene_body h2)
    (cong_of_equiv_or_r @ cong_of_equiv_concat_l h));

--- Reasoning about regular expressions
---------------------------------------

--- top-implies-fp
------------------

axiom top_implies_fp_init {X: SVar} (h: $phi . top_letter -> phi$)
    : $top_word X -> phi$;

axiom top_implies_fp_interior {X: SVar}
    (he_a: $epsilon -> s[ (mu X (epsilon \/ (a . phi_a) \/ (b . phi_b))) / X ] phi_a$)
    (he_b: $epsilon -> s[ (mu X (epsilon \/ (a . phi_a) \/ (b . phi_b))) / X ] phi_b$)
                                --- ^^^ Together these give (letter -> rhs)
    (ha: $(s[ (ctximp_app Box (sVar Box . top_letter) (mu X (epsilon \/ (a . phi_a) \/ (b . phi_b))) _) / X ] psi_a) -> (s[ (mu X (epsilon \/ (a . phi_a) \/ (b . phi_b))) / X ] phi_a)$)
    (hb: $(s[ (ctximp_app Box (sVar Box . top_letter) (mu X (epsilon \/ (a . phi_a) \/ (b . phi_b))) _) / X ] psi_b) -> (s[ (mu X (epsilon \/ (a . phi_a) \/ (b . phi_b))) / X ] phi_b)$)
  : ------------------------
    $(mu X (epsilon \/ ((a . psi_a) \/ (b . psi_b)))) . top_letter -> (mu X (epsilon \/ ((a . phi_a) \/ (b . phi_b))))$;


--- fp-implies-alpha
--------------------

--| Apply equivalence left to right
theorem apply_equiv (eq: $phi <-> psi$) (cont: $rho -> psi$): $rho -> phi$
  = '(syl (bi2i eq) cont);



theorem _sSubst_nnimp {X: SVar} (phi phi1 phi2 psi1 psi2: Pattern X)
  (h1: $ Norm (s[ phi / X ] phi1) psi1 $)
  (h2: $ Norm (s[ phi / X ] phi2) psi2 $):
  $ Norm (s[ phi / X ] (phi1 ->> phi2)) (psi1 ->> psi2) $ =
  '(_sSubst_imp (_sSubst_not @ _sSubst_not h1) h2);

theorem _eSubst_concat {x: EVar} (phi psi1 psi2 rho1 rho2: Pattern x)
  (h1: $ Norm (e[ phi / x ] psi1) rho1 $)
  (h2: $ Norm (e[ phi / x ] psi2) rho2 $):
  $ Norm (e[ phi / x ] (psi1 . psi2)) (rho1 . rho2) $ =
  '(_eSubst_app (_eSubst_app eSubstitution_triv h1) h2);

theorem _eSubst_concat_l {x: EVar} (phi psi rho: Pattern x) (gamma: Pattern)
  (h: $ Norm (e[ phi / x ] psi) rho $):
  $ Norm (e[ phi / x ] (psi . gamma)) (rho . gamma) $ =
  '(_eSubst_concat h eSubstitution_triv);
theorem _eSubst_concat_r {x: EVar} (phi psi rho: Pattern x) (gamma: Pattern)
  (h: $ Norm (e[ phi / x ] psi) rho $):
  $ Norm (e[ phi / x ] (gamma . psi)) (gamma . rho) $ =
  '(_eSubst_concat eSubstitution_triv h);


theorem epsilon_kleene {X: SVar} (phi: Pattern X)
  (h: $ _Positive X phi $):
  $ epsilon -> kleene X phi $ =
  '(rsyl orl (norm (norm_imp_l
    ,(propag_s_subst 'X $epsilon \/ phi . sVar X$)
    ) @ pre_fixpoint @ positive_in_kleene_body h));


theorem main_goal_leaf :
    $rho -> rho$ = 'id;

theorem main_goal_interior {X: SVar} (phi_a phi_b: Pattern X)
    (posa: $ _Positive X phi_a $)
    (posb: $ _Positive X phi_b $)
    (he: $epsilon -> epsilon /\ rho$)
    (ha: $s[ rho / X ] phi_a -> (derivative a rho)$)
    (hb: $s[ rho / X ] phi_b -> (derivative b rho)$):
    ----------------------------------------------
    $(mu X (epsilon \/ ((a . phi_a) \/ (b . phi_b)))) -> rho$ =
    '(KT
      (positive_in_or positive_triv @ positive_in_or (pos_in_concat positive_triv posa) (pos_in_concat positive_triv posb)) @
      apply_equiv (corollary_57_floor der_equality) (norm
        (norm_imp_l @ norm_sym @ _sSubst_or sSubstitution_triv @ _sSubst_or (sSubst_concat_r norm_refl) (sSubst_concat_r norm_refl))
        (orim he @ orim (framing_concat_r ha) (framing_concat_r hb))
      ));

theorem regex_eq_der_bot_lemma_1 {x y v w: EVar}:
  $ (forall v (exists x (eVar x == eVar w . eVar v ))) -> exists x (eVar x == eVar w . eVar y ) $ =
  '(norm (norm_imp_r ,(propag_e_subst 'v $exists x (eVar x == eVar w . eVar v )$)) var_subst);
theorem regex_eq_der_bot_lemma_2 {x y v w: EVar}:
  $ (forall w (forall v (exists x (eVar x == eVar w . eVar v )))) -> forall v (exists x (eVar x == eVar y . eVar v )) $ =
  '(norm (norm_imp_r ,(propag_e_subst 'w $forall v (exists x (eVar x == eVar w . eVar v ))$)) var_subst);

theorem regex_eq_der_bot
  (h: $ exists x (eVar x == A) $):
  $ (derivative A bot) -> bot $
  = '(exists_generalization_strict @ con3 anr @ notnot1 @ framing_def notnot1 @
    exists_generalization_strict (com12
      (eq_to_def @ norm (norm_imp_r @ norm_imp_r @ norm_sym @ norm_trans appCtxR @ norm_app norm_refl (! appCtxVar box)) @ eq_to_app_l @ eq_to_app_r eq_to_intro)
      (exists_generalization_strict (com12 (eq_to_def eq_to_intro) definedness)
          (! regex_eq_der_bot_lemma_1 x1 y1 v1 x (regex_eq_der_bot_lemma_2 (! functional_concat w2 v1 x1))))
        ) h
  );

theorem regex_eq_der_bot_wrt_a:
  $ (derivative a bot) <-> bot $ = '(ibii (regex_eq_der_bot (! functional_a x)) absurdum);
theorem regex_eq_der_bot_wrt_b:
  $ (derivative b bot) <-> bot $ = '(ibii (regex_eq_der_bot (! functional_b x)) absurdum);

axiom regex_eq_der_epsilon_wrt_a:
  $ (derivative a epsilon) <-> bot $;
axiom regex_eq_der_epsilon_wrt_b:
  $ (derivative b epsilon) <-> bot $;

axiom regex_eq_der_same_a_wrt_a:
  $ (derivative a a) <-> epsilon $;
axiom regex_eq_der_same_a_wrt_b:
  $ (derivative b b) <-> epsilon $;

axiom regex_eq_der_diff_a_wrt_a:
  $ (derivative a b) <-> bot $;
axiom regex_eq_der_diff_a_wrt_b:
  $ (derivative b a) <-> bot $;

axiom regex_eq_der_kleene_wrt_a {X: SVar} (Alpha: Pattern X): $ (derivative a (kleene X Alpha)) <-> ((derivative a Alpha) . (kleene X Alpha)) $;
axiom regex_eq_der_kleene_wrt_b {X: SVar} (Alpha: Pattern X): $ (derivative b (kleene X Alpha)) <-> ((derivative b Alpha) . (kleene X Alpha)) $;
axiom regex_eq_der_concat_wrt_a: $ (derivative a (Alpha . Beta)) <-> ((derivative a Alpha) . Beta) \/  ((epsilon /\ Alpha) . (derivative a Beta)) $;
axiom regex_eq_der_concat_wrt_b: $ (derivative b (Alpha . Beta)) <-> ((derivative b Alpha) . Beta) \/  ((epsilon /\ Alpha) . (derivative b Beta)) $;
axiom regex_eq_der_choice_wrt_a: $ (derivative a (Alpha \/ Beta)) <-> (derivative a Alpha) \/ (derivative a Beta) $;
axiom regex_eq_der_choice_wrt_b: $ (derivative b (Alpha \/ Beta)) <-> (derivative b Alpha) \/ (derivative b Beta) $;
axiom regex_eq_der_conj_wrt_a: $ (derivative a (Alpha /\ Beta)) <-> (derivative a Alpha) /\ (derivative a Beta) $;
axiom regex_eq_der_conj_wrt_b: $ (derivative b (Alpha /\ Beta)) <-> (derivative b Alpha) /\ (derivative b Beta) $;
axiom regex_eq_der_neg_wrt_a: $ (derivative a (~ Alpha)) <-> ~ (derivative a Alpha) $;
axiom regex_eq_der_neg_wrt_b: $ (derivative b (~ Alpha)) <-> ~ (derivative b Alpha) $;

theorem regex_eq_ewp_bot:
  $ (epsilon /\ bot) <-> bot $ = '(ibii anr absurdum);

theorem regex_eq_ewp_epsilon:
  $ epsilon /\ epsilon <-> epsilon $ = 'anidm;


theorem regex_eq_ewp_ab
  (h: $ letter -> top_letter $):
  $ epsilon /\ letter <-> bot $
  = '(ibii
    (exists_generalization_strict
      (com12
        (eq_to_imp (eq_to_def @ eq_to_and_l eq_to_intro) (eq_to_not @ eq_to_and_l eq_to_intro))
        (con2 (dne @ singleton_norm (! appCtxVar box1) (! defNorm box2))) -- |^ x /\ ~a ^| <-> ~(x /\ a)
      ) (exists_framing eq_sym (! functional_epsilon x))
      (framing_def (con3 @ imim2i @ syl h dne) @ dne no_confusion_ae_e))
    absurdum);

theorem regex_eq_ewp_a:
  $ epsilon /\ a <-> bot $ = '(regex_eq_ewp_ab orl);

theorem regex_eq_ewp_b:
  $ epsilon /\ b <-> bot $ = '(regex_eq_ewp_ab orr);

axiom regex_eq_ewp_concat:
  $ epsilon /\ (Alpha . Beta) <-> (epsilon /\ Alpha) /\ (epsilon /\ Beta) $;

theorem regex_eq_ewp_and:
  $ epsilon /\ (Alpha /\ Beta) <-> (epsilon /\ Alpha) /\ (epsilon /\ Beta) $ = 'anandi;

theorem regex_eq_ewp_choice:
  $ epsilon /\ (Alpha \/ Beta) <-> (epsilon /\ Alpha) \/ (epsilon /\ Beta) $ = 'andi;

theorem regex_eq_ewp_kleene {X: SVar} (Alpha: Pattern X)
  (h: $ _Positive X Alpha $):
  $ epsilon /\ (kleene X Alpha) <-> epsilon $ =
  '(ibii anl @ iand id @ epsilon_kleene h);

theorem regex_eq_ewp_not_bot: $ (epsilon /\ ~bot) <-> epsilon $ =
  '(ibii anl @ syl ancom top_and);
theorem regex_eq_ewp_not_eps: $ (epsilon /\ ~epsilon) <-> bot $ =
  '(ibii (notnot1 notnot1) absurdum);
theorem regex_eq_ewp_not_a: $ (epsilon /\ ~a) <-> epsilon $ =
  '(ibii anl @ iand id @ dne @ anl regex_eq_ewp_a);
theorem regex_eq_ewp_not_b: $ (epsilon /\ ~b) <-> epsilon $ =
  '(ibii anl @ iand id @ dne @ anl regex_eq_ewp_b);
axiom regex_eq_ewp_not_concat: $ (epsilon /\ ~(Alpha . Beta)) <-> ((epsilon /\ ~ Alpha) \/ (epsilon /\ ~ Beta)) $;
theorem regex_eq_ewp_not_and: $ (epsilon /\ ~(Alpha /\ Beta)) <-> ((epsilon /\ ~ Alpha) \/ (epsilon /\ ~ Beta)) $ =
  '(bitr (cong_of_equiv_and_r notan) andi);
theorem regex_eq_ewp_not_choice: $ (epsilon /\ ~(Alpha \/ Beta)) <-> ((epsilon /\ ~ Alpha) /\ (epsilon /\ ~ Beta)) $ =
  '(bitr (cong_of_equiv_and_r not_distr_or) and_distr);
theorem regex_eq_ewp_not_kleene {X: SVar} (Alpha: Pattern X)
  (h: $ _Positive X Alpha $):
  $ (epsilon /\ ~(kleene X Alpha)) <-> bot $ =
  '(ibii (notnot1 @ syl notnot1 @ epsilon_kleene h) absurdum);
theorem regex_eq_ewp_not_not: $ (epsilon /\ ~(~ Alpha)) <-> (epsilon /\ Alpha) $ =
  '(cong_of_equiv_and_r @ bicom notnot);

--- Identity and idemoptency of \/
theorem regex_eq_or_choice_abs: $ top \/ Alpha <-> top $ = '(ibii imp_top @ a1i top_or);
theorem regex_eq_or_choice_unit: $ bot \/ Alpha <-> Alpha $ = '(ibii bot_or prop_1);
theorem regex_eq_or_choice_idem: $ Alpha \/ Alpha <-> Alpha $ = 'oridm;
theorem regex_eq_or_choice_assoc: $ (Alpha \/ Beta) \/ Gamma <-> Alpha \/ (Beta \/ Gamma) $ = 'orass;
theorem regex_eq_or_choice_comm_node: $ Alpha \/ (Beta \/ Gamma) <-> Beta \/ (Alpha \/ Gamma) $ = 'or12;
theorem regex_eq_or_choice_comm_leaf: $ Alpha \/ Beta <-> Beta \/ Alpha $ = 'orcomb;

--- Identity and idemoptency of /\
theorem regex_eq_and_choice_abs: $ bot /\ Alpha <-> bot $ = '(ibii anl absurdum);
theorem regex_eq_and_choice_unit: $ top /\ Alpha <-> Alpha $ = '(ibii anr top_and);
theorem regex_eq_and_choice_idem: $ Alpha /\ Alpha <-> Alpha $ = 'anidm;
theorem regex_eq_and_choice_assoc: $ (Alpha /\ Beta) /\ Gamma <-> Alpha /\ (Beta /\ Gamma) $ = 'anass;
theorem regex_eq_and_choice_comm_node: $ Alpha /\ (Beta /\ Gamma) <-> Beta /\ (Alpha /\ Gamma) $ = 'anlass;
theorem regex_eq_and_choice_comm_leaf: $ Alpha /\ Beta <-> Beta /\ Alpha $ = 'ancomb;

---- Optional simplifications
theorem regex_eq_bot_concat_l: $ bot . Alpha <-> bot $ =
  '(ibii (norm (norm_not appCtxLRVar) (! propag_bot box)) absurdum);
theorem regex_eq_bot_concat_r: $ Alpha . bot <-> bot $ =
  '(ibii (norm (norm_not appCtxRVar) (! propag_bot box)) absurdum);

axiom regex_eq_eps_concat_l: $ epsilon . Alpha <-> Alpha $;
axiom regex_eq_eps_concat_r: $ Alpha . epsilon <-> Alpha $;

theorem regex_eq_double_neg: $ ~ (~ Alpha) <-> Alpha $ = '(bicom notnot);
axiom regex_eq_double_kleene {X: SVar} (Alpha: Pattern X): $ (kleene X (kleene X Alpha)) <-> (kleene X Alpha) $;

axiom regex_eq_eps_kleene: $ (kleene X epsilon) <-> epsilon $;
theorem regex_eq_bot_kleene: $ (kleene X bot) <-> epsilon $ = '(ibii
  (rsyl (mu_framing (positive_in_or positive_triv @ positive_in_concat positive_triv positive_in_same_sVar) positive_triv (rsyl (orim2 @ norm (norm_imp_l appCtxLRVar) (! propag_bot box)) dne)) (KT positive_triv @ norm (norm_sym @ norm_imp_l sSubstitution_triv) id))
  (epsilon_kleene positive_triv));
