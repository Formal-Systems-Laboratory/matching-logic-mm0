import "10-theory-definedness.mm1";

def nnimp (phi1 phi2: Pattern): Pattern = $ ~phi1 \/ phi2 $;
infixr nnimp: $->>$ prec 24;

def nneqiv (phi1 phi2: Pattern): Pattern = $ (phi1 ->> phi2) /\ (phi2 ->> phi1) $;
infixr nneqiv: $<<->>$ prec 20;

def replus (phi1 phi2: Pattern): Pattern = $ phi1 \/ phi2 $;
infixl replus: $+$ prec 29;

term a_symbol : Symbol ;
def a = $sym a_symbol$ ;
term b_symbol : Symbol ;
def b = $sym b_symbol$ ;

def emptyset = $bot$ ;

term epsilon_symbol : Symbol ;
def epsilon = $sym epsilon_symbol$ ;

term concat_symbol : Symbol ;
def concat (phi psi: Pattern) : Pattern = $(app (app (sym concat_symbol) phi) psi)$;
infixl concat: $.$ prec 39;

def kleene_l {X: SVar} (alpha: Pattern X) : Pattern = $mu X (epsilon \/ sVar X . alpha)$;
def kleene_r {X: SVar} (alpha: Pattern X) : Pattern = $mu X (epsilon \/ alpha . sVar X)$;
def kleene   {X: SVar} (alpha: Pattern X) : Pattern = $(kleene_r X alpha)$;

--- We assume that the alphabet has only two letters.
--- This, however, captures the full expressivity.
def top_letter : Pattern = $a \/ b$;

def top_word_l {X: SVar} : Pattern = $(kleene_l X top_letter )$ ;
def top_word_r {X: SVar} : Pattern = $(kleene_r X top_letter )$ ;
def top_word   {X: SVar} : Pattern = $(kleene   X top_letter )$ ;

--- Axioms (e suffix indicates over element vars)
axiom functional_epsilon : $exists x (eVar x == epsilon)$;
axiom functional_a       : $exists x (eVar x == a)$;
axiom functional_b       : $exists x (eVar x == b)$;
axiom functional_concat  {w v x: EVar} : $(forall w (forall v (exists x (eVar x == eVar w . eVar v ))))$;

axiom no_confusion_ab_e  : $a != b$;
axiom no_confusion_ae_e  : $not (epsilon C_ top_letter)$;
axiom no_confusion_ec_e  {u v: EVar} : $forall u (forall v (epsilon == eVar u . eVar v) -> (eVar u == epsilon) /\ (eVar v == epsilon))$;
axiom no_confusion_cc_e  {u v x y: EVar} : $forall u (forall v (forall x  (x in top_letter) -> (forall y  (y in top_letter)
                            -> (eVar x . eVar u == eVar y . eVar v) -> (eVar x == eVar y) /\ (eVar u == eVar v))))$;

axiom assoc_concat_e     {u v w: EVar} : $forall u (forall v (forall w  (eVar u . eVar v) . eVar w == eVar u . (eVar v . eVar w)))$;
axiom identity_left_e    : $forall u (eVar u) . epsilon == epsilon$;
axiom identity_right_e   : $forall u epsilon . (eVar u) == epsilon$;

