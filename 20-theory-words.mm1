import "10-theory-definedness.mm1";

term a_symbol : Symbol ;
def a = $sym a_symbol$ ;
term b_symbol : Symbol ;
def b = $sym a_symbol$ ;

def emptyset = $bot$ ;

term epsilon_symbol : Symbol ;
def epsilon = $sym epsilon_symbol$ ;

term concat_symbol : Symbol ;
def concat (phi psi: Pattern) : Pattern = $(app (app (sym concat_symbol) phi) psi)$;
infixl concat: $.$ prec 40;

def kleene_l { X: SVar } (alpha: Pattern) : Pattern = $mu X (epsilon \/ sVar X . alpha)$;
def kleene_r { X: SVar } (alpha: Pattern) : Pattern = $mu X (epsilon \/ alpha . sVar X)$;
def kleene   { X: SVar } (alpha: Pattern) : Pattern = $(kleene_r X alpha)$;

--- We assume that the alphabet has only two letters.
--- This, however, captures the full expressivity.
def top_letter : Pattern = $a \/ b$;

def top_word_l { X: SVar } : Pattern = $(kleene_l X top_letter )$ ;
def top_word_r { X: SVar } : Pattern = $(kleene_r X top_letter )$ ;
def top_word   { X: SVar } : Pattern = $(kleene   X top_letter )$ ;

--- Axioms (e suffix indicates over element vars)
axiom functional_a      : $exists x (eVar x == a)$;
axiom functional_b      : $exists x (eVar x == a)$;
axiom functional_concat : $(forall w (forall v (exists x (eVar x == eVar w . eVar v ))))$;

axiom no_confusion_ab_e  : $a != b$;
axiom no_confusion_ae_e : $not (epsilon C_ top_letter)$;
axiom no_confusion_ec_e : $forall u (forall v (epsilon == eVar u . eVar v) -> (eVar u == epsilon) /\ (eVar v == epsilon))$;
axiom no_confusion_cc_e : $forall u (forall v (forall x  (x in top_letter) -> (forall y  (y in top_letter)
                            -> (eVar x . eVar u == eVar y . eVar v) -> (eVar x == eVar y) /\ (eVar u == eVar v))))$;

axiom assoc_concat_e    : $forall u (forall v (forall w  (eVar u . eVar v) . eVar w == eVar u . (eVar v . eVar w)))$;
axiom identity_left_e   : $forall u (eVar u) . epsilon == epsilon$;
axiom identity_right_e  : $forall u epsilon . (eVar u) == epsilon$;

