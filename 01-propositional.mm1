import "00-matching-logic.mm0";

do {
  (def (id x) x)
  (def (ignore . _))
  (def dbg @ match-fn* [(x) (print x) x]
    [(x y) (display @ string-append (->string x) ": " (->string y)) y])
  (def (foldl l z s) (if (null? l) z (foldl (tl l) (s z (hd l)) s)))
  (def (foldli i l z s) (if (null? l) z (foldli {i + 1} (tl l) (s i z (hd l)) s)))
  (def (foldr l z s) (if (null? l) z (s (hd l) (foldr (tl l) z s))))
  (def (foldri i l z s) (if (null? l) z (s i (hd l) (foldri {i + 1} (tl l) z s))))
  (def (range a b) (if {a = b} () (cons a (range {a + 1} b))))
  (def (for a b f) (if {a = b} #undef (begin (f a) (for {a + 1} b f))))
  (def last (match-fn [(a) a] [(_ . l) (last l)]))
  (def split-last @ match-fn
    [(and (_) l) l]
    [(a . l) @ match (split-last l) @ (r . l2) '(,r ,a . ,l2)]
    [() ()])
  (def (append . ls) @ foldr ls () @ fn (l l2) @ foldr l l2 cons)
  (def (rev l) @ foldl l () (fn (l a) (cons a l)))
  (def (len l) @ foldl l 0 (fn (n _) {n + 1}))
  (def (filter l p) @ foldl l () @ fn (l2 x) @ if (p x) (cons x l2) l2)
  (def (repeat a n) (if {n = 0} () (cons a (repeat a {n - 1}))))
  (def (iterate n f a) (if {n = 0} a (f (iterate {n - 1} f a))))
  (def (find l) @ match l
    [((k v) . l) (def f (find l)) @ fn (a) @ if {k == a} v (f a)]
    [() @ fn (a)])
  (def (verb e) (copy-span e (list ':verb e)))
  (def (exact e) (refine (verb e)))
  (def (result) (hd (get-goals)))
  (def (target) (goal-type (result)))
  (def (inspect-result f) (def g (result)) (refine (f)) (display @ pp g))
  (def (later) @ match (get-goals)
    [(g . gs) (apply set-goals @ append gs @ list g)])
  (def mvar-sort @ match-fn @ (mvar s _) s)
  (def (report a) (def g (result)) (refine a) (print g))
  (def (atom-map . xs) (get! @ apply atom-map! xs))
  (def (lookup-fn xs) (def m (apply atom-map xs)) (fn k (apply lookup m k)))
  (def (atom-app . xs) (string->atom (apply string-append (map ->string xs))))
  (def transpose @ match-fn*
    [(xs) (apply map list xs)]
    [(n xs) (if (null? xs) (repeat () n) (apply map list xs))])
  (def (join xs) (apply append xs))
  (def (rmap . args) (apply map (split-last args)))
  (def (scan . args) (apply rmap args) #undef)
  (def (undef? x) (not (def? x)))
  (def (error-at sp msg) (report-at 'error sp msg))
  (def (info-at sp msg) (report-at 'info sp msg))
  (def goal! @ match-fn*
    [(ty) (ref! (goal ty))]
    [(pos ty) (ref! (copy-span pos (goal ty)))])
  (def (swap) @ match (get-goals) [(x . y) (apply set-goals @ append y @ list x)])
  (def suffices @ match-fn*
    [(h) (have h _) (swap)]
    [xs (apply have xs) (swap)])
  (def (get-proof x) @ match (get-decl x)
    [('theorem _ _ _ _ _ pf) (hd @ tl @ pf)]
    [_ (error "not a theorem")])
  (def (pp-proof x) (display @ pp @ get-proof x))

  --| This utility will take a verbatim proof and "unelaborate" it into a refine script
  --| using ! on every step. This is useful to get `refine` to re-typecheck a term when
  --| testing tactics which produce verbatim proofs.
  (def unelab @ letrec (
    [(args bs xs)
      @ if (null? bs) (map rec xs)
      @ cons (hd xs) @ args (tl bs) (tl xs)]
    [rec @ match-fn
      [(':conv tgt _ p) '{,(rec p) : ,tgt}]
      [(f . xs)
        (cons '! f @ args (nth 2 @ get-decl f) xs)]
      [e e]])
    rec)

  --| This is a special variable used by `mm0-rs doc` to shorten axiom list printouts.
  --| It is an atom map from a name for the axiom list to a list of axioms.
  (def axiom-sets (atom-map!))
  --| Declare a new axiom set, which is used by the docgen tool to shorten axiom lists.
  (def (add-axiom-set! x doc xs) (insert! axiom-sets x (cons doc xs)))

  --| `(named pf)` wraps a proof script `pf`, runs it, then gathers all
  --| unassigned metavariables and assigns them to dummies.
  --| `(named x1 ... xn pf)` is the same but names the first `n` variables `x1,...,xn`.
  --| This is commonly used for proofs where we don't care to name the
  --| dummy variables.
  (def named
    (def (assign-mvar m x) @ match x ['_] [_ (set! m (dummy! x (mvar-sort m)))])
    @ match-fn*
      [((? atom? d) es) (refine es) (scan (get-mvars) (list d) assign-mvar)]
      [(ds es) (refine es) (scan (get-mvars) ds assign-mvar)]
      [(es) (refine es)
        (def n (ref! 1))
        (scan (get-mvars) @ fn (v)
          (assign-mvar v (atom-app "a" n)) (set! n {n + 1}))
        (if {n = 1} (display "unnecessary (named)"))])

  --| `(name-all x1 ... xn)` instantiates all metavariables in the current
  --| proof state. It is the same as `named` but it can be used in the middle of a
  --| proof instead of as a wrapper around a complete proof.
  (def (name-all . ds)
    (def (assign-mvar m x) @ match x ['_] [_ (set! m (dummy! x (mvar-sort m)))])
    (scan (get-mvars) ds assign-mvar))

  (def ((tac-thm stmt f))
    @ match (get-goals) @ (g)
    (def res (f))
    (if (def? res) (refine res))
    (match (get-goals) [()] [_ (stat) (error "not all goals are solved")])
    '(() ,g))
  (def (add-tac-thm! x bis hyps ret vis f)
    (add-thm! x bis hyps ret vis (tac-thm ret f)))

  (def eq-for @ lookup-fn '([wff iff] [nat eq] [set eqs]))
  (def eq-sort @ lookup-fn '([iff wff] [eq nat] [eqs set]))
  (def nf-for @ lookup-fn '([wff nf] [nat nfn] [set nfs]))
  (def eqid-for @ lookup-fn '([wff biid] [nat eqid] [set eqsid]))
  (def eqidd-for @ lookup-fn '([wff biidd] [nat eqidd] [set eqsidd]))
  (def eqd-map (atom-map!)) (set-merge-strategy eqd-map merge-map)
  (def (eqd-for . e) (apply lookup eqd-map e))
  (def (register-eqd df) (fn (tgt) (insert! eqd-map df tgt)))
  (def (get-tgt-args args df . s) @ match args
    [() (apply atom-app df s)]
    [((? atom? t)) (apply atom-app t s)]
    [('quote (? atom? t)) t])

  (def (maybe-atom-map hs)
    @ if (apply and @ map (fn (x) (atom? (hd x))) hs)
      (let ([m (get! @ apply atom-map! hs)])
        @ fn (x) (lookup m x))
      (find hs))
  (def (eqtac-ctx ltr hyps)
    @ foldr hyps () @ fn (h ls)
      @ match (match (infer-type h) [('im _ R) R] [R R])
        [('eq L R) '([,(if ltr L R) ,h] . ,ls)]
        [_ ls])
  (def (eqtac-core ltr ctx t)
    @ match t @ (eq L R)
    @ letrec (
      [(f A) @ match (ctx A)
        [#undef @ match A
          [((? atom? t) . es)
            @ if (null? es) #undef @ begin
            @ match (eqd-for t) [#undef] @ eqd
            @ match (get-decl eqd) @ (_ _ bis hs ('im _ (eq (t . args) _)) ...)
            (def subterms @ apply atom-map! @ map list args es)
            (def isrefl (ref! #t))
            (def subproofs @ rmap hs @ match-fn @ (h ('im _ (eq arg _)))
              @ if (atom? arg)
                (or_refl isrefl @ lookup subterms arg)
                (eqidd-for (infer-sort A)))
            @ if isrefl #undef (cons eqd subproofs)]
          [e #undef]]
        [res res]]
      [(or_refl isrefl A) @ match (f A)
        [#undef (eqidd-for (infer-sort A))]
        [e (set! isrefl #f) e]])
    (or_refl (ref!) (if ltr L R)))
  (def ((eqtac-with ltr . hyps) refine t)
    @ refine t @ match t
    [('im G (and rhs (eq L R)))
      @ letrec ([add-locals @ match-fn*
        [(('an G D) f)
          (add-locals G @ fn (a p) (f a '(anwl ,G ,D ,a ,p)))
          (add-locals D @ fn (a p) (f a '(anwr ,G ,D ,a ,p)))]
        [((and a (h . _)) f) @ if (def? (eq-sort h)) (f a '(id ,a))]
        [_]])
      (def ctx (ref! (eqtac-ctx #t hyps)))
      (add-locals G @ match-fn* @ ((eq L R) p)
        (def v (if ltr L R))
        (def v @ match v [(mvar s _) (def d (dummy! s)) (set! v d) d] [_ v])
        (set! ctx '([,v ,(verb p)] . ,(get! ctx))))
      (eqtac-core ltr (maybe-atom-map ctx) rhs)]
    [(eq L R) '(trud ,(eqtac-core ltr (maybe-atom-map @ eqtac-ctx #t hyps) t))])

  --| A refine script that will prove formulas of the form `x = a -> (p <-> ?q)`
  --| by substituting all instances of `x` with `a` in `p`. This works whether `?q`
  --| is a metavariable or the substitution.
  (def eqtac (eqtac-with #t))

  --| Like `eqtac` but works in reverse:
  --| it will prove formulas of the form `x = a -> (?p <-> q)`
  --| by substituting all instances of `a` with `x` in `q`. If `x` is a metavariable, it
  --| also assigns it to a new dummy variable.
  (def ((eqtac-gen a) refine t) @ refine t
    @ match t @ ('im (eq x _) _)
      (def y (match x [(mvar s _) (dummy! s)] [_ x]))
      '{,(eqtac-with #f) : (im (eq ,y ,a) _)})

  --| This metaprogram proves a statement of the form
  --| $ G -> a1 = a2 $ > $ G -> b1 = b2 $ > $ G -> foo a1 b1 = foo a2 b2 $
  --| for any definition foo.
  (def (add-eqd-thm df . args)
    (def tgt (get-tgt-args args df "eqd"))
    @ match (get-decl df)
      [#undef (error (string-append "declaration '" (->string df) "' not found"))]
      [(_ _ () ...)]
      [(_ _ bis (ret _) . rest)
        (def G @ if (apply or (map (match-fn [('G ...) #t] [_ #f]) bis)) '_G '_G)
        @ if (def? (get-decl tgt)) (insert! eqd-map df tgt) @ begin
        (def ctx (atom-map!))
        @ match (map join @ transpose 4 @ rmap bis @ match-fn
          [(and (x s) e) (insert! ctx x (list s)) '((,e) () (,x) (,x))]
          [(v s vs) @ let ([v1 (atom-app '_ v 1)] [v2 (atom-app '_ v 2)] [hv (atom-app '_ v 'h)])
            (insert! ctx v (list v1 v2 s hv))
            '(() ((,v ,s ,v1 ,v2 ,hv))
              (,v1) (,v2))]) @ (xs vs es1 es2)
        (def xs1 (map hd xs))
        (def bis '((,G wff ()) . ,(append xs @ join @ rmap vs
          @ match-fn [(v s v1 v2 hv) '((,v1 ,s ,xs1) (,v2 ,s ,xs1))])))
        (def hs @ rmap vs @ match-fn [(v s v1 v2 hv) '(,hv (im ,G (,(eq-for s) ,v1 ,v2)))])
        (def rete '(im ,G (,(eq-for ret) (,df . ,es1) (,df . ,es2))))
        (match rest
          [() (add-thm! tgt bis hs rete)]
          [(_ ds v) @ add-thm! tgt bis hs rete () @ fn () @ list ds
            (def ds (rmap ds @ match-fn @ (x s) (insert! ctx x (list s)) x))
            @ letrec (
              [preproof (match-fn
                [(? atom? v) (lookup ctx v)]
                [((? atom? t) . es)
                  @ match (get-decl t) @ (_ _ bis (ret _) ...)
                  @ if (null? es) (list ret) @ begin
                  (def isrefl (ref! #t))
                  @ match (transpose 5 @ rmap bis es @ match-fn*
                    [((_ _) x) '((,x) () () ,x ,x)]
                    [((_ _ _) e)
                      @ match (preproof e)
                        [(s) '(() (,e ,e) ((,(eqidd-for s) ,G ,e)) ,e ,e)]
                        [(e1 e2 s p) (set! isrefl #f)
                          '(() (,e1 ,e2) (,p) ,e1 ,e2)]]) @ (xs ts ps es1 es2)
                  @ if isrefl (list ret) @ begin
                  @ match (eqd-for t)
                    [#undef (error @ string-append "equality theorem not found for " (->string t))]
                    [eqd '((,t . ,es1) (,t . ,es2) ,ret
                      (,eqd ,G . ,(append (join xs) (join ts) (join ps))))]])]
              [(mk-proof e) (match (preproof e)
                [(s) '(,e ,e (,(eqidd-for s) ,G ,e))]
                [(e1 e2 s p) (list e1 e2 p)])])
            @ match (mk-proof v) @ (t1 t2 p)
            '(:conv ,rete (im ,G (,(eq-for ret)
              (:unfold ,df ,es1 ,ds ,t1)
              (:unfold ,df ,es2 ,ds ,t2))) ,p)])
        (insert! eqd-map df tgt)])

  (def (ded-to-thm t)
    @ match (get-decl t) @ (_ _ ((G 'wff ()) . bis) hs ('im _ ret) ...)
    @ if (apply and @ rmap bis @ match-fn [(_ _ ()) #t] [_ #f]) @ begin
    (def rete @ foldr hs ret @ match-fn* [((_ ('im _ h)) r) '(im ,h ,r)])
    @ list bis rete @ fn () @ list ()
    @ letrec (
      [(exps l r) @ match r
        [('im e1 e2) (list 'exp l e1 e2 (exps (list 'an l e1) e2))]
        [_ (cons t l @ append (map hd bis) @
          map (match-fn [(_ h) h]) @ rev @ conjuncts l)]]
      [conjuncts @ match-fn
        [('an e1 e2)
          @ match (conjuncts e1)
            [(_) '((,e2 (anr ,e1 ,e2)) (,e1 (anl ,e1 ,e2)))]
            [hs (cons '(,e2 (anr ,e1 ,e2)) @
              rmap hs @ match-fn [(e h) '(,e (anwl ,e1 ,e2 ,e ,h))])]]
        [e '((,e (id ,e)))]])
    @ match rete [('im l r) (exps l r)])

  (def (make-eqNd-thms df)
    @ match (get-decl df) @ (_ _ bis (ret _) . rest)
    (def G '_G) (def h0 '_h)
    @ letrec (
      [mk-bis @ match-fn
        [() '(() () () () ())]
        [((and (x _) e) . bis)
          @ match (mk-bis bis) @ (pes vs es pp data)
          '((,x . ,pes) ,vs ,es ,pp
            ,(rmap data @ match-fn [(b t1 t2 h es ps)
              '(,b (,x . ,t1) (,x . ,t2) ,h ,es ,ps)]))]
        [((v s _) . bis)
          @ match (mk-bis bis) @ (pes vs es pp data)
          @ let ([v1 (atom-app '_ v 1)] [v2 (atom-app '_ v 2)])
          '((,v . ,pes)
            ((,v ,s) . ,vs)
            (,v ,v . ,es)
            ((,(eqidd-for s) ,G ,v) . ,pp)
            ((((,v1 ,s) (,v2 ,s) . ,vs)
              (,v1 . ,pes)
              (,v2 . ,pes)
              (im ,G (,(eq-for s) ,v1 ,v2))
              (,v1 ,v2 . ,es)
              (,h0 . ,pp)) .
             ,(rmap data @ match-fn @ (b t1 t2 h es ps)
              '(((,v ,s) . ,b) (,v . ,t1) (,v . ,t2) ,h (,v ,v . ,es) ((,(eqidd-for s) ,G ,v) . ,ps)))))]])
    (def xs @ join @ rmap bis @ match-fn [(and (_ _) e) (list e)] [_ ()])
    @ rmap (match (mk-bis bis) [(_ _ _ _ data) data]) @ match-fn @ (vs t1 t2 h es ps)
      (def xs1 (map hd xs))
      (def vs+ (rmap vs @ match-fn @ (v s) '(,v ,s ,xs1)))
      @ list
        '((,G wff ()) . ,(append xs vs+))
        '((,h0 ,h))
        '(im ,G (,(eq-for ret) (,df . ,t1) (,df . ,t2)))
        (match (eqd-for df)
          [#undef (error @ string-append "equality theorem not found for " (->string df))]
          [eqd '(,eqd ,G . ,(append xs1 es ps))]))

  (def eval-map (atom-map!
    '[im ,(fn (a b) {(not (eval a)) or (eval b)})]
    '[not ,(fn (a) (not (eval a)))]))
  (set-merge-strategy eval-map merge-map)
  (def (eval e) @ match e @ ((? atom? t) . es)
    (apply
      (lookup eval-map t @ fn () @ error
        @ string-append "unknown function encountered during evaluation: " (->string t))
      es))

  --| This is used as an annotation.
  --| * `@(add-eval f) def foo ..` will add `f` as an evaluator for `foo`,
  --|   which is used by the `eval` function (which can evaluate many
  --|   closed terms of sort `nat` or `wff` to values).
  --| * `@(add-eval)` will attempt to evaluate the body of the definition
  --|   and use that as the result.
  (def ((add-eval . f) a)
    (if (def? @ lookup eval-map a) (error "already defined evaluation rule"))
    @ insert! eval-map a @ match f
    [(f) (if (fn? f) f (fn () f))]
    [() (def x @ eval @ nth 6 @ get-decl a) (fn () x)])

  --| `@eval-check` is an annotation that can be placed on theorems or axioms which
  --| are closed terms, and will check that the theorem/axiom evaluates to `#t`.
  --| This is not formally rigorous as the evaluator is not verified, but it can be
  --| viewed as a cross-check of the axiom or the evaluator, depending on your
  --| point of view.
  (def (eval-check a) @ match (eval @ nth 4 @ get-decl a) [#t])

  --| `(named pf)` wraps a proof script `pf`, runs it, then gathers all
  --| unassigned metavariables and assigns them to dummies.
  --| `(named x1 ... xn pf)` is the same but names the first `n` variables `x1,...,xn`.
  --| This is commonly used for proofs where we don't care to name the
  --| dummy variables.
  (def named
    (def (assign-mvar m x) @ match x ['_] [_ (set! m (dummy! x (mvar-sort m)))])
    @ match-fn*
      [((? atom? d) es) (refine es) (scan (get-mvars) (list d) assign-mvar)]
      [(ds es) (refine es) (scan (get-mvars) ds assign-mvar)]
      [(es) (refine es)
        (def n (ref! 1))
        (scan (get-mvars) @ fn (v)
          (assign-mvar v (atom-app "a" n)) (set! n {n + 1}))
        (if {n = 1} (display "unnecessary (named)"))])
};

-- configuration
do {
  (set-timeout 500)
  (def (refine-extra-args refine tgt e . ps)
    @ refine tgt (foldl ps (verb e) @ fn (acc p2) @ copy-span e '(mp ,acc ,p2)))
};

theorem a1i (h: $ bb $): $ aa -> bb $ = '(prop_1 h);
theorem a2i (h: $ aa -> bb -> c $): $ (aa -> bb) -> (aa -> c) $ = '(prop_2 h);
theorem mpd (h1: $ aa -> bb $) (h2: $ aa -> bb -> c $): $ aa -> c $ = '(prop_2 h2 h1);
theorem mpi (h1: $ bb $) (h2: $ aa -> bb -> c $): $ aa -> c $ = '(mpd (a1i h1) h2);
theorem id: $ aa -> aa $ = '(mpd (! prop_1 _ aa) prop_1);
theorem idd: $ aa -> bb -> bb $ = '(a1i id);
theorem syl (h1: $ bb -> c $) (h2: $ aa -> bb $): $ aa -> c $ = '(mpd h2 (a1i h1));
theorem rsyl (h1: $ aa -> bb $) (h2: $ bb -> c $): $ aa -> c $ = '(syl h2 h1);
theorem a1d (h: $ aa -> bb $): $ aa -> c -> bb $ = '(syl prop_1 h);
theorem a2d (h: $ aa -> bb -> c -> d $): $ aa -> (bb -> c) -> (bb -> d) $ = '(syl prop_2 h);
theorem a3d (h: $ aa -> ~bb -> ~c $): $ aa -> c -> bb $ = '(syl prop_3 h);
theorem sylc (h: $ bb -> c -> d $) (h1: $ aa -> bb $) (h2: $ aa -> c $): $ aa -> d $ = '(mpd h2 @ syl h h1);
theorem syld (h1: $ aa -> bb -> c $) (h2: $ aa -> c -> d $): $ aa -> bb -> d $ = '(mpd h1 @ a2d @ a1d h2);
theorem syl5 (h1: $ bb -> c $) (h2: $ aa -> c -> d $): $ aa -> bb -> d $ = '(syld (a1i h1) h2);
theorem syl6 (h1: $ c -> d $) (h2: $ aa -> bb -> c $): $ aa -> bb -> d $ = '(syld h2 (a1i h1));
theorem imim2: $ (bb -> c) -> (aa -> bb) -> (aa -> c) $ = '(a2d prop_1);
theorem imim2i (h: $ bb -> c $): $ (aa -> bb) -> (aa -> c) $ = '(imim2 h);
theorem imim2d (h: $ aa -> c -> d $): $ aa -> (bb -> c) -> (bb -> d) $ = '(syl imim2 h);
theorem absurd: $ ~aa -> aa -> bb $ = '(a3d prop_1);
theorem com12 (h: $ aa -> bb -> c $): $ bb -> aa -> c $ = '(syl (a2i h) prop_1);
theorem mpcom: $ aa -> (aa -> bb) -> bb $ = '(com12 id);
theorem com23 (h: $ aa -> bb -> c -> d $): $ aa -> c -> bb -> d $ = '(syl (com12 @ imim2d mpcom) h);
theorem eimd (h1: $ aa -> bb $) (h2: $ aa -> c -> d $): $ aa -> (bb -> c) -> d $ = '(syld (rsyl h1 mpcom) h2);
theorem absurdr: $ aa -> ~aa -> bb $ = '(com12 absurd);
theorem imim1: $ (aa -> bb) -> (bb -> c) -> (aa -> c) $ = '(com12 imim2);
theorem imim1i (h: $ aa -> bb $): $ (bb -> c) -> (aa -> c) $ = '(imim1 h);
theorem imim1d (h: $ aa -> bb -> c $): $ aa -> (c -> d) -> (bb -> d) $ = '(syl imim1 h);
theorem imimd (h1: $ aa -> bb -> c $) (h2: $ aa -> d -> e $):
  $ aa -> (c -> d) -> (bb -> e) $ = '(syld (imim1d h1) (imim2d h2));
theorem imim: $ (aa -> bb) -> (c -> d) -> (bb -> c) -> (aa -> d) $ = '(syl5 imim2 (imim2d imim1));
theorem imidm: $ (aa -> aa -> bb) -> aa -> bb $ = '(a2i mpcom);
theorem eim: $ aa -> (bb -> c) -> (aa -> bb) -> c $ = '(imim1d mpcom);
theorem contra: $ (~aa -> aa) -> aa $ = '(imidm (a3d (a2i absurd)));
theorem dne: $ ~~aa -> aa $ = '(syl contra absurd);
theorem inot: $ (aa -> ~aa) -> ~aa $ = '(syl contra (imim1 dne));
theorem con2: $ (aa -> ~bb) -> (bb -> ~aa) $ = '(a3d (syl5 dne id));
theorem notnot1: $ aa -> ~~aa $ = '(con2 id);
theorem con3: $ (aa -> bb) -> (~bb -> ~aa) $ = '(syl con2 (imim2i notnot1));
theorem con1: $ (~aa -> bb) -> (~bb -> aa) $ = '(a3d (imim2i notnot1));
theorem con4: $ (~aa -> ~bb) -> (bb -> aa) $ = '(syl (imim1 notnot1) con1);
theorem cases (h1: $ aa -> bb $) (h2: $ ~aa -> bb $): $ bb $ = '(contra @ syl h1 @ con1 h2);
theorem casesd (h1: $ aa -> bb -> c $) (h2: $ aa -> ~bb -> c $): $ aa -> c $ =
'(cases (com12 h1) (com12 h2));
theorem con1d (h: $ aa -> ~bb -> c $): $ aa -> ~c -> bb $ = '(syl con1 h);
theorem con2d (h: $ aa -> bb -> ~c $): $ aa -> c -> ~bb $ = '(syl con2 h);
theorem con3d (h: $ aa -> bb -> c $): $ aa -> ~c -> ~bb $ = '(syl con3 h);
theorem con4d (h: $ aa -> ~bb -> ~c $): $ aa -> c -> bb $ = '(syl prop_3 h);
theorem mt (h1: $ bb -> aa $) (h2: $ ~aa $): $ ~bb $ = '(con3 h1 h2);
theorem mt2 (h1: $ bb -> ~aa $) (h2: $ aa $): $ ~bb $ = '(con2 h1 h2);
theorem mtd (h1: $ aa -> ~bb $) (h2: $ aa -> c -> bb $): $ aa -> ~c $ = '(mpd h1 (con3d h2));
theorem mti (h1: $ ~bb $) (h2: $ aa -> c -> bb $): $ aa -> ~c $ = '(mtd (a1i h1) h2);
theorem mt2d (h1: $ aa -> c $) (h2: $ aa -> bb -> ~c $): $ aa -> ~bb $ = '(sylc con2 h2 h1);

theorem anl: $ aa /\ bb -> aa $ = '(con1 absurd);
theorem anr: $ aa /\ bb -> bb $ = '(con1 prop_1);
theorem anli (h: $ aa /\ bb $): $ aa $ = '(anl h);
theorem anri (h: $ aa /\ bb $): $ bb $ = '(anr h);
theorem ian: $ aa -> bb -> aa /\ bb $ = '(con2d mpcom);
theorem iand (h1: $ aa -> bb $) (h2: $ aa -> c $): $ aa -> bb /\ c $ = '(sylc ian h1 h2);
theorem anld (h: $ aa -> bb /\ c $): $ aa -> bb $ = '(syl anl h);
theorem anrd (h: $ aa -> bb /\ c $): $ aa -> c $ = '(syl anr h);
theorem iani (h1: $ aa $) (h2: $ bb $): $ aa /\ bb $ = '(ian h1 h2);
theorem anwl (h: $ aa -> c $): $ aa /\ bb -> c $ = '(syl h anl);
theorem anwr (h: $ bb -> c $): $ aa /\ bb -> c $ = '(syl h anr);
theorem anll: $ aa /\ bb /\ c -> aa $ = '(anwl anl);
theorem anlr: $ aa /\ bb /\ c -> bb $ = '(anwl anr);
theorem anrl: $ aa /\ (bb /\ c) -> bb $ = '(anwr anl);
theorem anrr: $ aa /\ (bb /\ c) -> c $ = '(anwr anr);
theorem anwll (h: $ aa -> d $): $ aa /\ bb /\ c -> d $ = '(anwl (anwl h));
theorem anw3l (h: $ aa -> e $): $ aa /\ bb /\ c /\ d -> e $ = '(anwll (anwl h));
theorem anw4l (h: $ aa -> f $): $ aa /\ bb /\ c /\ d /\ e -> f $ = '(anw3l (anwl h));
theorem anw5l (h: $ aa -> g $): $ aa /\ bb /\ c /\ d /\ e /\ f -> g $ = '(anw4l (anwl h));
theorem anw6l (x: $ aa -> h $): $ aa /\ bb /\ c /\ d /\ e /\ f /\ g -> h $ = '(anw5l (anwl x));
theorem anw7l (x: $ aa -> i $): $ aa /\ bb /\ c /\ d /\ e /\ f /\ g /\ h -> i $ = '(anw6l (anwl x));
theorem anllr: $ aa /\ bb /\ c /\ d -> bb $ = '(anwll anr);
theorem an3l: $ aa /\ bb /\ c /\ d -> aa $ = '(anwll anl);
theorem an3lr: $ aa /\ bb /\ c /\ d /\ e -> bb $ = '(anwl anllr);
theorem an4l: $ aa /\ bb /\ c /\ d /\ e -> aa $ = '(anwl an3l); -- TODO: automate these
theorem an4lr: $ aa /\ bb /\ c /\ d /\ e /\ f -> bb $ = '(anwl an3lr);
theorem an5l: $ aa /\ bb /\ c /\ d /\ e /\ f -> aa $ = '(anwl an4l);
theorem an5lr: $ aa /\ bb /\ c /\ d /\ e /\ f /\ g -> bb $ = '(anwl an4lr);
theorem an6l: $ aa /\ bb /\ c /\ d /\ e /\ f /\ g -> aa $ = '(anwl an5l);
theorem an6lr: $ aa /\ bb /\ c /\ d /\ e /\ f /\ g /\ h -> bb $ = '(anwl an5lr);
theorem an7l: $ aa /\ bb /\ c /\ d /\ e /\ f /\ g /\ h -> aa $ = '(anwl an6l);
theorem an7lr: $ aa /\ bb /\ c /\ d /\ e /\ f /\ g /\ h /\ i -> bb $ = '(anwl an6lr);
theorem an8l: $ aa /\ bb /\ c /\ d /\ e /\ f /\ g /\ h /\ i -> aa $ = '(anwl an7l);
theorem an8lr: $ aa /\ bb /\ c /\ d /\ e /\ f /\ g /\ h /\ i /\ j -> bb $ = '(anwl an7lr);
theorem an9l: $ aa /\ bb /\ c /\ d /\ e /\ f /\ g /\ h /\ i /\ j -> aa $ = '(anwl an8l);
theorem an9lr: $ aa /\ bb /\ c /\ d /\ e /\ f /\ g /\ h /\ i /\ j /\ k -> bb $ = '(anwl an8lr);
theorem curry (h: $ aa -> bb -> c $): $ aa /\ bb -> c $ = '(sylc h anl anr);
theorem exp (h: $ aa /\ bb -> c $): $ aa -> bb -> c $ = '(syl6 h ian);
theorem impcom (h: $ aa -> bb -> c $): $ bb /\ aa -> c $ = '(curry (com12 h));
theorem expcom (h: $ aa /\ bb -> c $): $ bb -> aa -> c $ = '(com12 (exp h));
theorem syla (h1: $ (bb -> c) -> d $) (h2: $ aa /\ bb -> c $): $ aa -> d $ = '(syl h1 @ exp h2);
theorem sylan (h: $ bb /\ c -> d $) (h1: $ aa -> bb $) (h2: $ aa -> c $):
  $ aa -> d $ = '(syl h @ iand h1 h2);
theorem animd (h1: $ aa -> bb -> c $) (h2: $ aa -> d -> e $): $ aa -> bb /\ d -> c /\ e $ =
'(exp (iand (curry (syl5 anl h1)) (curry (syl5 anr h2))));
theorem anim1d (h: $ aa -> bb -> c $): $ aa -> bb /\ d -> c /\ d $ = '(animd h idd);
theorem anim2d (h: $ aa -> c -> d $): $ aa -> bb /\ c -> bb /\ d $ = '(animd idd h);
theorem anim1: $ (aa -> bb) -> aa /\ c -> bb /\ c $ = '(anim1d id);
theorem anim2: $ (bb -> c) -> aa /\ bb -> aa /\ c $ = '(anim2d id);
theorem anim: $ (aa -> bb) -> (c -> d) -> aa /\ c -> bb /\ d $ =
'(exp @ syld (anim1d anl) (anim2d anr));
theorem anim2a: $ (aa -> bb -> c) -> (aa /\ bb -> aa /\ c) $ =
'(exp @ iand anrl @ mpd anrr @ mpd anrl anl);
theorem ancom: $ aa /\ bb -> bb /\ aa $ = '(iand anr anl);
theorem anrasss (h: $ aa /\ bb /\ c -> d $): $ aa /\ c /\ bb -> d $ =
'(sylan h (iand anll anr) anlr);
theorem anim1a: $ (aa -> bb -> c) -> (bb /\ aa -> c /\ aa) $ =
'(syl6 ancom @ syl5 ancom anim2a);
theorem casesda (h1: $ aa /\ bb -> c $) (h2: $ aa /\ ~bb -> c $): $ aa -> c $ =
'(casesd (exp h1) (exp h2));
theorem inotda (h: $ aa /\ bb -> ~bb $): $ aa -> ~bb $ = '(syla inot h);
theorem mpand (h1: $ aa -> bb $) (h2: $ aa /\ bb -> c $): $ aa -> c $ = '(mpd h1 (exp h2));
theorem mtand (h1: $ aa -> ~bb $) (h2: $ aa /\ c -> bb $): $ aa -> ~c $ = '(mtd h1 (exp h2));
theorem mtani (h1: $ ~bb $) (h2: $ aa /\ c -> bb $): $ aa -> ~c $ = '(mtand (a1i h1) h2);

theorem bi1: $ (aa <-> bb) -> aa -> bb $ = 'anl;
theorem bi1i (h: $ aa <-> bb $): $ aa -> bb $ = '(bi1 h);
theorem bi1d (h: $ aa -> (bb <-> c) $): $ aa -> bb -> c $ = '(syl bi1 h);
theorem bi1a (h: $ aa -> (bb <-> c) $): $ aa /\ bb -> c $ = '(curry @ bi1d h);
theorem bi2: $ (aa <-> bb) -> bb -> aa $ = 'anr;
theorem bi2i (h: $ aa <-> bb $): $ bb -> aa $ = '(bi2 h);
theorem bi2d (h: $ aa -> (bb <-> c) $): $ aa -> c -> bb $ = '(syl bi2 h);
theorem bi2a (h: $ aa -> (bb <-> c) $): $ aa /\ c -> bb $ = '(curry @ bi2d h);
theorem ibii (h1: $ aa -> bb $) (h2: $ bb -> aa $): $ aa <-> bb $ = '(iani h1 h2);
theorem ibid (h1: $ aa -> bb -> c $) (h2: $ aa -> c -> bb $): $ aa -> (bb <-> c) $ = '(iand h1 h2);
theorem ibida (h1: $ aa /\ bb -> c $) (h2: $ aa /\ c -> bb $): $ aa -> (bb <-> c) $ = '(ibid (exp h1) (exp h2));
theorem biid: $ aa <-> aa $ = '(ibii id id);
theorem biidd: $ aa -> (bb <-> bb) $ = '(a1i biid);
theorem mpbi (h1: $ aa <-> bb $) (h2: $ aa $): $ bb $ = '(bi1i h1 h2);
theorem mpbir (h1: $ bb <-> aa $) (h2: $ aa $): $ bb $ = '(bi2i h1 h2);
theorem mpbid (h1: $ aa -> (bb <-> c) $) (h2: $ aa -> bb $): $ aa -> c $ = '(mpd h2 (bi1d h1));
theorem mpbird (h1: $ aa -> (c <-> bb) $) (h2: $ aa -> bb $): $ aa -> c $ = '(mpd h2 (bi2d h1));
theorem mpbii (h1: $ bb $) (h2: $ aa -> (bb <-> c) $): $ aa -> c $ = '(mpbid h2 (a1i h1));
theorem mpbiri (h1: $ bb $) (h2: $ aa -> (c <-> bb) $): $ aa -> c $ = '(mpbird h2 (a1i h1));
theorem mtbi (h1: $ aa <-> bb $) (h2: $ ~aa $): $ ~bb $ = '(mt (bi2 h1) h2);
theorem mtbir (h1: $ bb <-> aa $) (h2: $ ~aa $): $ ~bb $ = '(mt (bi1 h1) h2);
theorem mtbid (h1: $ aa -> (bb <-> c) $) (h2: $ aa -> ~bb $): $ aa -> ~c $ = '(mtd h2 (bi2d h1));
theorem mtbird (h1: $ aa -> (c <-> bb) $) (h2: $ aa -> ~bb $): $ aa -> ~c $ = '(mtd h2 (bi1d h1));
theorem con1b: $ (~aa <-> bb) -> (~bb <-> aa) $ = '(ibid (con1d bi1) (con2d bi2));
theorem con2b: $ (aa <-> ~bb) -> (bb <-> ~aa) $ = '(ibid (con2d bi1) (con1d bi2));
theorem con3b: $ (aa <-> bb) -> (~aa <-> ~bb) $ = '(ibid (con3d bi2) (con3d bi1));
theorem con4b: $ (~aa <-> ~bb) -> (aa <-> bb) $ = '(ibid (con4d bi2) (con4d bi1));
theorem con1bb: $ (~aa <-> bb) <-> (~bb <-> aa) $ = '(ibii con1b con1b);
theorem con2bb: $ (aa <-> ~bb) <-> (bb <-> ~aa) $ = '(ibii con2b con2b);
theorem con3bb: $ (aa <-> bb) <-> (~aa <-> ~bb) $ = '(ibii con3b con4b);
theorem con1bi: $ (~aa -> bb) <-> (~bb -> aa) $ = '(ibii con1 con1);
theorem con2bi: $ (aa -> ~bb) <-> (bb -> ~aa) $ = '(ibii con2 con2);
theorem con3bi: $ (aa -> bb) <-> (~bb -> ~aa) $ = '(ibii con3 prop_3);
theorem notnot: $ aa <-> ~~aa $ = '(ibii notnot1 dne);
theorem bithd (h1: $ aa -> bb $) (h2: $ aa -> c $): $ aa -> (bb <-> c) $ = '(ibid (a1d h2) (a1d h1));
theorem binthd (h1: $ aa -> ~bb $) (h2: $ aa -> ~c $): $ aa -> (bb <-> c) $ = '(syl con4b @ bithd h1 h2);
theorem bith: $ aa -> bb -> (aa <-> bb) $ = '(exp @ bithd anl anr);
theorem binth: $ ~aa -> ~bb -> (aa <-> bb) $ = '(exp @ binthd anl anr);
theorem bicom: $ (aa <-> bb) -> (bb <-> aa) $ = '(ibid bi2 bi1);
theorem bicomb: $ (aa <-> bb) <-> (bb <-> aa) $ = '(ibii bicom bicom);
theorem bicomd (h: $ aa -> (bb <-> c) $): $ aa -> (c <-> bb) $ = '(syl bicom h);
theorem bitrd (h1: $ aa -> (bb <-> c) $) (h2: $ aa -> (c <-> d) $): $ aa -> (bb <-> d) $ =
'(ibid (syld (bi1d h1) (bi1d h2)) (syld (bi2d h2) (bi2d h1)));
theorem bitr2d (h1: $ aa -> (bb <-> c) $) (h2: $ aa -> (c <-> d) $): $ aa -> (d <-> bb) $ = '(bicomd (bitrd h1 h2));
theorem bitr3d (h1: $ aa -> (c <-> bb) $) (h2: $ aa -> (c <-> d) $): $ aa -> (bb <-> d) $ = '(bitrd (bicomd h1) h2);
theorem bitr4d (h1: $ aa -> (bb <-> c) $) (h2: $ aa -> (d <-> c) $): $ aa -> (bb <-> d) $ = '(bitrd h1 (bicomd h2));
theorem bitr: $ (aa <-> bb) -> (bb <-> c) -> (aa <-> c) $ = '(exp (bitrd anl anr));
theorem bitr2: $ (aa <-> bb) -> (bb <-> c) -> (c <-> aa) $ = '(exp (bitr2d anl anr));
theorem bitr3: $ (bb <-> aa) -> (bb <-> c) -> (aa <-> c) $ = '(exp (bitr3d anl anr));
theorem bitr4: $ (aa <-> bb) -> (c <-> bb) -> (aa <-> c) $ = '(exp (bitr4d anl anr));
theorem bisylr: $ (c <-> bb) -> (aa <-> bb) -> (aa <-> c) $ = '(rsyl bicom @ com23 id bitr);
theorem sylib (h1: $ bb <-> c $) (h2: $ aa -> bb $): $ aa -> c $ = '(syl (bi1i h1) h2);
theorem sylibr (h1: $ c <-> bb $) (h2: $ aa -> bb $): $ aa -> c $ = '(syl (bi2i h1) h2);
theorem sylbi (h1: $ aa <-> bb $) (h2: $ bb -> c $): $ aa -> c $ = '(syl h2 (bi1i h1));
theorem sylbir (h1: $ bb <-> aa $) (h2: $ bb -> c $): $ aa -> c $ = '(syl h2 (bi2i h1));
theorem syl5bb (h1: $ bb <-> c $) (h2: $ aa -> (c <-> d) $): $ aa -> (bb <-> d) $ = '(bitrd (a1i h1) h2);
theorem syl5bbr (h1: $ c <-> bb $) (h2: $ aa -> (c <-> d) $): $ aa -> (bb <-> d) $ = '(syl5bb (bicom h1) h2);
theorem syl6bb (h1: $ c <-> d $) (h2: $ aa -> (bb <-> c) $): $ aa -> (bb <-> d) $ = '(bitrd h2 (a1i h1));
theorem syl6bbr (h1: $ d <-> c $) (h2: $ aa -> (bb <-> c) $): $ aa -> (bb <-> d) $ = '(syl6bb (bicom h1) h2);
theorem syl5bi (h1: $ bb <-> c $) (h2: $ aa -> c -> d $): $ aa -> bb -> d $ = '(syl5 (bi1 h1) h2);
theorem syl5bir (h1: $ c <-> bb $) (h2: $ aa -> c -> d $): $ aa -> bb -> d $ = '(syl5bi (bicom h1) h2);
theorem syl6ib (h1: $ c <-> d $) (h2: $ aa -> bb -> c $): $ aa -> bb -> d $ = '(syl6 (bi1 h1) h2);
theorem syl6ibr (h1: $ d <-> c $) (h2: $ aa -> bb -> c $): $ aa -> bb -> d $ = '(syl6 (bi2 h1) h2);
theorem syl5ibrcom (h1: $ c -> (bb <-> d) $) (h2: $ aa -> d $): $ aa -> c -> bb $ = '(com12 @ syl5 h2 (bi2d h1));
theorem sylbid (h1: $ aa -> (bb <-> c) $) (h2: $ aa -> c -> d $): $ aa -> bb -> d $ = '(syld (bi1d h1) h2);
theorem sylibd (h1: $ aa -> bb -> c $) (h2: $ aa -> (c <-> d) $): $ aa -> bb -> d $ = '(syld h1 (bi1d h2));
theorem sylbird (h1: $ aa -> (c <-> bb) $) (h2: $ aa -> c -> d $): $ aa -> bb -> d $ = '(syld (bi2d h1) h2);
theorem sylibrd (h1: $ aa -> bb -> c $) (h2: $ aa -> (d <-> c) $): $ aa -> bb -> d $ = '(syld h1 (bi2d h2));
theorem bitr3g (h1: $ bb <-> d $) (h2: $ c <-> e $) (h: $ aa -> (bb <-> c) $):
  $ aa -> (d <-> e) $ = '(syl5bb (bicom h1) @ syl6bb h2 h);
theorem bitr4g (h1: $ d <-> bb $) (h2: $ e <-> c $) (h: $ aa -> (bb <-> c) $):
  $ aa -> (d <-> e) $ = '(syl5bb h1 @ syl6bb (bicom h2) h);
theorem bitr3gi (h1: $ aa <-> c $) (h2: $ bb <-> d $) (h: $ aa <-> bb $): $ c <-> d $ = '(bitr3 h1 @ bitr h h2);
theorem bitr4gi (h1: $ c <-> aa $) (h2: $ d <-> bb $) (h: $ aa <-> bb $): $ c <-> d $ = '(bitr h1 @ bitr4 h h2);
theorem impbi (h: $ aa -> (bb <-> c) $): $ aa /\ bb -> c $ = '(curry @ bi1d h);
theorem impbir (h: $ aa -> (c <-> bb) $): $ aa /\ bb -> c $ = '(curry @ bi2d h);
theorem ancomb: $ aa /\ bb <-> bb /\ aa $ = '(ibii ancom ancom);
theorem anass: $ aa /\ bb /\ c <-> aa /\ (bb /\ c) $ =
'(ibii (iand anll (anim1 anr)) (iand (anim2 anl) anrr));
theorem bian2a: $ (aa -> bb) -> (aa /\ bb <-> aa) $ = '(ibid (a1i anl) (a2i ian));
theorem bian1a: $ (bb -> aa) -> (aa /\ bb <-> bb) $ = '(syl5bb ancomb bian2a);
theorem bian1: $ aa -> (aa /\ bb <-> bb) $ = '(syl bian1a prop_1);
theorem bian2: $ bb -> (aa /\ bb <-> aa) $ = '(syl bian2a prop_1);
theorem bibi1: $ aa -> ((aa <-> bb) <-> bb) $ = '(ibid (com12 bi1) bith);
theorem bibi2: $ bb -> ((aa <-> bb) <-> aa) $ = '(syl5bb bicomb bibi1);
theorem noteq: $ (aa <-> bb) -> (~aa <-> ~bb) $ = 'con3b;
theorem noteqi (h: $ aa <-> bb $): $ ~aa <-> ~bb $ = '(noteq h);
theorem noteqd (h: $ aa -> (bb <-> c) $): $ aa -> (~bb <-> ~c) $ = '(syl noteq h);
theorem imeqd
  (h1: $ aa -> (bb <-> c) $) (h2: $ aa -> (d <-> e) $): $ aa -> (bb -> d <-> c -> e) $ =
'(ibid (imimd (bi2d h1) (bi1d h2)) (imimd (bi1d h1) (bi2d h2)));
theorem bibin1: $ ~aa -> ((aa <-> bb) <-> ~bb) $ = '(ibid (com12 @ bi1d noteq) binth);
theorem bibin2: $ ~bb -> ((aa <-> bb) <-> ~aa) $ = '(syl5bb bicomb bibin1);
theorem imeq1d (h: $ aa -> (bb <-> c) $): $ aa -> (bb -> d <-> c -> d) $ = '(imeqd h biidd);
theorem imeq2d (h: $ aa -> (c <-> d) $): $ aa -> (bb -> c <-> bb -> d) $ = '(imeqd biidd h);
theorem imeq1i (h: $ aa <-> bb $): $ aa -> c <-> bb -> c $ = '(imeq1d id h);
theorem imeq2i (h: $ bb <-> c $): $ aa -> bb <-> aa -> c $ = '(imeq2d id h);
theorem imeqi (h1: $ aa <-> bb $) (h2: $ c <-> d $): $ aa -> c <-> bb -> d $ = '(bitr (imeq1i h1) (imeq2i h2));
theorem aneqd
  (h1: $ aa -> (bb <-> c) $) (h2: $ aa -> (d <-> e) $): $ aa -> (bb /\ d <-> c /\ e) $ =
'(ibid (animd (bi1d h1) (bi1d h2)) (animd (bi2d h1) (bi2d h2)));
theorem imeq2a: $ (aa -> (bb <-> c)) -> (aa -> bb <-> aa -> c) $ = '(ibid (a2d @ imim2i bi1) (a2d @ imim2i bi2));
theorem imeq1a: $ (~c -> (aa <-> bb)) -> (aa -> c <-> bb -> c) $ = '(bitr4g con3bi con3bi @ syl imeq2a @ imim2i noteq);
theorem imeq2da (h: $ G /\ aa -> (bb <-> c) $): $ G -> (aa -> bb <-> aa -> c) $ = '(syl imeq2a @ exp h);
theorem aneq1d (h: $ aa -> (bb <-> c) $): $ aa -> (bb /\ d <-> c /\ d) $ = '(aneqd h biidd);
theorem aneq2d (h: $ aa -> (c <-> d) $): $ aa -> (bb /\ c <-> bb /\ d) $ = '(aneqd biidd h);
theorem aneq: $ (aa <-> bb) -> (c <-> d) -> (aa /\ c <-> bb /\ d) $ = '(exp @ aneqd anl anr);
theorem aneq1i (h: $ aa <-> bb $): $ aa /\ c <-> bb /\ c $ = '(aneq1d id h);
theorem aneq2i (h: $ bb <-> c $): $ aa /\ bb <-> aa /\ c $ = '(aneq2d id h);
theorem aneq2a: $ (aa -> (bb <-> c)) -> (aa /\ bb <-> aa /\ c) $ =
'(ibid (syl anim2a @ imim2i bi1) (syl anim2a @ imim2i bi2));
theorem aneq1a: $ (c -> (aa <-> bb)) -> (aa /\ c <-> bb /\ c) $ = '(syl5bb ancomb @ syl6bb ancomb aneq2a);
theorem aneq1da (h: $ G /\ c -> (aa <-> bb) $): $ G -> (aa /\ c <-> bb /\ c) $ = '(syl aneq1a @ exp h);
theorem aneq2da (h: $ G /\ aa -> (bb <-> c) $): $ G -> (aa /\ bb <-> aa /\ c) $ = '(syl aneq2a @ exp h);
theorem anlass: $ aa /\ (bb /\ c) <-> bb /\ (aa /\ c) $ =
'(bitr3 anass @ bitr (aneq1i ancomb) anass);
theorem anrass: $ aa /\ bb /\ c <-> aa /\ c /\ bb $ =
'(bitr anass @ bitr4 (aneq2i ancomb) anass);
theorem an4: $ (aa /\ bb) /\ (c /\ d) <-> (aa /\ c) /\ (bb /\ d) $ =
'(bitr4 anass @ bitr4 anass @ aneq2i anlass);
theorem anroti (h: $ aa -> bb /\ d $): $ aa /\ c -> bb /\ c /\ d $ = '(sylib anrass @ anim1 h);
theorem anrotri (h: $ bb /\ d -> aa $): $ bb /\ c /\ d -> aa /\ c $ = '(sylbi anrass @ anim1 h);
theorem bian11i (h: $ aa <-> bb /\ c $): $ aa /\ d <-> bb /\ (c /\ d) $ = '(bitr (aneq1i h) anass);
theorem bian21i (h: $ aa <-> bb /\ c $): $ aa /\ d <-> (bb /\ d) /\ c $ = '(bitr (aneq1i h) anrass);
theorem bian12i (h: $ aa <-> bb /\ c $): $ d /\ aa <-> bb /\ (d /\ c) $ = '(bitr (aneq2i h) anlass);
theorem bian22i (h: $ aa <-> bb /\ c $): $ d /\ aa <-> (d /\ bb) /\ c $ = '(bitr4 (aneq2i h) anass);
theorem bian11d (h: $ G -> (aa <-> bb /\ c) $): $ G -> (aa /\ d <-> bb /\ (c /\ d)) $ = '(syl6bb anass (aneq1d h));
theorem bian21d (h: $ G -> (aa <-> bb /\ c) $): $ G -> (aa /\ d <-> (bb /\ d) /\ c) $ = '(syl6bb anrass (aneq1d h));
theorem bian12d (h: $ G -> (aa <-> bb /\ c) $): $ G -> (d /\ aa <-> bb /\ (d /\ c)) $ = '(syl6bb anlass (aneq2d h));
theorem bian22d (h: $ G -> (aa <-> bb /\ c) $): $ G -> (d /\ aa <-> (d /\ bb) /\ c) $ = '(syl6bbr anass (aneq2d h));
theorem bian11da (h: $ G /\ d -> (aa <-> bb /\ c) $): $ G -> (aa /\ d <-> bb /\ (c /\ d)) $ = '(syl6bb anass (aneq1da h));
theorem bian21da (h: $ G /\ d -> (aa <-> bb /\ c) $): $ G -> (aa /\ d <-> (bb /\ d) /\ c) $ = '(syl6bb anrass (aneq1da h));
theorem bian12da (h: $ G /\ d -> (aa <-> bb /\ c) $): $ G -> (d /\ aa <-> bb /\ (d /\ c)) $ = '(syl6bb anlass (aneq2da h));
theorem bian22da (h: $ G /\ d -> (aa <-> bb /\ c) $): $ G -> (d /\ aa <-> (d /\ bb) /\ c) $ = '(syl6bbr anass (aneq2da h));
theorem anidm: $ aa /\ aa <-> aa $ = '(ibii anl (iand id id));
theorem anandi: $ aa /\ (bb /\ c) <-> (aa /\ bb) /\ (aa /\ c) $ = '(bitr3 (aneq1i anidm) an4);
theorem anandir: $ (aa /\ bb) /\ c <-> (aa /\ c) /\ (bb /\ c) $ = '(bitr3 (aneq2i anidm) an4);
theorem imandi: $ (aa -> bb /\ c) <-> (aa -> bb) /\ (aa -> c) $ =
'(ibii (iand (imim2i anl) (imim2i anr)) (com12 @ animd mpcom mpcom));
theorem imancom: $ aa /\ (bb -> c) -> bb -> aa /\ c $ = '(com12 @ anim2d mpcom);
theorem rbida (h1: $ aa /\ c -> bb $) (h2: $ aa /\ d -> bb $)
  (h: $ aa /\ bb -> (c <-> d) $): $ aa -> (c <-> d) $ =
'(bitr3d (syla bian2a h1) @ bitrd (syla aneq1a h) (syla bian2a h2));
theorem rbid (h1: $ bb -> aa $) (h2: $ c -> aa $) (h: $ aa -> (bb <-> c) $): $ bb <-> c $ =
'(bitr3 (bian2a h1) @ bitr (aneq1a h) (bian2a h2));
theorem bieqd
  (h1: $ aa -> (bb <-> c) $) (h2: $ aa -> (d <-> e) $): $ aa -> ((bb <-> d) <-> (c <-> e)) $ =
'(aneqd (imeqd h1 h2) (imeqd h2 h1));
theorem bieq1d (h: $ aa -> (bb <-> c) $): $ aa -> ((bb <-> d) <-> (c <-> d)) $ = '(bieqd h biidd);
theorem bieq2d (h: $ aa -> (c <-> d) $): $ aa -> ((bb <-> c) <-> (bb <-> d)) $ = '(bieqd biidd h);
theorem bieq: $ (aa <-> bb) -> (c <-> d) -> ((aa <-> c) <-> (bb <-> d)) $ = '(exp (bieqd anl anr));
theorem bieq1: $ (aa <-> bb) -> ((aa <-> c) <-> (bb <-> c)) $ = '(bieq1d id);
theorem bieq2: $ (bb <-> c) -> ((aa <-> bb) <-> (aa <-> c)) $ = '(bieq2d id);
theorem impexp: $ (aa /\ bb -> c) <-> (aa -> bb -> c) $ =
'(ibii (exp @ exp @ mpd (anim1 anr) anll) (exp @ mpd anrr @ mpd anrl anl));
theorem impd (h: $ aa -> bb -> c -> d $): $ aa -> bb /\ c -> d $ = '(sylibr impexp h);
theorem expd (h: $ aa -> bb /\ c -> d $): $ aa -> bb -> c -> d $ = '(sylib impexp h);
theorem com12b: $ (aa -> bb -> c) <-> (bb -> aa -> c) $ = '(ibii (com23 id) (com23 id));

theorem orl: $ aa -> aa \/ bb $ = 'absurdr;
theorem orr: $ bb -> aa \/ bb $ = 'prop_1;
theorem eori (h1: $ aa -> c $) (h2: $ bb -> c $): $ aa \/ bb -> c $ =
'(casesd (a1i h1) (imim2i h2));
theorem eord (h1: $ aa -> bb -> d $) (h2: $ aa -> c -> d $):
  $ aa -> bb \/ c -> d $ = '(com12 (eori (com12 h1) (com12 h2)));
theorem eorda (h1: $ aa /\ bb -> d $) (h2: $ aa /\ c -> d $):
  $ aa -> bb \/ c -> d $ = '(eord (exp h1) (exp h2));
theorem orld (h: $ aa -> bb $): $ aa -> bb \/ c $ = '(syl orl h);
theorem orrd (h: $ aa -> c $): $ aa -> bb \/ c $ = '(syl orr h);
theorem eor: $ (aa -> c) -> (bb -> c) -> aa \/ bb -> c $ = '(exp (eord anl anr));
theorem orimd (h1: $ aa -> bb -> c $) (h2: $ aa -> d -> e $): $ aa -> bb \/ d -> c \/ e $ =
'(eord (syl6 orl h1) (syl6 orr h2));
theorem orim1d (h: $ aa -> bb -> c $): $ aa -> bb \/ d -> c \/ d $ = '(orimd h idd);
theorem orim2d (h: $ aa -> c -> d $): $ aa -> bb \/ c -> bb \/ d $ = '(orimd idd h);
theorem orim1: $ (aa -> bb) -> aa \/ c -> bb \/ c $ = '(orim1d id);
theorem orim2: $ (bb -> c) -> aa \/ bb -> aa \/ c $ = '(orim2d id);
theorem oreq1d: $ (aa <-> bb) -> (aa \/ c <-> bb \/ c) $ = '(anim orim1 orim1);
theorem oreq2d: $ (aa <-> bb) -> (c \/ aa <-> c \/ bb) $ = '(anim orim2 orim2);
theorem oreq1i (h: $ aa <-> bb $): $ aa \/ c <-> bb \/ c $ = '(oreq1d h);
theorem oreq2i (h: $ bb <-> c $): $ aa \/ bb <-> aa \/ c $ = '(oreq2d h);
theorem orim: $ (aa -> bb) -> (c -> d) -> aa \/ c -> bb \/ d $ = '(exp @ syld (anwl orim1) (anwr orim2));
theorem oreq: $ (aa <-> bb) -> (c <-> d) -> (aa \/ c <-> bb \/ d) $ = '(syl5 oreq2d @ syl bitr oreq1d);
theorem oreqi (h1: $ aa <-> bb $) (h2: $ c <-> d $): $ aa \/ c <-> bb \/ d $ = '(bitr (oreq1i h1) (oreq2i h2));
theorem orcom: $ aa \/ bb -> bb \/ aa $ = 'con1;
theorem orcomb: $ aa \/ bb <-> bb \/ aa $ = '(ibii orcom orcom);
theorem or12: $ aa \/ (bb \/ c) <-> bb \/ (aa \/ c) $ = '(bitr3 impexp @ bitr (imeq1i ancomb) impexp);
theorem orass: $ aa \/ bb \/ c <-> aa \/ (bb \/ c) $ = '(bitr orcomb @ bitr or12 @ imeq2i orcomb);
-- theorem or4: $ (aa \/ bb) \/ (c \/ d) <-> (aa \/ c) \/ (bb \/ d) $ = '(bitr4 orass @ bitr4 orass @ oreq2 or12);
theorem oridm: $ aa \/ aa <-> aa $ = '(ibii (eor id id) orl);
theorem notan2: $ ~(aa /\ bb) <-> aa -> ~bb $ = '(bicom notnot);
theorem notan: $ ~(aa /\ bb) <-> (~aa \/ ~bb) $ = '(bitr notan2 (imeq1i notnot));
theorem notor: $ ~(aa \/ bb) <-> (~aa /\ ~bb) $ = '(con1b (bitr4 notan (oreqi notnot notnot)));
theorem iman: $ aa -> bb <-> ~(aa /\ ~bb) $ = '(bitr4 (imeq2i notnot) notan2);
theorem imor: $ ((aa \/ bb) -> c) <-> ((aa -> c) /\ (bb -> c)) $ =
'(ibii (iand (imim1i orl) (imim1i orr)) (curry eor));
theorem andi: $ aa /\ (bb \/ c) <-> aa /\ bb \/ aa /\ c $ =
'(ibii (curry @ orimd ian ian) @ eor (anim2 orl) (anim2 orr));
theorem andir: $ (aa \/ bb) /\ c <-> aa /\ c \/ bb /\ c $ =
'(bitr ancomb @ bitr andi @ oreqi ancomb ancomb);
theorem ordi: $ aa \/ (bb /\ c) <-> (aa \/ bb) /\ (aa \/ c) $ =
'(ibii (iand (orim2 anl) (orim2 anr)) @ com12 @ animd mpcom mpcom);
theorem ordir: $ (aa /\ bb) \/ c <-> (aa \/ c) /\ (bb \/ c) $ =
'(bitr orcomb @ bitr ordi @ aneq orcomb orcomb);
theorem oreq2a: $ (~aa -> (bb <-> c)) -> (aa \/ bb <-> aa \/ c) $ = 'imeq2a;
theorem oreq1a: $ (~c -> (aa <-> bb)) -> (aa \/ c <-> bb \/ c) $ = '(syl5bb orcomb @ syl6bb orcomb oreq2a);
theorem biim1a: $ (~aa -> bb) -> (aa -> bb <-> bb) $ = '(ibid (exp @ casesd anr anl) (a1i prop_1));
theorem biim2a: $ (bb -> ~aa) -> (aa -> bb <-> ~aa) $ = '(ibid (exp @ syl inot @ curry imim2) (a1i absurd));
theorem bior1a: $ (aa -> bb) -> (aa \/ bb <-> bb) $ = '(sylbi (imeq1i notnot) biim1a);
theorem bior2a: $ (bb -> aa) -> (aa \/ bb <-> aa) $ = '(syl5bb orcomb bior1a);
theorem biim1: $ aa -> (aa -> bb <-> bb) $ = '(syl biim1a absurdr);
theorem biim2: $ ~bb -> (aa -> bb <-> ~aa) $ = '(syl biim2a absurd);
theorem bior1: $ ~aa -> (aa \/ bb <-> bb) $ = '(syl bior1a absurd);
theorem bior2: $ ~bb -> (aa \/ bb <-> aa) $ = '(syl bior2a absurd);
theorem em: $ p \/ ~p $ = 'id;
theorem emr: $ ~p \/ p $ = '(orcom em);

theorem ian2: $ aa -> bb -> bb /\ aa $ = '(exp ancom);
theorem absurdum: $ bot -> phi $ = '(prop_3 idd);
theorem taut: $ top $ = 'absurdum;
theorem imp_top: $ phi -> top $ = '(a1i taut);
theorem top_or: $ top \/ phi $ = '(syl absurdum dne);
theorem bot_or: $ (bot \/ aa) -> aa $ = '(mpcom taut);
theorem top_and: $ phi -> top /\ phi $ = '(com12 bot_or);

theorem imp_to_or (h: $(~aa \/ bb) -> c$): $(aa -> bb) -> c$  = '(rsyl con3 (rsyl orcom h)) ;

theorem not_distr_or: $ ~(aa \/ bb) <-> ~aa /\ ~bb $ = 'notor;
theorem and_distr: $ aa /\ (bb /\ c) <-> (aa /\ bb) /\ (aa /\ c) $ =
  '(ibii
    (   rsyl (anim1 @ anr anidm)
      @ rsyl (anl anass)
      @ rsyl (anim2 @ anl anlass)
             (anr anass))
    (rsyl (rsyl (anl anass) anr) (anl anlass)));

theorem appl: $ (aa /\ (aa -> bb)) -> bb $ = '(con1 @ anl com12b @ con3d mpcom);

--- analogs to anl and anr; Would prefer: $~(aa -> bb) <-> (aa /\ ~bb)$
theorem neg_imp_left: $ ~(aa -> bb) -> aa $ = '(con1 absurd);
theorem neg_imp_right: $ ~(aa -> bb) -> ~bb $ = '(con3 prop_1);
theorem neg_imp_wl(h: $ aa -> c $): $ ~(aa -> bb) -> c $ = '(syl h neg_imp_left);
theorem neg_imp_wr(h: $ ~bb -> c $): $ ~(aa -> bb) -> c $ = '(syl h neg_imp_right);

theorem or_imp_xor_and: $ aa \/ bb -> (~(aa <-> bb) \/ (aa /\ bb)) $ =
  '( eori (! cases bb _ (expcom orr)
                       @ expcom @ syl orl @ com12 @ curry @ com23 @ impd @ a2i @ a1i absurdr
          )
          (! cases aa _ (exp orr)
                       @ expcom @ syl orl @ com12 @ curry @ com12 @ com23 @ impd @ a2i @ a1i absurdr
          ) );
theorem xor_and_imp_or: $ (~(aa <-> bb) \/ (aa /\ bb)) -> aa \/ bb $ =
 '(eori (syl (imp_to_or (eori (neg_imp_wl orl) (neg_imp_wl orr))) dne)
        (anwl orl)
  );

theorem lemma_51: $ ((aa /\ ~bb) \/ (bb /\ ~aa)) <-> ~(aa <-> bb) $ = '(iani
  (eori (con3 @ rsyl anl @ imim2i notnot1)
        (rsyl ancom @ con3 @ rsyl anr con3))
  (con1 @ rsyl (anl not_distr_or) @ anim (anr iman) (anr iman)));

theorem lemma_in_in_reverse_helper: $ (~aa \/ bb) -> (~aa \/ (bb /\ aa)) $ =
  '(syl (orim2 @ anim2 dne) @ syl anr bian1a);

theorem lemma_60_helper_1: $ aa -> (aa /\ ~bb) \/ (aa /\ bb) $ =
  '(syl (anl andi) @ iand id @ a1i emr);

theorem lemma_60_helper_2: $ aa -> ~bb \/ (aa /\ bb) $ =
  '(syl (imim1i dne) ian);

theorem bisquare (h1: $aa <-> bb$) (h2: $d <-> c$) (h3: $bb <-> c$): $aa <-> d$ =
  '(bitr h1 @ bisylr h2 h3);

theorem Fprop: $ (aa -> bb) -> (c -> d) -> (bb -> d -> e) -> (aa -> c -> e) $ =
  '(syl (anl impexp) @ com12 @ imim2d @ curry @ imim2d imim1);

theorem an_top_bi_l: $ phi /\ top <-> phi $ = '(ibii anl @ syl ancom top_and);
theorem an_top_bi_r: $ top /\ phi <-> phi $ = '(ibii anr top_and);
theorem an_bot_bi_l: $ phi /\ bot <-> bot $ = '(ibii anr absurdum);
theorem an_bot_bi_r: $ bot /\ phi <-> bot $ = '(ibii anl absurdum);

theorem or_bot_bi_l: $ phi \/ bot <-> phi $ = '(ibii (eori id absurdum) orl);
theorem or_bot_bi_r: $ bot \/ phi <-> phi $ = '(ibii (eori absurdum id) orr);

theorem or_or_not_an: $ aa \/ bb <-> aa \/ (~aa /\ bb) $ =
  '(bitr (bitr (bicom an_top_bi_r) @ aneq1i @ ibii (a1i em) imp_top) @ bicom ordi);

theorem absurd_an: $~aa /\ aa <-> bot$ = '(ibii (impcom mpcom) absurdum);
theorem absurd_an_r: $aa /\ ~aa <-> bot$ = '(ibii (curry mpcom) absurdum);

theorem imp_or_split: $ (aa -> bb \/ c) -> (aa -> bb) \/ (aa -> c) $ =
  '(rsyl (anr impexp) @ orim (imim2 dne) prop_1);

theorem iand4 (h1: $ aa -> bb $) (h2: $ aa -> c $) (h3: $ aa -> d $) (h4: $ aa -> e $): $ aa -> bb /\ c /\ d /\ e $ =
  '(iand (iand (iand h1 h2) h3) h4);
