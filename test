#!/usr/bin/env bash
set -euo pipefail
test_dir=.build


### Helpers #######################

function error_handler(){
    local last_status_code=$1;
    local error_line_number=$2;
    echo 1>&2 "====== Error: exited with status $last_status_code at line $error_line_number";
}
trap  'error_handler $? $LINENO' ERR

warn_unproved() {
    echo "===== Warning: the following are unproved:"
    for f in $(ls *.mm1); do
        [[ ! "$f" == *theory* ]] || continue
        sed -n \
            -e 's/--.*//' "$f" \
            -e 's/^ *axiom *\([a-zA-Z0-9_]*\).*/\1/p' "$f" \
            | tr '\n' ' '
    done
    echo
}

join()      { mm0-rs join "$1" "$2" ; }                         # join    <input> <output>
compile()   { mm0-rs compile -q --warn-as-error "$1" "$2" ; }   # compile <input> <output>
check()     { mm0-c  "$1" < "$2" ; }                            # check   <mmb>   <mm0>

test_mm() {
    mm0_file="$1"; shift
    mm1_file="$1"; shift
    test_name="$(basename $mm1_file)"
    test_basename="$test_dir/$test_name"
    test_extension="${test_name##*.}"
    echo "Testing: $test_name."

    # There seems to be a bug in mm0-rs that causes the program to crash
    # when compiling un-joined files.
    join "$mm1_file" "$test_basename".joined."$test_extension"
    compile "$test_basename".joined."$test_extension" "$test_basename".mmb
    check "$test_basename".mmb "$mm0_file"
}

test_regex() {
    theorem="$1"; shift
    test_name="$1"; shift
    regexp="$1"; shift

    test_basename="$test_dir/$test_name"
    ./proof-gen.py mm0 "$theorem" "$regexp" > "$test_basename".mm0
    join "$test_basename".mm0 "$test_basename".joined.mm0
    ./proof-gen.py mm1 "$theorem" "$regexp" > "$test_basename".mm1
    test_mm "$test_basename".joined.mm0 "$test_basename".mm1
}

### Main #######################

mkdir -p "$test_dir"
warn_unproved
last_mm0_file=
for f in $(ls *.mm0 *.mm1 | sort); do
    [[ $f != *.mm0 ]] || {
        last_mm0_file="$test_dir/joined.$f"
        join "$f" "$last_mm0_file"
    }
    test_mm "$last_mm0_file" "$f"
done
test_regex 'main-goal'        'a-or-b-star'                '(a + b)*'
test_regex 'fp-implies-regex' 'kleene-star-star'           '(a *) * ->> (a *)'
test_regex 'fp-implies-regex' 'example-in-paper'           '(a . a)* ->> (((a *) . a) + epsilon) '
test_regex 'fp-implies-regex' 'alternate-top'              '((a *) . b) * + (((b *) . a) *)'
test_regex 'fp-implies-regex' 'even-or-odd'                '((((a . a) + (a . b)) + (b . a)) + (b . b)) * + ((a + b) . (((((a . a) + (a . b)) + (b . a)) + (b . b)) *))'
test_regex 'fp-implies-regex' 'no-contains-a-or-no-only-b' '(~ (top . (a . top))) + ~ (b *)'

# Benchmarks:
# Unified Decision Procedures for Regular Expression Equivalence
# From: https://citeseerx.ist.psu.edu/document?repid=rep1&type=pdf&doi=f650281fc011a2c132690903eb443ff1ab3298f7
test_regex 'fp-implies-regex' 'match-r-4'                  'match-r(4)'
test_regex 'fp-implies-regex' 'match-r-10'                 'match-r(10)'
test_regex 'fp-implies-regex' 'match-r-20'                 'match-r(20)'
test_regex 'fp-implies-regex' 'match-r-30'                 'match-r(30)'
test_regex 'fp-implies-regex' 'match-l-4'                  'match-l(4)'
test_regex 'fp-implies-regex' 'match-l-10'                 'match-l(10)'
test_regex 'fp-implies-regex' 'match-l-20'                 'match-l(20)'
test_regex 'fp-implies-regex' 'match-l-30'                 'match-l(30)'
test_regex 'fp-implies-regex' 'match-l-100'                'match-l(100)'
test_regex 'fp-implies-regex' 'eq-l-4'                     'eq-l(4)'
test_regex 'fp-implies-regex' 'eq-l-10'                    'eq-l(10)'
test_regex 'fp-implies-regex' 'eq-l-20'                    'eq-l(20)'
test_regex 'fp-implies-regex' 'eq-l-30'                    'eq-l(30)'
test_regex 'fp-implies-regex' 'eq-r-4'                     'eq-r(4)'
test_regex 'fp-implies-regex' 'eq-r-10'                    'eq-r(10)'
test_regex 'fp-implies-regex' 'eq-r-20'                    'eq-r(20)'
test_regex 'fp-implies-regex' 'eq-r-30'                    'eq-r(30)'

echo Passed.
