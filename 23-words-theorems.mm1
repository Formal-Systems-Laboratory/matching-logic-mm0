import "13-fixedpoints.mm1";
import "21-words-helpers.mm1";
import "22-assumptions.mm0";

--- Lift axioms to higher level constructs
------------------------------------------

--- Lift functional axioms to $ a . [] $ and $ b . [] $.
theorem functional_a_concat {.w x v: EVar} :
  $ exists x (eVar x == a . eVar v) $ =
  (functional_subst_implicit 'w $exists x (eVar x == (eVar w . eVar v))$ 'functional_concat '(! functional_a k));
theorem functional_b_concat {.w x v: EVar} :
  $ exists x (eVar x == b . eVar v) $ =
  (functional_subst_implicit 'w $exists x (eVar x == (eVar w . eVar v))$ 'functional_concat '(! functional_b k));

theorem regex_eq_eps_concat_l: $ epsilon . Alpha <-> Alpha $ =
  '(bitr (cong_of_equiv_concat_r @ bicom lemma_62) @
    bitr (norm (norm_equiv appCtxRVar @ norm_exists appCtxRVar) (! exists_appCtx x box1)) @
    bitr (cong_of_equiv_exists @
      bitr (norm (norm_equiv appCtxRVar @ norm_and_r appCtxRVar) (! lemma_60_b _ box2)) @
      cong_of_equiv_and_r @ corollary_57_floor (! identity_right_e x))
    (! lemma_62 _ x));
theorem regex_eq_eps_concat_r: $ Alpha . epsilon <-> Alpha $ =
  '(bitr (cong_of_equiv_concat_l @ bicom lemma_62) @
    bitr (norm (norm_equiv appCtxLRVar @ norm_exists appCtxLRVar) (! exists_appCtx x box1)) @
    bitr (cong_of_equiv_exists @
      bitr (norm (norm_equiv appCtxLRVar @ norm_and_r appCtxLRVar) (! lemma_60_b _ box2)) @
      cong_of_equiv_and_r @ corollary_57_floor (! identity_left_e x))
    (! lemma_62 _ x));

theorem regex_eq_ewp_ab
  (h: $ letter -> top_letter $):
  $ epsilon /\ letter <-> bot $
  = '(ibii
    (exists_generalization_strict
      (com12
        (eq_to_imp (eq_to_def @ eq_to_and_l eq_to_intro) (eq_to_not @ eq_to_and_l eq_to_intro))
        (con2 (dne @ singleton_norm (! appCtxVar box1) (! defNorm box2))) -- |^ x /\ ~a ^| <-> ~(x /\ a)
      ) (exists_framing eq_sym (! functional_epsilon x))
      (framing_def (con3 @ imim2i @ syl h dne) @ dne no_confusion_ae_e))
    absurdum);

theorem def_a: $|^ a ^|$ =
  (functional_subst_implicit 'w $|^ eVar w ^|$ 'definedness '(! functional_a w));
theorem def_b: $|^ b ^|$ =
  (functional_subst_implicit 'w $|^ eVar w ^|$ 'definedness '(! functional_b w));

theorem a_in_top_letter: $|^ a /\ top_letter ^|$ =
  '(framing_def (iand id orl) def_a);
theorem b_in_top_letter: $|^ b /\ top_letter ^|$ =
  '(framing_def (iand id orr) def_b);

theorem no_confusion_cc_e_asym {u x y: EVar} : $(x in top_letter) -> (y in top_letter)
                            -> (eVar x . eVar u == eVar y) -> (eVar x == eVar y) /\ (eVar u == epsilon)$ =
  '(syl (imim2i @ imim1i @ com12 eq_trans @ eq_sym identity_left_e)
    ,(functional_subst_implicit 'v $(x in top_letter) -> (y in top_letter) -> (eVar x . eVar u == eVar y . eVar v) -> (eVar x == eVar y) /\ (eVar u == eVar v)$ 'no_confusion_cc_e '(! functional_epsilon w))
  );

--- Proving the Empty Word Property
-----------------------------------

theorem epsilon_implies_top :
  $ epsilon -> top $
= '(con2 absurdum);

theorem epsilon_implies_kleene {X: SVar} (phi: Pattern X)
  (h: $ _Positive X phi $):
  $ epsilon -> kleene X phi $ =
  '(rsyl orl (norm (norm_imp_l
    ,(propag_s_subst 'X $epsilon \/ phi . sVar X$)
    ) @ pre_fixpoint @ positive_in_kleene_r_body h));

theorem epsilon_implies_concat (phi psi : Pattern)
    (h1: $epsilon -> phi$)
    (h2: $epsilon -> psi$)
  : $epsilon -> (phi . psi)$
= '( rsyl (bi1i @ bicom regex_eq_eps_concat_r)
   @ rsyl (framing_concat_l h1)
   @ rsyl (framing_concat_r h2)
     id);

theorem epsilon_implies_not_letter (letter : Pattern)
    (h: $letter -> top_letter$)
  : $epsilon -> ~ letter$
= '(exp (bi1i @ regex_eq_ewp_ab h))
  ;

theorem epsilon_implies_not_and_l (phi psi : Pattern)
    (h: $epsilon -> ~ phi$)
  : $epsilon -> ~ (phi /\ psi)$
= '(rsyl (orld h) (bi1i @ bicom notan));
theorem  epsilon_implies_not_and_r (phi psi : Pattern)
    (h: $epsilon -> ~ psi$)
  : $epsilon -> ~ (phi /\ psi)$
= '(rsyl (orrd h) (bi1i @ bicom notan));

theorem epsilon_implies_not_or (phi psi : Pattern)
    (h1: $epsilon -> ~ phi$)
    (h2: $epsilon -> ~ psi$)
  : $epsilon -> ~ (phi \/ psi)$
= '(rsyl (iand h1 h2) (bi1i @ bicom notor));

theorem epsilon_implies_not_concat_l (phi psi : Pattern)
    (h: $epsilon -> ~ phi$)
  : $epsilon -> ~ (phi . psi)$
= '( exp
   @ rsyl (bi1i @ regex_eq_ewp_concat)
   @ anwl
   @ curry h );
theorem epsilon_implies_not_concat_r (phi psi : Pattern)
    (h: $epsilon -> ~ psi$)
  : $epsilon -> ~ (phi . psi)$
= '( exp
   @ rsyl (bi1i @ regex_eq_ewp_concat)
   @ anwr
   @ curry h );


theorem regex_eq_ewp_bot:
  $ (epsilon /\ bot) <-> bot $ = '(ibii anr absurdum);
theorem regex_eq_ewp_epsilon:
  $ epsilon /\ epsilon <-> epsilon $ = 'anidm;
theorem regex_eq_ewp_a:
  $ epsilon /\ a <-> bot $ = '(regex_eq_ewp_ab orl);
theorem regex_eq_ewp_b:
  $ epsilon /\ b <-> bot $ = '(regex_eq_ewp_ab orr);
theorem regex_eq_ewp_and:
  $ epsilon /\ (Alpha /\ Beta) <-> (epsilon /\ Alpha) /\ (epsilon /\ Beta) $ = 'anandi;
theorem regex_eq_ewp_choice:
  $ epsilon /\ (Alpha \/ Beta) <-> (epsilon /\ Alpha) \/ (epsilon /\ Beta) $ = 'andi;
theorem regex_eq_ewp_kleene {X: SVar} (Alpha: Pattern X)
  (h: $ _Positive X Alpha $):
  $ epsilon /\ (kleene X Alpha) <-> epsilon $ =
  '(ibii anl @ iand id @ epsilon_implies_kleene h);

theorem regex_eq_ewp_not_bot: $ (epsilon /\ ~bot) <-> epsilon $ =
  '(ibii anl @ syl ancom top_and);
theorem regex_eq_ewp_not_eps: $ (epsilon /\ ~epsilon) <-> bot $ =
  '(ibii (notnot1 notnot1) absurdum);
theorem regex_eq_ewp_not_a: $ (epsilon /\ ~a) <-> epsilon $ =
  '(ibii anl @ iand id @ dne @ anl regex_eq_ewp_a);
theorem regex_eq_ewp_not_b: $ (epsilon /\ ~b) <-> epsilon $ =
  '(ibii anl @ iand id @ dne @ anl regex_eq_ewp_b);
theorem regex_eq_ewp_not_and: $ (epsilon /\ ~(Alpha /\ Beta)) <-> ((epsilon /\ ~ Alpha) \/ (epsilon /\ ~ Beta)) $ =
  '(bitr (cong_of_equiv_and_r notan) andi);
theorem regex_eq_ewp_not_choice: $ (epsilon /\ ~(Alpha \/ Beta)) <-> ((epsilon /\ ~ Alpha) /\ (epsilon /\ ~ Beta)) $ =
  '(bitr (cong_of_equiv_and_r not_distr_or) and_distr);
theorem regex_eq_ewp_not_kleene {X: SVar} (Alpha: Pattern X)
  (h: $ _Positive X Alpha $):
  $ (epsilon /\ ~(kleene X Alpha)) <-> bot $ =
  '(ibii (notnot1 @ syl notnot1 @ epsilon_implies_kleene h) absurdum);
theorem regex_eq_ewp_not_not: $ (epsilon /\ ~(~ Alpha)) <-> (epsilon /\ Alpha) $ =
  '(cong_of_equiv_and_r @ bicom notnot);


--- Simplifications used in generated proofs
--------------------------------------------

--- Identity and idemoptency of \/
theorem regex_eq_or_choice_abs: $ top \/ Alpha <-> top $ = '(ibii imp_top @ a1i top_or);
theorem regex_eq_or_choice_unit: $ bot \/ Alpha <-> Alpha $ = '(ibii bot_or prop_1);
theorem regex_eq_or_choice_idem_node: $ Alpha \/ (Alpha \/ Beta) <-> Alpha \/ Beta$ = '(ibii (eori orl id) orr);
theorem regex_eq_or_choice_idem_leaf: $ Alpha \/ Alpha <-> Alpha $ = 'oridm;
theorem regex_eq_or_choice_assoc: $ (Alpha \/ Beta) \/ Gamma <-> Alpha \/ (Beta \/ Gamma) $ = 'orass;
theorem regex_eq_or_choice_comm_node: $ Alpha \/ (Beta \/ Gamma) <-> Beta \/ (Alpha \/ Gamma) $ = 'or12;
theorem regex_eq_or_choice_comm_leaf: $ Alpha \/ Beta <-> Beta \/ Alpha $ = 'orcomb;

--- Identity and idemoptency of /\
theorem regex_eq_and_choice_abs: $ bot /\ Alpha <-> bot $ = '(ibii anl absurdum);
theorem regex_eq_and_choice_unit: $ top /\ Alpha <-> Alpha $ = '(ibii anr top_and);
theorem regex_eq_and_choice_idem_node: $ Alpha /\ (Alpha /\ Beta) <-> Alpha /\ Beta$ = '(bicom @ bian11i @ bicom anidm);
theorem regex_eq_and_choice_idem_leaf: $ Alpha /\ Alpha <-> Alpha $ = 'anidm;
theorem regex_eq_and_choice_assoc: $ (Alpha /\ Beta) /\ Gamma <-> Alpha /\ (Beta /\ Gamma) $ = 'anass;
theorem regex_eq_and_choice_comm_node: $ Alpha /\ (Beta /\ Gamma) <-> Beta /\ (Alpha /\ Gamma) $ = 'anlass;
theorem regex_eq_and_choice_comm_leaf: $ Alpha /\ Beta <-> Beta /\ Alpha $ = 'ancomb;

theorem regex_eq_bot_concat_l: $ bot . Alpha <-> bot $ =
  '(ibii (norm (norm_not appCtxLRVar) (! propag_bot box)) absurdum);
theorem regex_eq_bot_concat_r: $ Alpha . bot <-> bot $ =
  '(ibii (norm (norm_not appCtxRVar) (! propag_bot box)) absurdum);
theorem regex_eq_double_neg: $ ~ (~ Alpha) <-> Alpha $ = '(bicom notnot);
theorem regex_eq_bot_kleene: $ (kleene X bot) <-> epsilon $ = '(ibii
  (rsyl (mu_framing (positive_in_or positive_disjoint @ positive_in_concat positive_disjoint positive_in_same_sVar) positive_disjoint (rsyl (orim2 @ norm (norm_imp_l appCtxLRVar) (! propag_bot box)) dne)) (KT positive_disjoint @ norm (norm_sym @ norm_imp_l sSubstitution_disjoint) id))
  (epsilon_implies_kleene positive_disjoint));

theorem regex_eq_eps_kleene {X: SVar}: $ (kleene X epsilon) <-> epsilon $ =
  '(ibii
    (KT (positive_in_kleene_r_body positive_disjoint) @ norm (norm_sym @ norm_imp_l ,(propag_s_subst 'Y $epsilon \/ (epsilon . sVar Y)$)) @ eori id @ eq_to_intro ,(functional_subst_implicit 'u $(eVar u) . epsilon == (eVar u)$ 'identity_left_e '(! functional_epsilon w)))
    (imim1i orl @ norm (norm_imp_l ,(propag_s_subst 'Y $epsilon \/ (epsilon . sVar Y)$)) @ pre_fixpoint (positive_in_kleene_r_body positive_disjoint))
  );

--- Derivatives: "Semantic" theorems
------------------------------------

--- The following theorems lift ctximp_in_ctx to derivatives.
theorem der_in_ctx_reverse
  : $w2 -> w1 . (derivative w1 w2)$
= '(norm_lemma_r (norm_sym appctx_concat_r ) (! ctximp_in_ctx_reverse box dummy ));
theorem der_in_ctx_forward : $w1 . (derivative w1 w2) -> w2$
 = '(norm_lemma (norm_sym @ norm_trans appCtxR (norm_app norm_refl appCtxVar))
                (! ctximp_in_ctx_forward dummy1 _ dummy _ )
    );

--- main theorem for deriviatives
theorem der_equality:
    $phi == (epsilon /\ phi) \/ ((a . (derivative a phi)) \/ (b . (derivative b phi)))$
= '(equiv_to_eq @ ibii
    (mp (! unfold_l_top_word_r X _ @ eori (exp @ orld id)
                                    (rsyl propag_or_concat @ eori
                                      (exp @ orrd @ orld @ rsyl (anwr id) der_in_ctx_reverse)
                                      (exp @ orrd @ orrd @ rsyl (anwr id) der_in_ctx_reverse)
                                    ))
        domain_words)
    (eori anr @ eori der_in_ctx_forward der_in_ctx_forward)
  ) ;


--- Derivatives: Syntactic Simplifications
------------------------------------------

theorem der_expand (l: Pattern) (phi: Pattern):
  $ (derivative l phi) <-> exists d (eVar d /\ ((l . eVar d) C_ phi)) $ =
  '(norm (norm_equiv_r @ norm_exists @ norm_and_r @ norm_floor @ norm_imp_l (! appCtxRVar box _ _)) biid);
theorem l_der_phi_imp_phi (l phi: Pattern):
  $ (l . derivative l phi) -> phi $ =
  '(norm (norm_imp_l appCtxRVar) (! unwrap box _ _ _ dummy id));


do {
  (def (der_transformer x y l phi) '(ibii
    (exists_generalization_strict @ curry @ syl anr ,(functional_subst_helper 'y $(l . eVar y) C_ phi$))
    (rsyl (ian eq_refl) @ norm (norm_imp_l ,(propag_e_subst_adv 'x $(eVar y == eVar x) /\ ((l . eVar x) C_ phi)$ (atom-map! '[l #t] '[phi #t]))) exists_intro)
  ))
};
theorem der_transformer_test_1 {x y: EVar} (phi: Pattern):
  $ (exists x ((eVar y == eVar x) /\ ((a . eVar x) C_ (~ phi)))) <-> ((a . eVar y) C_ (~ phi)) $ =
  (der_transformer 'x 'y 'a $~ phi$);


theorem regex_eq_der_bot
  (h: $ exists x (eVar x == A) $):
  $ (derivative A bot) -> bot $
  = '(exists_generalization_strict @ con3 anr @ notnot1 @ framing_def notnot1 @
    exists_generalization_strict (com12
      (eq_to_def @ norm (norm_imp_r @ norm_imp_r @ norm_sym @ norm_trans appCtxR @ norm_app norm_refl (! appCtxVar box)) @ eq_to_app_l @ eq_to_app_r eq_to_intro)
      (exists_generalization_strict (com12 (eq_to_def eq_to_intro) definedness)
          (! functional_concat x v1 x1))
        ) h
  );
theorem regex_eq_der_bot_wrt_a:
  $ (derivative a bot) <-> bot $ = '(ibii (regex_eq_der_bot (! functional_a x)) absurdum);
theorem regex_eq_der_bot_wrt_b:
  $ (derivative b bot) <-> bot $ = '(ibii (regex_eq_der_bot (! functional_b x)) absurdum);

theorem regex_eq_der_epsilon_wrt_a:
  $ (derivative a epsilon) <-> bot $ =
  '(ibii (rsyl (anl der_expand) @ syl not_exists_bot @ exists_framing @ con3 anr @
    rsyl ,(functional_subst_implicit 'x $((a . eVar d) C_ eVar x) -> ((a . eVar d) == eVar x)$ (
        functional_subst_implicit 'y $((eVar y . eVar d) C_ eVar x) -> ((eVar y . eVar d) == eVar x)$ (
          functional_subst_implicit 'z $(eVar z C_ eVar x) -> (eVar z == eVar x)$ '(eVars_subset_eq_forward) '(! functional_concat _ _ k)
        ) '(! functional_a w1)
      ) '(! functional_epsilon w2)) @
    rsyl eq_sym @
    rsyl ,(functional_subst_implicit 'x $(epsilon == eVar x . eVar d) -> ((epsilon == eVar x) /\ (epsilon == eVar d))$ '(! no_confusion_ec_e _ d) '(! functional_a w3)) @
      con3 anl @ con3 (rsyl eq_imp_subset subset_imp_subset_or_l) no_confusion_ae_e
  ) absurdum);
theorem regex_eq_der_epsilon_wrt_b:
  $ (derivative b epsilon) <-> bot $ =
  '(ibii (rsyl (anl der_expand) @ syl not_exists_bot @ exists_framing @ con3 anr @
    rsyl ,(functional_subst_implicit 'x $((b . eVar d) C_ eVar x) -> ((b . eVar d) == eVar x)$ (
        functional_subst_implicit 'y $((eVar y . eVar d) C_ eVar x) -> ((eVar y . eVar d) == eVar x)$ (
          functional_subst_implicit 'z $(eVar z C_ eVar x) -> (eVar z == eVar x)$ '(eVars_subset_eq_forward) '(! functional_concat _ _ k)
        ) '(! functional_b w1)
      ) '(! functional_epsilon w2)) @
    rsyl eq_sym @
    rsyl ,(functional_subst_implicit 'x $(epsilon == eVar x . eVar d) -> ((epsilon == eVar x) /\ (epsilon == eVar d))$ '(! no_confusion_ec_e _ d) '(! functional_b w3)) @
      con3 anl @ con3 (rsyl eq_imp_subset subset_imp_subset_or_r) no_confusion_ae_e
  ) absurdum);
theorem regex_eq_der_diff_a_wrt_a:
  $ (derivative a b) <-> bot $ =
  '(ibii (rsyl (anl der_expand) @ syl not_exists_bot @ exists_framing @ con3 anr @
    rsyl ,(functional_subst_implicit 'x $((a . eVar d) C_ eVar x) -> ((a . eVar d) == eVar x)$ (
        functional_subst_implicit 'y $((eVar y . eVar d) C_ eVar x) -> ((eVar y . eVar d) == eVar x)$ (
          functional_subst_implicit 'z $(eVar z C_ eVar x) -> (eVar z == eVar x)$ '(eVars_subset_eq_forward) '(! functional_concat _ _ k)
        ) '(! functional_a w1)
      ) '(! functional_b w2)) @
      syl no_confusion_ab_e @ syl anl @ mp
      ,(functional_subst_implicit 'y $|^ a /\ top_letter ^| -> (y in top_letter) -> (a . eVar u == eVar y) -> (a == eVar y) /\ (eVar u == epsilon)$
        (functional_subst_implicit 'x $(x in top_letter) -> (y in top_letter) -> (eVar x . eVar u == eVar y) -> (eVar x == eVar y) /\ (eVar u == epsilon)$ '(! no_confusion_cc_e_asym w3) '(! functional_a w5))
        '(! functional_b w4)) a_in_top_letter b_in_top_letter
  ) absurdum);
theorem regex_eq_der_diff_a_wrt_b:
  $ (derivative b a) <-> bot $ =
  '(ibii (rsyl (anl der_expand) @ syl not_exists_bot @ exists_framing @ con3 anr @
    rsyl ,(functional_subst_implicit 'x $((b . eVar d) C_ eVar x) -> ((b . eVar d) == eVar x)$ (
        functional_subst_implicit 'y $((eVar y . eVar d) C_ eVar x) -> ((eVar y . eVar d) == eVar x)$ (
          functional_subst_implicit 'z $(eVar z C_ eVar x) -> (eVar z == eVar x)$ '(eVars_subset_eq_forward) '(! functional_concat _ _ k)
        ) '(! functional_b w1)
      ) '(! functional_a w2)) @
      syl no_confusion_ab_e @ syl eq_sym @ syl anl @ mp
      ,(functional_subst_implicit 'y $|^ b /\ top_letter ^| -> (y in top_letter) -> (b . eVar u == eVar y) -> (b == eVar y) /\ (eVar u == epsilon)$
        (functional_subst_implicit 'x $(x in top_letter) -> (y in top_letter) -> (eVar x . eVar u == eVar y) -> (eVar x == eVar y) /\ (eVar u == epsilon)$ '(! no_confusion_cc_e_asym w3) '(! functional_b w5))
        '(! functional_a w4)) b_in_top_letter a_in_top_letter
  ) absurdum);

theorem regex_eq_der_choice_wrt_a: $ (derivative a (Alpha \/ Beta)) <-> (derivative a Alpha) \/ (derivative a Beta) $ =
  '(bitr (! der_expand d1) @
    bitr (
      membership_elim_implicit @ anr
        ,(propag_mem 'y $(exists x (eVar x /\ ((a . eVar x) C_ (Alpha \/ Beta)))) <-> ((exists x (eVar x /\ ((a . eVar x) C_ Alpha))) \/ (exists x (eVar x /\ ((a . eVar x) C_ Beta))))$) @
          bitr ,(der_transformer 'x 'y 'a $Alpha \/ Beta$) @
          bitr ,(functional_subst_implicit 'x $(eVar x C_ Alpha \/ Beta) <-> (eVar x C_ Alpha) \/ (eVar x C_ Beta)$ '(
            bitr eVar_in_subset_rev @ bitr membership_or_bi (cong_of_equiv_or eVar_in_subset eVar_in_subset)
          ) '(! functional_a_concat d2 x)) @
          bicom @ cong_of_equiv_or ,(der_transformer 'x 'y 'a $Alpha$) ,(der_transformer 'x 'y 'a $Beta$)) @
    bicom @ cong_of_equiv_or (! der_expand d1) (! der_expand d1));
theorem regex_eq_der_choice_wrt_b: $ (derivative b (Alpha \/ Beta)) <-> (derivative b Alpha) \/ (derivative b Beta) $ =
  '(bitr (! der_expand d1) @
    bitr (
      membership_elim_implicit @ anr
        ,(propag_mem 'y $(exists x (eVar x /\ ((b . eVar x) C_ (Alpha \/ Beta)))) <-> ((exists x (eVar x /\ ((b . eVar x) C_ Alpha))) \/ (exists x (eVar x /\ ((b . eVar x) C_ Beta))))$) @
          bitr ,(der_transformer 'x 'y 'b $Alpha \/ Beta$) @
          bitr ,(functional_subst_implicit 'x $(eVar x C_ Alpha \/ Beta) <-> (eVar x C_ Alpha) \/ (eVar x C_ Beta)$ '(
            bitr eVar_in_subset_rev @ bitr membership_or_bi (cong_of_equiv_or eVar_in_subset eVar_in_subset)
          ) '(! functional_b_concat d2 x)) @
          bicom @ cong_of_equiv_or ,(der_transformer 'x 'y 'b $Alpha$) ,(der_transformer 'x 'y 'b $Beta$)) @
    bicom @ cong_of_equiv_or (! der_expand d1) (! der_expand d1));
theorem regex_eq_der_conj_wrt_a: $ (derivative a (Alpha /\ Beta)) <-> (derivative a Alpha) /\ (derivative a Beta) $ =
  '(bitr (! der_expand d1) @
    bitr (
      membership_elim_implicit @ anr
        ,(propag_mem 'y $(exists x (eVar x /\ ((a . eVar x) C_ (Alpha /\ Beta)))) <-> ((exists x (eVar x /\ ((a . eVar x) C_ Alpha))) /\ (exists x (eVar x /\ ((a . eVar x) C_ Beta))))$) @
          bitr ,(der_transformer 'x 'y 'a $Alpha /\ Beta$) @
          bitr ,(functional_subst_implicit 'x $(eVar x C_ Alpha /\ Beta) <-> (eVar x C_ Alpha) /\ (eVar x C_ Beta)$ '(
            bitr eVar_in_subset_rev @ bitr membership_and_bi (cong_of_equiv_and eVar_in_subset eVar_in_subset)
          ) '(! functional_a_concat d2 x)) @
          bicom @ cong_of_equiv_and ,(der_transformer 'x 'y 'a $Alpha$) ,(der_transformer 'x 'y 'a $Beta$)) @
    bicom @ cong_of_equiv_and (! der_expand d1) (! der_expand d1));
theorem regex_eq_der_conj_wrt_b: $ (derivative b (Alpha /\ Beta)) <-> (derivative b Alpha) /\ (derivative b Beta) $ =
  '(bitr (! der_expand d1) @
    bitr (
      membership_elim_implicit @ anr
        ,(propag_mem 'y $(exists x (eVar x /\ ((b . eVar x) C_ (Alpha /\ Beta)))) <-> ((exists x (eVar x /\ ((b . eVar x) C_ Alpha))) /\ (exists x (eVar x /\ ((b . eVar x) C_ Beta))))$) @
          bitr ,(der_transformer 'x 'y 'b $Alpha /\ Beta$) @
          bitr ,(functional_subst_implicit 'x $(eVar x C_ Alpha /\ Beta) <-> (eVar x C_ Alpha) /\ (eVar x C_ Beta)$ '(
            bitr eVar_in_subset_rev @ bitr membership_and_bi (cong_of_equiv_and eVar_in_subset eVar_in_subset)
          ) '(! functional_b_concat d2 x)) @
          bicom @ cong_of_equiv_and ,(der_transformer 'x 'y 'b $Alpha$) ,(der_transformer 'x 'y 'b $Beta$)) @
    bicom @ cong_of_equiv_and (! der_expand d1) (! der_expand d1));
theorem regex_eq_der_neg_wrt_a: $ (derivative a (~ Alpha)) <-> ~ (derivative a Alpha) $ =
  '(bitr (! der_expand d1) @
    bitr (
      membership_elim_implicit @ anr
        ,(propag_mem 'y $(exists x (eVar x /\ ((a . eVar x) C_ ~ Alpha))) <-> ~ (exists x (eVar x /\ ((a . eVar x) C_ Alpha)))$) @
          bitr ,(der_transformer 'x 'y 'a $~ Alpha$) @
          bitr (cong_of_equiv_not ,(functional_subst_implicit 'x $(x in Alpha) <-> (eVar x C_ Alpha)$ 'eVar_in_subset '(! functional_a_concat d2 x))) @
          bicom @ cong_of_equiv_not ,(der_transformer 'x 'y 'b $Alpha$)) @
    bicom @ cong_of_equiv_not (! der_expand d1));
theorem regex_eq_der_neg_wrt_b: $ (derivative b (~ Alpha)) <-> ~ (derivative b Alpha) $ =
  '(bitr (! der_expand d1) @
    bitr (
      membership_elim_implicit @ anr
        ,(propag_mem 'y $(exists x (eVar x /\ ((b . eVar x) C_ ~ Alpha))) <-> ~ (exists x (eVar x /\ ((b . eVar x) C_ Alpha)))$) @
          bitr ,(der_transformer 'x 'y 'b $~ Alpha$) @
          bitr (cong_of_equiv_not ,(functional_subst_implicit 'x $(x in Alpha) <-> (eVar x C_ Alpha)$ 'eVar_in_subset '(! functional_b_concat d2 x))) @
          bicom @ cong_of_equiv_not ,(der_transformer 'x 'y 'b $Alpha$)) @
    bicom @ cong_of_equiv_not (! der_expand d1));

theorem inductive_domain_l_implies_r { X : SVar }
  : $(top_word_l X) -> (top_word_r X)$
  = '( kt_top_word_l
           ( unfold_r_top_word_r orl)
           ( norm (norm_imp (! appctx_concat_l _) norm_refl)
                  (unwrap @ kt_top_word_r
                    (wrap ( norm ( norm_sym  (norm_imp (! appctx_concat_l _) norm_refl) )
                            (sylbi regex_eq_eps_concat_l
                            @ unfold_r_top_word_r @ orrd
                            @ sylbir regex_eq_eps_concat_r
                            @ framing_concat_r
                            @ unfold_r_top_word_r orl)
                          )
                    )
                    @ syl (bi2i (! alpha_rename_ctximp_app sBox eBox1 eBox2))
                    (wrap ( norm ( norm_sym  (norm_imp (! appctx_concat_l _) norm_refl) )
                           @ unfold_r_top_word_r @ orrd
                           @ sylbir (bicom regex_eq_concat_assoc) @ framing_concat_r
                           @ norm (norm_imp (norm_trans appctx_concat_l norm_refl) norm_refl)
                           @ ctximp_in_ctx_forward
                          ) )
                  ))
     );
theorem inductive_domain_r_implies_l { X : SVar }
  : $(top_word_r X) -> (top_word_l X)$
  = '( kt_top_word_r
        ( unfold_r_top_word_l orl)
        ( norm (norm_imp appctx_concat_r norm_refl)
               (unwrap @ kt_top_word_l
                    (wrap @ norm ( norm_sym  (norm_imp appctx_concat_r norm_refl) )
                          @ sylbi regex_eq_eps_concat_r
                          @ unfold_r_top_word_l @ orrd
                          @ sylbir regex_eq_eps_concat_l
                          @ framing_concat_l
                          @ unfold_r_top_word_l orl
                    )
                    @ syl (bi2i (! alpha_rename_ctximp_app sBox eBox1 eBox2))
                    (wrap @ norm ( norm_sym  (norm_imp appctx_concat_r norm_refl) )
                          @ unfold_r_top_word_l @ orrd
                          @ sylbir regex_eq_concat_assoc @ framing_concat_l
                          @ norm (norm_imp (norm_trans appctx_concat_r norm_refl) norm_refl)
                          @ ctximp_in_ctx_forward
                    )
               )
        )
     );


--- Proof certificate implementation
------------------------------------

theorem top_implies_fp_init {X: SVar} (phi: Pattern)
    (he: $epsilon -> phi$)
    (hl:  $phi . top_letter -> phi$)
  : $top_word X -> phi$
= '( rsyl inductive_domain_r_implies_l @ kt_top_word_l he hl );


--- fp-implies-alpha
--------------------

--- Apply equivalence left to right
theorem apply_equiv (eq: $phi <-> psi$) (cont: $rho -> psi$): $rho -> phi$
  = '(syl (bi2i eq) cont);

theorem fp_implies_regex_leaf :
    $rho -> rho$ = 'id;

theorem fp_implies_regex_interior {X: SVar} (phi_a phi_b: Pattern X)
    (posa: $ _Positive X phi_a $)
    (posb: $ _Positive X phi_b $)
    (he: $epsilon -> rho$)
    (ha: $s[ rho / X ] phi_a -> (derivative a rho)$)
    (hb: $s[ rho / X ] phi_b -> (derivative b rho)$):
    ----------------------------------------------
    $(mu X (epsilon \/ ((a . phi_a) \/ (b . phi_b)))) -> rho$ =
    '(KT
      (positive_in_or positive_disjoint @ positive_in_or (positive_in_concat positive_disjoint posa) (positive_in_concat positive_disjoint posb)) @
      apply_equiv (corollary_57_floor der_equality) (norm
        (norm_imp_l @ norm_sym @ _sSubst_or sSubstitution_disjoint @ _sSubst_or (sSubst_concat_r norm_refl) (sSubst_concat_r norm_refl))
        (orim (iand id he) @ orim (framing_concat_r ha) (framing_concat_r hb))
      ));

