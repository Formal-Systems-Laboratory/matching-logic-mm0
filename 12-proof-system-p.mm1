import "01-propositional.mm1";
import "10-theory-definedness.mm1";
import "11-definedness-normalization.mm1";


--- Appendix C: Properties of Proof System H
--------------------------------------------

theorem propag_exists_def {x: EVar} (phi: Pattern x):
  $ |^ exists x phi ^| -> exists x (|^ phi ^|) $ =
  '(norm (norm_imp defNorm @ norm_exists defNorm) (! propag_exists_strict box));

theorem prop_43_bot (rho: Pattern): $ bot -> rho $ = 'absurdum;
theorem prop_43_or {box: SVar} (ctx: Pattern box) (phi1 phi2: Pattern):
  $ (app[ phi1 / box ] ctx \/ app[ phi2 / box ] ctx) -> app[ phi1 \/ phi2 / box ] ctx $ =
  '(eori (framing orl) (framing orr));
theorem prop_43_exists {box: SVar} {x: EVar} (ctx: Pattern box) (phi: Pattern x):
  $ (exists x (app[ phi / box ] ctx)) -> app[ exists x phi / box ] ctx $ =
  '(exists_generalization (eFresh_appCtx eFresh_triv eFresh_exists_same_var) (framing exists_intro_same_var));

theorem prop_43_or_def (phi1 phi2: Pattern):
  $ (|^ phi1 ^| \/ |^ phi2 ^|) -> |^ phi1 \/ phi2 ^| $ =
  '(eori (framingDef orl) (framingDef orr));
theorem prop_43_exists_def {x: EVar} (phi: Pattern x):
  $ (exists x (|^ phi ^|)) -> |^ exists x phi ^| $ =
  '(exists_generalization (eFresh_app eFresh_triv eFresh_exists_same_var) (framingDef exists_intro_same_var));

--- prop_44
theorem cong_of_equiv_not (h: $phi1 <-> phi2$): $~phi1 <-> ~phi2$ = '(noteqi h);
theorem cong_of_equiv_imp_l (h: $phi1 <-> phi2$): $(phi1 -> psi) <-> (phi2 -> psi)$ = '(anim imim1 imim1 @ ancom h);
theorem cong_of_equiv_imp_r (h: $phi1 <-> phi2$): $(psi -> phi1) <-> (psi -> phi2)$ = '(anim imim2 imim2 h);
theorem cong_of_equiv_or_l (h: $phi1 <-> phi2$): $(phi1 \/ psi) <-> (phi2 \/ psi)$;
theorem cong_of_equiv_or_r (h: $phi1 <-> phi2$): $(psi \/ phi1) <-> (psi \/ phi2)$;
theorem cong_of_equiv_and_l (h: $phi1 <-> phi2$): $(phi1 /\ psi) <-> (phi2 /\ psi)$ = '(anim anim1 anim1 h);
theorem cong_of_equiv_and_r (h: $phi1 <-> phi2$): $(psi /\ phi1) <-> (psi /\ phi2)$ = '(anim anim2 anim2 h);
theorem cong_of_equiv_app_l (h: $phi1 <-> phi2$): $(app phi1 psi) <-> (app phi2 psi)$;
theorem cong_of_equiv_app_r (h: $phi1 <-> phi2$): $(app psi phi1) <-> (app psi phi2)$;

theorem cong_of_equiv_exists {x: EVar} (phi1 phi2: Pattern x)
  (h: $ phi1 <-> phi2 $): $ (exists x phi1) <-> (exists x phi2) $ =
  '(iani (exists_framing @ anl h) (exists_framing @ anr h));

theorem univ_gene {x: EVar} (phi: Pattern x)
  (p: $ phi $):
  $ forall x phi $ = '(exists_generalization_strict @ notnot1 p);
theorem var_subst {x y: EVar} (phi: Pattern x y):
  $ (forall x phi) -> e[ eVar y / x ] phi $ =
  '(con1 @ norm (norm_imp eSubstitution_in_not norm_refl) exists_intro);
theorem var_subst_same_var {x: EVar} (phi: Pattern x):
  $ (forall x phi) -> phi $ = '(con1 exists_intro_same_var);

theorem lemma_46 (phi: Pattern) {box: SVar} (ctx: Pattern box)
  (p : $ phi $):
  $ ~ (app[ (~ phi) / box ] ctx) $ = '(syl propag_bot @ framing @ notnot1 p);

theorem eqiv_to_eq (h: $ phi <-> psi $):
  $ phi == psi $ = '(norm (norm_not @ ! defNorm box) @ lemma_46 h);

theorem eq_intro: $ phi == phi $ = '(eqiv_to_eq biid);

theorem eq_sym: $ (phi1 == phi2) -> (phi2 == phi1) $ =
  '(con3 @ framingDef @ con3 bicom);

theorem membership_intro {x: EVar} (phi: Pattern x)
  (h: $ phi $):
  $ forall x (x in phi) $ =
  '(univ_gene @ framingDef (iand id (a1i h)) definedness);

theorem membership_elim {x: EVar} (phi: Pattern)
  (h: $ forall x (x in phi) $):
  $ phi $ =
  '(dne @ exists_generalization_strict (dne @ dne (norm (norm_not @ norm_and (! defNorm box1) (! appCtxVar box2)) singleton) @ var_subst_same_var h) existence);

theorem membership_var_forward {x y: EVar}: $ (x in (eVar y)) -> (eVar x == eVar y) $
 = '( rsyl (iand (dne singletonDef) (imim1i (framingDef ancom) @ dne @ norm (norm_not @ norm_and defNorm defNorm) (! singleton box1 box2)))
    @ rsyl (anri not_distr_or)
    @ rsyl (con3 @ norm (norm_imp norm_refl @ norm_or defNorm defNorm) propag_or)
    @ con3
    @ norm (norm_imp defNorm norm_refl)
      (! framing box _ _ _ @ anr lemma_51));
theorem membership_var_reverse {x y: EVar}: $ (eVar x == eVar y) -> (x in (eVar y)) $
 = '(propag_or_def @ framingDef or_imp_xor_and @ norm defNorm @ prop_43_or @ norm (norm_sym @ norm_or defNorm (! defNorm box)) @ orl definedness);
theorem membership_var_bi {x y: EVar}:
  $ (x in (eVar y)) <-> (eVar x == eVar y) $
 = '(iani membership_var_forward  membership_var_reverse);
theorem membership_var {x y: EVar}:
  $ (x in (eVar y)) == (eVar x == eVar y) $
 = '(eqiv_to_eq membership_var_bi);

theorem membership_not_forward {x: EVar} (phi: Pattern x):
  $(x in ~phi) -> ~(x in phi) $ = '(con2 @ dne singletonDef);
theorem membership_not_reverse {x: EVar} (phi: Pattern x):
  $~(x in phi) -> (x in ~phi) $ =
  '(propag_or_def @ framingDef (exp @ iand anl @ curry @ com12 dne) definedness);
theorem membership_not {x: EVar} (phi: Pattern x):
  $ (x in ~phi) == ~(x in phi) $ =
  '(eqiv_to_eq @ iani membership_not_forward membership_not_reverse);

theorem framing_in {x: EVar} (phi1 phi2: Pattern x)
  (h: $ phi1 -> phi2 $):
  $ (x in phi1) -> (x in phi2)$ =
  '(framingDef @ anim2 h);


--- (membership and)
theorem membership_and_forward {x: EVar} (phi1 phi2: Pattern x):
  $ x in (phi1 /\ phi2) -> (x in phi1) /\ (x in phi2) $
  = '(iand (framingDef @ iand anl anrl) (framingDef @ iand anl anrr));
theorem membership_and_reverse {x: EVar} (phi1 phi2: Pattern x):
  $  (x in phi1) /\ (x in phi2) -> x in (phi1 /\ phi2) $
  ='(syl dne @ con2 @ rsyl membership_not_reverse @ rsyl (framing_in @ anl notan) @ rsyl
      (framingDef @ anl andi)
      (rsyl (norm (norm_imp defNorm @ norm_or defNorm defNorm) (! propag_or box)) @ rsyl (orim (con2 @ dne singletonDef) (con2 @ dne singletonDef)) (anr notan)));
theorem membership_and_bi {x: EVar} (phi1 phi2: Pattern x):
  $ x in (phi1 /\ phi2) <-> (x in phi1) /\ (x in phi2) $
  = '(iani membership_and_forward membership_and_reverse);
theorem membership_and {x: EVar} (phi1 phi2: Pattern x):
  $ x in (phi1 /\ phi2) == (x in phi1) /\ (x in phi2) $ =
  '(eqiv_to_eq membership_and_bi);

theorem membership_imp_forward {x: EVar} (phi1 phi2: Pattern):
  $ x in (phi1 -> phi2) -> (x in phi1) -> (x in phi2) $ =
  '(exp @ rsyl membership_and_reverse @ framing_in @ impcom @ syl mpcom id );
theorem membership_imp_reverse {x: EVar} (phi1 phi2: Pattern):
  $((x in phi1) -> (x in phi2))  -> x in (phi1 -> phi2)$ =
  '(imp_to_or @ eori (rsyl membership_not_reverse @ framing_in absurd)
                     (framing_in @ com12 idd ) );
theorem membership_imp {x: EVar}  (phi1 phi2: Pattern):
  $ x in (phi1 -> phi2) == (x in phi1) -> (x in phi2) $ =
  '(eqiv_to_eq @ iani membership_imp_forward membership_imp_reverse);

theorem membership_exists_forward {x y: EVar} (phi: Pattern x y):
  $ (x in (exists y phi)) -> exists y (x in phi) $
  = '(rsyl (framingDef and_exists_reverse) propag_exists_def);
theorem membership_exists_reverse {x y: EVar} (phi: Pattern x y):
  $ (exists y (x in phi) -> x in (exists y phi)) $
  = '(rsyl prop_43_exists_def @ framingDef and_exists_forwards);
theorem membership_exists {x y: EVar} (phi: Pattern x y):
  $ (x in (exists y phi)) == exists y (x in phi) $
  = '(eqiv_to_eq @ iani membership_exists_forward membership_exists_reverse);

theorem lemma_exists_and {x: EVar} (phi: Pattern):
  $ phi <-> exists x (eVar x /\ phi) $ =
  '(ibii
    (rsyl notnot1 @ anr or_exists @ exists_framing
      (expcom @ iand appl @ rsyl anl dne)
      @ anl or_exists @ orr existence)
    (exists_generalization_strict anr));

theorem lemma_56 {box: SVar} (ctx: Pattern box) (phi: Pattern):
  $ (app[ phi / box ] ctx) -> |^ phi ^| $ =
  '(rsyl (rsyl
    (framing @ anl lemma_exists_and)
    propag_exists_strict)
    (exists_generalization_strict @ rsyl
      (dne @ singleton_norm norm_refl (! defNorm box2))
      (propag_or_def @ framingDef (anl com12b @ rsyl dne @ imim2i dne) (! definedness x))
    ));

theorem corollary_57_ceil (phi: Pattern): $ phi -> |^ phi ^| $ =
  '(norm (norm_imp_l appCtxVar) (! lemma_56 box));
theorem corollary_57_floor (phi: Pattern): $ |_ phi _| -> phi $ =
  '(con1 corollary_57_ceil);

--- lemma 59
--- theorem functional_subst {x: EVar} {y: EVar} (phi1: Pattern x y) (phi2: Pattern x):
---  $(forall x phi1) /\ (exists y phi2 == eVar y) -> e[ phi2 / x ] phi1$;

--- lemma 60
theorem lemma_60_forward {x: EVar}  {box: SVar} (ctx: Pattern box x) (phi1 phi2: Pattern x):
  $ (app[ phi1 /\ (x in phi2) / box ] ctx) -> ((app[ phi1 / box ] ctx) /\ (x in phi2)) $
  ;

theorem lemma_60_reverse {x: EVar} {box: SVar} (ctx: Pattern box x) (phi1 phi2: Pattern x):
  $ ((app[ phi1 / box ] ctx) /\ (x in phi2)) -> app[ phi1 /\ (x in phi2) / box ] ctx $
  ;
-- theorem lemma_60 {x: EVar} {box: SVar} (phi1 ctx: Pattern box x):
--   $(app[ phi1 /\ (x in phi2) / box ] ctx) == app[ phi1 / box ] ctx /\ (x in phi2)$
--   = '(eqiv_to_eq @ iani lemma_60_forward lemma_60_reverse );


--- Lemma 62
theorem lemma_62_forward {x: EVar} (phi: Pattern):
  $ (exists x ((x in phi) /\ eVar x)) -> phi $ =
  '(exists_generalization_strict @ syl dne @ dne @ con3 (bi1i anass) (singleton_norm (! defNorm box1) (! appCtxVar box2)));
theorem lemma_62_reverse {y: EVar} (phi: Pattern) {.box: SVar}:
  $ phi -> (exists y ((y in phi) /\ eVar y))$
  = '( ! membership_elim x _
     @ exists_generalization eFresh_triv
     @ notnot1
     @ membership_imp_reverse
     @ syl membership_exists_reverse
     @ syl (bi2i @ cong_of_equiv_exists membership_and_bi)
     @ syl (bi2i @ cong_of_equiv_exists @ cong_of_equiv_and_r membership_var_bi)
     @ syl (! exists_intro y x)
     @ norm (norm_imp norm_refl @ norm_sym @ norm_trans eSubstitution_in_and
                @ norm_and (norm_trans eSubstitution_in_app @ norm_app
                              eSubstitution_triv
                            @ norm_trans eSubstitution_in_and @ norm_and eSubstitution_triv
                            @ norm_trans eSubstitution_in_app @ norm_app eSubstitution_triv
                            @ norm_trans eSubstitution_in_and @ norm_and
                              eSubstitution_in_same_eVar
                              eSubstitution_triv)
                           ( norm_trans eSubstitution_in_not @ norm_not
                            @ norm_trans eSubstitution_in_app @ norm_app eSubstitution_triv
                            @ norm_trans eSubstitution_in_not @ norm_not
                            @ norm_trans eSubstitution_in_and @ norm_and
                              (norm_trans eSubstitution_in_imp @ norm_imp
                                 eSubstitution_triv eSubstitution_in_same_eVar )
                              (norm_trans eSubstitution_in_imp @ norm_imp
                                 eSubstitution_in_same_eVar eSubstitution_triv )   )
            )
     @ iand ( syl (norm (norm_imp (norm_and defNorm norm_refl) @ defNorm) (! lemma_60_reverse _ box) )
            @ iand (a1i definedness)
                   id
            )
            (a1i eq_intro)
     );

theorem lemma_62_b_reverse {y: EVar} (phi: Pattern):
  $ phi -> (exists y (eVar y /\ (y in phi)))$ =
  '(rsyl lemma_62_reverse @ exists_framing ancom);

theorem lemma_14 {box: SVar} (ctx: Pattern box) (psi phi1 phi2: Pattern)
  (h: $ |_ psi _| -> phi1 -> phi2 $):
  $ |_ psi _| -> (app[ phi1 / box ] ctx) -> app[ phi2 / box ] ctx $ =
  '(com12 @ con1d @ rsyl
    (syl propag_or @ framing @ syl (imim2 dne) @ con3d @ com12 h)
    (imim2 @ norm (norm_imp_l @ norm_trans appCtxNested @ norm_ctxApp_pt norm_refl defNorm) (! lemma_56 box2))
  );

-- Equality reasoning

theorem eq_to_intro:
  $ (phi1 == phi2) -> (phi1 -> phi2) $ =
  '(syl anl corollary_57_floor);

theorem eq_to_appCtx {box: SVar} (ctx: Pattern box) (phi1 phi2 psi1 psi2: Pattern)
  (h: $ (phi1 == phi2) -> (psi1 -> psi2) $):
  $ (phi1 == phi2) -> (app[ psi1 / box ] ctx) -> app[ psi2 / box ] ctx $ =
  '(lemma_14 h);

theorem eq_to_framing {box: SVar} (ctx: Pattern box) (phi1 phi2: Pattern):
  $ (phi1 == phi2) -> ((app[ phi1 / box ] ctx) -> app[ phi2 / box ] ctx) $ =
  '(eq_to_appCtx eq_to_intro);

theorem eq_to_def
  (h: $ (phi1 == phi2) -> (psi1 -> psi2) $):
  $ (phi1 == phi2) -> (|^ psi1 ^| -> |^ psi2 ^|) $ =
  '(norm (norm_imp_r @ norm_imp defNorm defNorm) (! eq_to_appCtx box _ _ _ _ _ h));

theorem eq_to_and
  (h1: $ (phi1 == phi2) -> (psi1 -> psi2) $)
  (h2: $ (phi1 == phi2) -> (rho1 -> rho2) $):
  $ (phi1 == phi2) -> ((psi1 /\ rho1) -> (psi2 /\ rho2)) $ =
  '(animd h1 h2);
theorem eq_to_and_l
  (h: $ (phi1 == phi2) -> (psi1 -> psi2) $):
  $ (phi1 == phi2) -> ((psi1 /\ rho) -> (psi2 /\ rho)) $ =
  '(anim1d h);
theorem eq_to_and_r
  (h: $ (phi1 == phi2) -> (psi1 -> psi2) $):
  $ (phi1 == phi2) -> ((rho /\ psi1) -> (rho /\ psi2)) $ =
  '(anim2d h);

theorem eq_to_imp
  (h1: $ (phi1 == phi2) -> (psi2 -> psi1) $)
  (h2: $ (phi1 == phi2) -> (rho1 -> rho2) $):
  $ (phi1 == phi2) -> ((psi1 -> rho1) -> (psi2 -> rho2)) $ =
  '(imimd h1 h2);
theorem eq_to_imp_l
  (h: $ (phi1 == phi2) -> (psi2 -> psi1) $):
  $ (phi1 == phi2) -> ((psi1 -> rho) -> (psi2 -> rho)) $ =
  '(imim1d h);
theorem eq_to_imp_r
  (h: $ (phi1 == phi2) -> (psi1 -> psi2) $):
  $ (phi1 == phi2) -> ((rho -> psi1) -> (rho -> psi2)) $ =
  '(imim2d h);

theorem eq_to_app_l
  (h: $ (phi1 == phi2) -> (psi1 -> psi2) $):
  $ (phi1 == phi2) -> ((app psi1 rho) -> (app psi2 rho)) $ =
  '(norm
    (norm_imp_r @ norm_imp (norm_trans appCtxL @ norm_app appCtxVar norm_refl) (norm_trans appCtxL @ norm_app appCtxVar norm_refl))
    (! eq_to_appCtx box _ _ _ _ _ h));
theorem eq_to_app_r
  (h: $ (phi1 == phi2) -> (psi1 -> psi2) $):
  $ (phi1 == phi2) -> ((app rho psi1) -> (app rho psi2)) $ =
  '(norm
    (norm_imp_r @ norm_imp (norm_trans appCtxR @ norm_app norm_refl appCtxVar) (norm_trans appCtxR @ norm_app norm_refl appCtxVar))
    (! eq_to_appCtx box _ _ _ _ _ h));

theorem eq_to_not
  (h: $ (phi1 == phi2) -> (psi2 -> psi1) $):
  $ (phi1 == phi2) -> ((~ psi1) -> (~ psi2)) $ =
  '(eq_to_imp_l h);

theorem eq_to_eqiv
  (h1: $ (phi1 == phi2) -> (psi1 <-> psi2) $)
  (h2: $ (phi1 == phi2) -> (rho1 <-> rho2) $):
  $ (phi1 == phi2) -> ((psi1 <-> rho1) -> (psi2 <-> rho2)) $ =
  '(eq_to_and (eq_to_imp (bi2d h1) (bi1d h2)) (eq_to_imp (bi2d h2) (bi1d h1)));

theorem eq_to_eq
  (h1: $ (phi1 == phi2) -> (psi1 == psi2) $)
  (h2: $ (phi1 == phi2) -> (rho1 == rho2) $):
  $ (phi1 == phi2) -> ((psi1 == rho1) -> (psi2 == rho2)) $ =
  '(eq_to_not @ eq_to_def @ eq_to_not @ eq_to_eqiv (syl corollary_57_floor h1) (syl corollary_57_floor h2));
theorem eq_to_eq_l
  (h: $ (phi1 == phi2) -> (psi1 == psi2) $):
  $ (phi1 == phi2) -> ((psi1 == rho) -> (psi2 == rho)) $ =
  '(eq_to_eq h (a1i eq_intro));
theorem eq_to_eq_r
  (h: $ (phi1 == phi2) -> (psi1 == psi2) $):
  $ (phi1 == phi2) -> ((rho == psi1) -> (rho == psi2)) $ =
  '(eq_to_eq (a1i eq_intro) h);

-- theorem eq_to_eq_app_l
--   (h: $ (phi1 == phi2) -> (psi1 == psi2) $):
--   $ (phi1 == phi2) -> ((app psi1 rho) == (app psi2 rho)) $ =
--   '(syl eqiv_to_eq @ ibid (eq_to_app_l @ syl eq_to_intro h) (eq_to_app_l @ syl eq_to_intro @ syl eq_sym h));