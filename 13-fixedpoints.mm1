import "12-proof-system-h.mm1";


--- Appendix G: Properties of Proof System H_mu
-----------------------------------------------



--- Appendix I: Notations and Proofs about Recursive Symbols
------------------------------------------------------------

--- contextual implications
def ctximp_app {box: SVar} (ctx: Pattern box) (phi: Pattern) {dummy: EVar}: Pattern =
    $ exists dummy (eVar dummy /\ ((app[ eVar dummy / box ] ctx) C_ phi)) $;

theorem wrap_lemma_1 {x: EVar} (phi psi: Pattern x)
  (h: $ (x in phi) -> psi $):
  $ (x in phi) -> |_ psi _| $ =
  '(syl (con3 @ framingDef @ con3 h) @ con2 @ rsyl (framingDef membership_not_reverse)
  (rsyl (norm (norm_imp
    (norm_trans appCtxR @ norm_app norm_refl @ norm_trans appCtxR @ norm_app norm_refl appCtxVar)
    norm_refl) (! lemma_56 box)) (con2 @ dne singletonDef)));

-- theorem appCtx_ceil_1:
--   $ app[ phi /\ |^ psi ^| / box ] ctx -> app[ phi / box ] ctx /\ |^ psi ^| $ =
--   '(iand (framing anl) (rsyl _ (norm (norm_imp _ norm_refl) lemma_56)));
theorem appCtx_ceil_2 {box: SVar} (ctx: Pattern box) (phi psi: Pattern):
  $ app[ phi / box ] ctx /\ |^ psi ^| -> app[ phi /\ |^ psi ^| / box ] ctx $;

--- lemma 91 (Specialized to Application contexts)
--- TODO: review variable binding
--- TODO: Introduce notation
theorem unwrap {box: SVar} (ctx: Pattern box) (phi psi: Pattern) {dummy: EVar}
  (h: $ phi -> (ctximp_app box ctx psi dummy) $):
  $ (app[ phi / box ] ctx) -> psi $;
theorem wrap {box: SVar} (ctx: Pattern box) (phi psi: Pattern) {dummy: EVar}
  (h: $ (app[ phi / box ] ctx) -> psi $):
  $ phi -> (ctximp_app box ctx psi dummy) $ =
  '(rsyl _ @ exists_framing @ anim id
    (wrap_lemma_1 @ expcom @ rsyl exists_intro_same_var (imim1i (rsyl (exists_framing appCtx_ceil_2) prop_43_exists) (rsyl (framing (rsyl (exists_framing ancom) lemma_62_forward)) h)))
  );
