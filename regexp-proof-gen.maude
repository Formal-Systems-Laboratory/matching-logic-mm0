fmod PATTERN-METAMATH-CORE is
    protecting QID-LIST .
    sorts Symbol SVar EVar Pattern .
    subsorts Symbol SVar EVar < Pattern .

    *** Core ***************************************
    op sVar _ : Qid -> SVar [ctor] .
    op eVar _ : Qid -> EVar [ctor] .
    op sym  _ : Qid -> Symbol [ctor] .
    op app _ _ : Pattern Pattern -> Pattern [ctor] .
    op _ -> _  : Pattern Pattern -> Pattern [ctor] .
    op mu _ _  : Qid     Pattern -> Pattern [ctor] .
    op bot         : -> Pattern [ctor] .
    op exists _ _ : Qid Pattern -> Pattern [ctor] .

    *** Standard sugar **********************************
    op _ /\ _       : Pattern Pattern -> Pattern [ctor] .
    op _ \/ _       : Pattern Pattern -> Pattern [ctor] .
    op nu _ _       : Qid Pattern     -> Pattern [ctor] .
    op forall _ _   : Qid Pattern     -> Pattern [ctor] .
    op ~ _           : Pattern         -> Pattern [ctor] .

    *** ERE *********************************************
    op epsilon      :                 -> Pattern [ctor] .

    --- TODO: Ideally, we'd want to be parametric over an alphabet.
    --- However, two letters are enough to encode all words.
    sort Letter .
    subsort Letter < Pattern .
    op a            :                 -> Letter [ctor] .
    op b            :                 -> Letter [ctor] .
    op [ kleene _ _ ] : Qid Pattern     -> Pattern [ctor prec 25] .
    op top-letter   :                 -> Pattern [ctor] .
    op kleene _ _   : Qid Pattern     -> Pattern [ctor prec 25] .
    op top-word _   : Qid             -> Pattern [ctor] .

    op _ . _        : Pattern Pattern -> Pattern [ctor prec 28] .

    op (derivative _ _) : Pattern Pattern -> Pattern [ctor] .

    *** Meta variables *************************
    vars phi phi1 phi2 psi psi1 psi2 : Pattern .
    vars x y X Y Q : Qid .
    vars QL QL1 QL2 : QidList .

    *** Helpers ***************************************************

    op substitute [ _ / _ ] in _ : Pattern Qid Pattern -> Pattern .
    eq substitute [ phi / X ] in sVar X = phi .
   ceq substitute [ phi / X ] in sVar Y = sVar Y if X =/= Y .
    eq substitute [ phi / X ] in mu X psi = mu X psi .
   ceq substitute [ phi / X ] in mu Y psi = mu X (substitute [ phi / X ] in psi) if X =/= Y .
    eq substitute [ phi / X ] in (psi1 \/ psi2) = (substitute [ phi / X ] in psi1) \/ (substitute [ phi / X ] in psi2) .
    eq substitute [ phi / X ] in epsilon = epsilon .
    eq substitute [ phi / X ] in a = a .
    eq substitute [ phi / X ] in b = b .
    eq substitute [ phi / X ] in (psi1 . psi2)
     = (substitute [ phi / X ] in psi1) . (substitute [ phi / X ] in psi2) .

    op unique : QidList -> QidList .

    op all-sVars : Pattern -> QidList .
    eq all-sVars(sVar X) = X .
    eq all-sVars(eVar X) = nil .
    eq all-sVars(sym  X) = nil .
    eq all-sVars(app phi psi) = all-sVars(phi) minus(all-sVars(psi), all-sVars(phi)) .
    eq all-sVars(phi -> psi)  = all-sVars(phi) minus(all-sVars(psi), all-sVars(phi)) .
    eq all-sVars(mu X phi) = X minus(all-sVars(phi), X) .
    eq all-sVars(bot) = nil .
    eq all-sVars(exists X phi) = all-sVars(phi) .
    eq all-sVars(~ phi) = all-sVars(phi) .

    eq all-sVars(epsilon)  = nil .
    eq all-sVars(a)  = nil .
    eq all-sVars(b)  = nil .
    eq all-sVars(phi \/ psi)  = all-sVars(phi) minus(all-sVars(psi), all-sVars(phi)) .
    eq all-sVars(phi .  psi)  = all-sVars(phi) minus(all-sVars(psi), all-sVars(phi)) .

    eq all-sVars([ kleene X phi ]) = X .
    eq all-sVars(top-word X) = X .

    op minus : QidList QidList -> QidList .
    eq minus(nil, QL) = nil .
   ceq minus(Q QL1, QL2) =   minus(QL1, QL2) if     occurs(Q, QL2) .
   ceq minus(Q QL1, QL2) = Q minus(QL1, QL2) if not occurs(Q, QL2) .
endfm

fmod PATTERN-METAMATH is
    including PATTERN-METAMATH-CORE .

    *** ERE sugar
    vars Alpha Beta Gamma : Pattern .
    --- NOT FOR INTERNAL USE.
    op top : -> Pattern .
    eq top = ~ bot .

    op _ + _        : Pattern Pattern -> Pattern [prec 30] .
    eq Alpha + Beta = Alpha \/ Beta .

    op _ *          : Pattern -> Pattern [prec 30] .
    eq Alpha * = [ kleene 'Xk Alpha ] .

    op _ ->> _        : Pattern Pattern -> Pattern [prec 31] .
    eq Alpha ->> Beta = (~ Alpha) \/ Beta .

    op _ <<->> _       : Pattern Pattern -> Pattern [prec 32] .
    eq Alpha <<->> Beta = (Alpha ->> Beta) /\ (Beta ->> Alpha) .

    --- Internal sorting of patterns
    sort Comparison .
    ops LT EQ GT : -> Comparison [ctor] .

    op toNat : Pattern -> Nat .
    op (_ <=> _) : Pattern Pattern -> Comparison .

    vars phi phi1 phi2 psi psi1 psi2 : Pattern .
    vars x y X Y : Qid .

    *** ! Changing these values also requires changing the two *-choice-comm-leaf rules
    eq toNat(bot) = 0 .
    eq toNat(epsilon) = 1 .
    eq toNat(a) = 2 .
    eq toNat(b) = 3 .
    eq toNat(top) = 4 .
    eq toNat([kleene X phi]) = 5 .
    eq toNat(~ phi) = 6 .
    eq toNat(phi1 . phi2) = 7 .
    eq toNat(phi1 /\ phi2) = 8 .
    eq toNat(phi1 \/ phi2) = 9 .
    eq toNat(phi1 -> phi2) = 10 .
    eq toNat(derivative phi1 phi2) = 11 .

    eq phi <=> phi = EQ .
    ceq phi <=> psi = LT if toNat(phi) < toNat(psi) .
    ceq phi <=> psi = GT if toNat(phi) > toNat(psi) .
    eq ([kleene X phi]) <=> ([kleene X psi]) = phi <=> psi .
    eq (~ phi) <=> (~ psi) = phi <=> psi .
    ceq (phi1 . phi2) <=> (psi1 . psi2) = phi2 <=> psi2 if phi1 <=> psi1 = EQ .
    eq (phi1 . phi2) <=> (psi1 . psi2) = phi1 <=> psi1 [owise] .
    ceq (phi1 /\ phi2) <=> (psi1 /\ psi2) = phi2 <=> psi2 if phi1 <=> psi1 = EQ .
    eq (phi1 /\ phi2) <=> (psi1 /\ psi2) = phi1 <=> psi1 [owise] .
    ceq (phi1 \/ phi2) <=> (psi1 \/ psi2) = phi2 <=> psi2 if phi1 <=> psi1 = EQ .
    eq (phi1 \/ phi2) <=> (psi1 \/ psi2) = phi1 <=> psi1 [owise] .
    ceq (phi1 -> phi2) <=> (psi1 -> psi2) = phi2 <=> psi2 if phi1 <=> psi1 = EQ .
    eq (phi1 -> phi2) <=> (psi1 -> psi2) = phi1 <=> psi1 [owise] .
    ceq (derivative phi1 phi2) <=> (derivative psi1 psi2) = phi2 <=> psi2 if phi1 <=> psi1 = EQ .
    eq (derivative phi1 phi2) <=> (derivative psi1 psi2) = phi1 <=> psi1 [owise] .
endfm

mod ERE-THEOREMS is
    protecting PATTERN-METAMATH .
    protecting META-TERM . --- TODO: I think this is required due to a bug in maude 2.7
                           --- I get this warning: Advisory: could not find sort Sort in meta-module ERE-THEOREMS.
                           --- Does this go away in newer versions of Maude?

    vars Alpha Alpha1 Alpha2 : Pattern .
    vars Beta  Beta1  Beta2  : Pattern .
    vars Gamma : Pattern .
    vars A B A1 A2 : Letter .
    vars X Y : Qid . 

    rl [regex_eq_der_bot]     : (derivative A bot)          => bot .
    rl [regex_eq_der_epsilon] : (derivative A epsilon)      => bot .
    rl [regex_eq_der_same_a]  : (derivative A A)            => epsilon .
   crl [regex_eq_der_diff_a]  : (derivative A B)            => bot if A =/= B .

    rl [regex_eq_der_kleene]  : (derivative A [kleene X Alpha])         => (derivative A Alpha) . [kleene X Alpha] .
    rl [regex_eq_der_concat]  : (derivative A (Alpha . Beta))  => ((derivative A Alpha) . Beta) \/  ((epsilon /\ Alpha) . (derivative A Beta)) .
    rl [regex_eq_der_choice]  : (derivative A (Alpha \/ Beta)) => (derivative A Alpha) \/ (derivative A Beta) .
    rl [regex_eq_der_conj]    : (derivative A (Alpha /\ Beta)) => (derivative A Alpha) /\ (derivative A Beta) .
    rl [regex_eq_der_neg]     : (derivative A ~ Alpha)         => ~ (derivative A Alpha) .

    rl [regex_eq_ewp_bot]     : epsilon /\ bot             => bot .
    rl [regex_eq_ewp_epsilon] : epsilon /\ epsilon         => epsilon .
    rl [regex_eq_ewp_a]       : epsilon /\ a               => bot .
    rl [regex_eq_ewp_b]       : epsilon /\ b               => bot .
    rl [regex_eq_ewp_concat]  : epsilon /\ (Alpha . Beta)  => (epsilon /\ Alpha) /\ (epsilon /\ Beta) .
    rl [regex_eq_ewp_and]     : epsilon /\ (Alpha /\ Beta) => (epsilon /\ Alpha) /\ (epsilon /\ Beta) .
    rl [regex_eq_ewp_choice]  : epsilon /\ (Alpha \/ Beta) => (epsilon /\ Alpha) \/ (epsilon /\ Beta) .
    rl [regex_eq_ewp_kleene]  : epsilon /\ [kleene X Alpha]       => epsilon .

    rl [regex_eq_ewp_not_bot]     : epsilon /\ ~(bot)           => epsilon .
    rl [regex_eq_ewp_not_eps]     : epsilon /\ ~(epsilon)       => bot .
    rl [regex_eq_ewp_not_a]       : epsilon /\ ~(a)             => epsilon .
    rl [regex_eq_ewp_not_b]       : epsilon /\ ~(b)             => epsilon .
    rl [regex_eq_ewp_not_concat]  : epsilon /\ ~(Alpha . Beta)  => (epsilon /\ ~ Alpha) \/ (epsilon /\ ~ Beta) .
    rl [regex_eq_ewp_not_and]     : epsilon /\ ~(Alpha /\ Beta) => (epsilon /\ ~ Alpha) \/ (epsilon /\ ~ Beta) .
    rl [regex_eq_ewp_not_choice]  : epsilon /\ ~(Alpha \/ Beta) => (epsilon /\ ~ Alpha) /\ (epsilon /\ ~ Beta) .
    rl [regex_eq_ewp_not_kleene]  : epsilon /\ ~ ([ kleene X Alpha ]) => bot .
    rl [regex_eq_ewp_not_not]     : epsilon /\ ~(~ Alpha)       => epsilon /\ Alpha .

    --- Identity and idemoptency of \/
    rl [regex_eq_or_choice_abs] : (~ bot)   \/ Alpha => (~ bot) .
    rl [regex_eq_or_choice_unit] : bot   \/ Alpha => Alpha .
    rl [regex_eq_or_choice_idem] : Alpha \/ Alpha => Alpha .
    rl [regex_eq_or_choice_assoc] : (Alpha \/ Beta) \/ Gamma  => Alpha \/ (Beta \/ Gamma) .
   crl [regex_eq_or_choice_comm_node] : Alpha \/ (Beta \/ Gamma) => Beta \/ (Alpha \/ Gamma) if Alpha <=> Beta = GT .
   crl [regex_eq_or_choice_comm_leaf] : Alpha \/ Beta => Beta \/ Alpha if (Alpha <=> Beta == GT) and (toNat(Beta) =/= 9) .

    --- Identity and idemoptency of /\
    rl [regex_eq_and_choice_abs] : bot   /\ Alpha => bot .
    rl [regex_eq_and_choice_unit] : (~ bot)   /\ Alpha => Alpha .
    rl [regex_eq_and_choice_idem] : Alpha /\ Alpha => Alpha .
    rl [regex_eq_and_choice_assoc] : (Alpha /\ Beta) /\ Gamma  => Alpha /\ (Beta /\ Gamma) .
   crl [regex_eq_and_choice_comm_node] : Alpha /\ (Beta /\ Gamma) => Beta /\ (Alpha /\ Gamma) if Alpha <=> Beta = GT .
   crl [regex_eq_and_choice_comm_leaf] : Alpha /\ Beta => Beta /\ Alpha if (Alpha <=> Beta == GT) and (toNat(Beta) =/= 8) .

    ---- Optional simplifications
    rl [regex_eq_bot_concat_l] : bot . Alpha => bot .
    rl [regex_eq_bot_concat_r] : Alpha . bot => bot .

    rl [regex_eq_eps_concat_l] : epsilon . Alpha => Alpha .
    rl [regex_eq_eps_concat_r] : Alpha . epsilon => Alpha .

    rl [regex_eq_double_neg] : ~ ~ Alpha => Alpha .
    rl [regex_eq_double_kleene] : [kleene X [kleene Y Alpha]] => [kleene X Alpha] .

    rl [regex_eq_eps_kleene] : [kleene X epsilon] => epsilon .
    rl [regex_eq_bot_kleene] : [kleene X bot] => epsilon .


    *** Rules *********************************
    *******************************************

    sort State .
    op < _ > : Pattern -> State [ctor] .
    op < invalid > : -> State [ctor] .

    eq < bot > = < invalid > . --- This should never be reached.
    rl [der-a]     : < Alpha > => < (derivative a Alpha) > .
    rl [der-b]     : < Alpha > => < (derivative b Alpha) > .
    rl [check-ewp] : < Alpha > => check-ewp[ (epsilon /\ Alpha) ] .

    --- We don't want the derivative rules to apply when checking EWS.
    op check-ewp[ _ ] : Pattern -> State [ctor] .
endm


fmod MM0 is
    protecting QID-LIST .
    protecting PATTERN-METAMATH-CORE .

    sort MM0SExpr MM0Atom .
    subsort Qid < MM0Atom < MM0SExpr .

    --- We use square brackets instead of parens for S-Expressions since
    --- Maude treats parens specially.
    --- TODO: Consider using List{MM0SExpr}?
    op [ _ _ ]        : MM0SExpr MM0SExpr                             -> MM0SExpr .
    op [ _ _ _ ]      : MM0SExpr MM0SExpr MM0SExpr                    -> MM0SExpr .
    op [ _ _ _ _ ]    : MM0SExpr MM0SExpr MM0SExpr MM0SExpr           -> MM0SExpr .
    op [ _ _ _ _ _ ]  : MM0SExpr MM0SExpr MM0SExpr MM0SExpr MM0SExpr  -> MM0SExpr .
    op [ _ _ _ _ _ _ ]
                      : MM0SExpr MM0SExpr MM0SExpr MM0SExpr MM0SExpr MM0SExpr  -> MM0SExpr .
    op [ _ _ _ _ _ _ _ ]
                      : MM0SExpr MM0SExpr MM0SExpr MM0SExpr MM0SExpr MM0SExpr MM0SExpr  -> MM0SExpr .

    sort MM0Decl MM0Binder .
    op _ _ : MM0Decl MM0Decl -> MM0Decl [ctor assoc format(d n d)] .
    op     theorem _ _ colon $ _ $           ; : Qid MM0Binder Pattern          -> MM0Decl .
    op pub theorem _ _ colon $ _ $ = quote _ ; : Qid MM0Binder Pattern MM0SExpr -> MM0Decl .
    op no-binders : -> MM0Binder [ctor] .
    op { _ colon SVar } : QidList -> MM0Binder [ctor] .
endfm

--- Manually performs a search, and returns the search graph as a tree with backlinks.
mod PROOF-GEN is
    extending ERE-THEOREMS .
    protecting MM0 .
    protecting META-LEVEL .
    protecting NAT .

    sorts Edge NeEdges Edges Node EdgeLabel .
    subsorts Edge < NeEdges < Edges .
    op none : -> Edges [ctor] .
    op eqEdge : EdgeLabel Node -> Edge [ctor] .
    op rlEdge : EdgeLabel Node -> Edge [ctor] .
    op _ ; _ : NeEdges NeEdges -> NeEdges [ctor assoc comm id: none] .
    op _ ; _ : Edges Edges -> Edges [ditto] .

    op applResult : Qid Context Substitution -> EdgeLabel [ctor] .

    op node : State Edges -> Node [ctor] .
    op backlink : State -> Node [ctor] .
    op depthReached : State -> Node [ctor] .

    var NAT : Nat .
    vars Es : NeEdges . vars Es? : Edges .
    vars T T1 T2 : Term . vars TL TL' : TermList .
    vars P : Pattern .
    vars S : State . vars SL SL' : StateList .
    vars X Y Z R Q : Qid . vars Result : Result4Tuple .
    vars Es1 Es2 : NeEdges .
    vars EL : EdgeLabel .
    vars N N_EWP N_A N_B : Node .
    vars Subst Subst_EWP Subst_A Subst_B : Substitution .
    vars Ctx CtxEWP Ctx_A Ctx_B : Context .

    op getState : Node -> State .
    eq getState(node(S, Es?)) = S .
    eq getState(backlink(S)) = S .
    eq getState(depthReached(S)) = S .

    sorts NeStateList StateList .
    subsort State < NeStateList < StateList .

    op empty : -> StateList [ctor] .
    op _,_ : NeStateList StateList -> NeStateList [ctor assoc id: empty gather (e E) prec 121] . --- Same as TermList
    op _,_ : StateList NeStateList -> NeStateList [ctor ditto] .
    op _,_ : StateList StateList -> StateList [ctor ditto] .

    op _ in _ : State StateList -> Bool .
    eq S in (SL , S , SL') = true .
    eq S in SL = false [owise] .

   --- curr term, previous terms, depth
    op mkProofHint : State StateList Nat -> Node .
   ceq mkProofHint(S, SL, NAT) = backlink(S)                              if      S in SL .
   ceq mkProofHint(S, SL, NAT) = node(S, applyAnyEquation(S, SL, NAT))      if (not S in SL) /\ Es := applyAnyEquation(S, SL, NAT) .
   ceq mkProofHint(S, SL, s(NAT)) = node(S, applyAllRules(S, (SL, S), NAT)) if (not S in SL) /\ none = applyAnyEquation(S, SL, NAT) .
   ceq mkProofHint(S, SL, 0) = depthReached(S)                          if (not S in SL) /\ none = applyAnyEquation(S, SL, 0) .

    op applyAnyEquation : State StateList Nat -> Edges .
    eq applyAnyEquation(S, SL, NAT) =
        applyEq(S, SL, NAT, 'regex_eq_der_bot) or-else
        applyEq(S, SL, NAT, 'regex_eq_der_epsilon) or-else
        applyEq(S, SL, NAT, 'regex_eq_der_same_a) or-else
        applyEq(S, SL, NAT, 'regex_eq_der_diff_a) or-else
        applyEq(S, SL, NAT, 'regex_eq_der_kleene) or-else
        applyEq(S, SL, NAT, 'regex_eq_der_concat) or-else
        applyEq(S, SL, NAT, 'regex_eq_der_choice) or-else
        applyEq(S, SL, NAT, 'regex_eq_der_conj) or-else
        applyEq(S, SL, NAT, 'regex_eq_der_neg) or-else
        applyEq(S, SL, NAT, 'regex_eq_ewp_bot) or-else
        applyEq(S, SL, NAT, 'regex_eq_ewp_epsilon) or-else
        applyEq(S, SL, NAT, 'regex_eq_ewp_a) or-else
        applyEq(S, SL, NAT, 'regex_eq_ewp_b) or-else
        applyEq(S, SL, NAT, 'regex_eq_ewp_concat) or-else
        applyEq(S, SL, NAT, 'regex_eq_ewp_and) or-else
        applyEq(S, SL, NAT, 'regex_eq_ewp_choice) or-else
        applyEq(S, SL, NAT, 'regex_eq_ewp_kleene) or-else
        applyEq(S, SL, NAT, 'regex_eq_ewp_not_bot) or-else
        applyEq(S, SL, NAT, 'regex_eq_ewp_not_eps) or-else
        applyEq(S, SL, NAT, 'regex_eq_ewp_not_a) or-else
        applyEq(S, SL, NAT, 'regex_eq_ewp_not_b) or-else
        applyEq(S, SL, NAT, 'regex_eq_ewp_not_concat) or-else
        applyEq(S, SL, NAT, 'regex_eq_ewp_not_and) or-else
        applyEq(S, SL, NAT, 'regex_eq_ewp_not_choice) or-else
        applyEq(S, SL, NAT, 'regex_eq_ewp_not_kleene) or-else
        applyEq(S, SL, NAT, 'regex_eq_ewp_not_not) or-else


        applyEq(S, SL, NAT, 'regex_eq_or_choice_abs) or-else
        applyEq(S, SL, NAT, 'regex_eq_or_choice_unit) or-else
        applyEq(S, SL, NAT, 'regex_eq_or_choice_idem) or-else
        applyEq(S, SL, NAT, 'regex_eq_or_choice_assoc) or-else
        applyEq(S, SL, NAT, 'regex_eq_or_choice_comm_node) or-else
        applyEq(S, SL, NAT, 'regex_eq_or_choice_comm_leaf) or-else
        applyEq(S, SL, NAT, 'regex_eq_and_choice_abs) or-else
        applyEq(S, SL, NAT, 'regex_eq_and_choice_unit) or-else
        applyEq(S, SL, NAT, 'regex_eq_and_choice_idem) or-else
        applyEq(S, SL, NAT, 'regex_eq_and_choice_assoc) or-else
        applyEq(S, SL, NAT, 'regex_eq_and_choice_comm_node) or-else
        applyEq(S, SL, NAT, 'regex_eq_and_choice_comm_leaf) or-else

        applyEq(S, SL, NAT, 'regex_eq_bot_concat_l) or-else
        applyEq(S, SL, NAT, 'regex_eq_bot_concat_r) or-else
        applyEq(S, SL, NAT, 'regex_eq_eps_concat_l) or-else
        applyEq(S, SL, NAT, 'regex_eq_eps_concat_r) or-else
        applyEq(S, SL, NAT, 'regex_eq_double_neg) or-else
        applyEq(S, SL, NAT, 'regex_eq_double_kleene) or-else
        applyEq(S, SL, NAT, 'regex_eq_eps_kleene) or-else
        applyEq(S, SL, NAT, 'regex_eq_bot_kleene)
        .

    --- The strat attribute is needed to get decent preformance.
    --- Otherwise, it would compute all possible outward edges and throw all but one away,
    --- leading to exponential complexity.
    op _ or-else _ : Edges Edges -> Edges [strat (1 0) gather (e E)] .
    eq E:Edge or-else Es:Edges = E:Edge .
    eq none or-else Es? = Es? .

    op applyAllRules : State StateList Nat -> Edges .
    eq applyAllRules(S, SL, NAT) =
        applyRule(S, SL, NAT, 'check-ewp) ;
        applyRule(S, SL, NAT, 'der-a) ;
        applyRule(S, SL, NAT, 'der-b) .

    op myModule : -> Module .
    eq myModule = upModule('ERE-THEOREMS, false) .

    op < error > : -> [State] .

    op applyEq : State StateList Nat Qid -> Edges .
   ceq applyEq(S, SL, NAT, R) = eqEdge( applResult(R, getContext(Result), getSubstitution(Result))
                                      , mkProofHint(downTerm(getTerm(Result), < error >), SL, NAT)
                                      )
    if Result := metaXapply(myModule, upTerm(S), R, none, 0, unbounded, 0) .
    eq applyEq(S, SL, NAT, R) = none [owise] .

    op applyRule : State StateList Nat Qid -> Edges .
   ceq applyRule(S, SL, NAT, R) = rlEdge( applResult(R, getContext(Result), getSubstitution(Result))
                                        , mkProofHint(downTerm(getTerm(Result), < error >), SL, NAT)
                                        )
    if Result := metaXapply(myModule, upTerm(S), R, none, 0, unbounded, 0) .
    eq applyRule(S, SL, NAT, R) = none [owise] .

    vars Alpha Alpha1 Alpha2 : Pattern .
    vars Beta  Beta1  Beta2  : Pattern .
    vars Phi   Phi1   Phi2   : Pattern .
    vars A B A1 A2 : Letter .


    *** Proof hint generation ************************************************

    op ruleLabelToLetter : Qid -> Pattern .
    eq ruleLabelToLetter('check-ewp) = epsilon .
    eq ruleLabelToLetter('der-a) = a .
    eq ruleLabelToLetter('der-b) = b .

    op proofHint : Pattern -> Node .
    eq proofHint(Alpha) = mkProofHint(< Alpha >, empty, 6) .

    *** Mapping EREs to its Matching Logic signature *************************
    --- We may consider desugaring the constructors via the notation defined
    --- in some other module. But I'm not sure it will be necessary.

    --- Generate a fresh set variable for each regexp.
    op F : Pattern -> Qid .
    eq F(Alpha) = qid(str(Alpha)) .

    op str : Pattern -> String .
    eq str(bot) = "z" .
    eq str(a) = "a" .
    eq str(b) = "b" .
    eq str(epsilon) = "e" .
    eq str(Alpha . Beta) = "C" + str(Alpha) + str(Beta) + "D" .
    eq str(Alpha \/ Beta) = "C" + str(Alpha) + "p" + str(Beta) + "D" .
    eq str(Alpha /\ Beta) = "C" + str(Alpha) + "q" + str(Beta) + "D" .
    eq str(Alpha -> Beta) = "C" + str(Alpha) + "i" + str(Beta) + "D" .
    eq str([kleene X Alpha]) = "C" + str(Alpha) + "Dx" .
    eq str(~ Alpha) = "nC" + str(Alpha) + "D" .

    *** fp *******************************************************************
    --- Here, we generate the fixedpoint needed for our proof.

    op fp : Node -> Pattern .
    eq fp(backlink(< Alpha >)) = sVar F(Alpha) .
    eq fp(node(< Alpha >, eqEdge(EL, N))) = fp(N) .
    eq fp(node(< Alpha >, rlEdge(applResult('check-ewp, CtxEWP, Subst_EWP), N_EWP) ;
                          rlEdge(applResult('der-a,     Ctx_A, Subst_A), N_A) ;
                          rlEdge(applResult('der-b,     Ctx_B, Subst_B), N_B)
         )    )
     = mu qid(str(Alpha)) (epsilon \/ ((a . fp(N_A)) \/ (b . fp(N_B)))) [owise] .


    *** der-tree *************************************************************
    --- Simplify proofHint into derivative tree (debugging only).

    op der-tree : Node -> Node .
    eq der-tree(backlink(< Alpha >)) = backlink(< Alpha >) .
    eq der-tree(node(< Alpha >, eqEdge(EL, N))) = der-tree(N) .
    eq der-tree(node(< Alpha >, rlEdge(applResult('check-ewp, CtxEWP, Subst_EWP), N_EWP) ;
                                rlEdge(applResult('der-a,     Ctx_A, Subst_A), N_A) ;
                                rlEdge(applResult('der-b,     Ctx_B, Subst_B), N_B)
         )    )
     = node(< Alpha >, rlEdge(applResult('der-a,     [], none), der-tree(N_A)) ;
                       rlEdge(applResult('der-b,     [], none), der-tree(N_B))
           )    [owise] .


    *** Metamath proofs ******************************************************

    vars MMP : MM0SExpr .

    *** Contextual reasoning with equalities *********************************

    vars LR : String .
    op cong-thm : Qid String -> Qid .
    eq cong-thm('_->_, LR) = qid("imp" + LR) .
    eq cong-thm('_\/_, LR) = qid("or" + LR) .
    eq cong-thm('_/\_, LR) = qid("and" + LR) .
    eq cong-thm('_._, LR) = qid("concat" + LR) .
    eq cong-thm('~_, LR) = 'not .
    eq cong-thm('`[kleene__`], LR) = 'kleene .

    op eq-thm : Substitution Qid -> MM0SExpr .
    eq eq-thm('X:Qid <- T1 ; 'Alpha:Pattern <- T2, 'regex_eq_ewp_kleene)
     = ['regex_eq_ewp_kleene positivity(downTerm(T1, 'bad-down-term), downTerm(T2, sVar 'bad-down-term-alpha))] .
    eq eq-thm('X:Qid <- T1 ; 'Alpha:Pattern <- T2, 'regex_eq_ewp_not_kleene)
     = ['regex_eq_ewp_not_kleene positivity(downTerm(T1, 'bad-down-term), downTerm(T2, sVar 'bad-down-term-alpha))] .
    eq eq-thm('A:Letter <- Q ; Subst , R) = qid(string(R) + "-wrt-" + string(getName(Q))) .
    eq eq-thm(                 Subst , R) = R [owise] .


    op cong-of-equiv _ _ : Qid MM0SExpr -> MM0SExpr .
    eq cong-of-equiv Q MMP = [ qid("cong-of-equiv-" + string(Q)) MMP ] .

    op lift-equality-to-context : Context Term Term MM0SExpr -> MM0SExpr .
    --- input: Context, Original Term, Final Term, Continuation
    --- At each step, we must unwrap both the original term and the context,
    --- so that we can pass the pluged context to the positivity generator.
    vars TOrig TFinal : Term .

    eq lift-equality-to-context([], TOrig, TFinal, MMP) = MMP .

    --- special case for Kleene due to positivitiy
    eq lift-equality-to-context('`[kleene__`][ T1, Ctx ], '`[kleene__`][ T1, TOrig ], '`[kleene__`][ T1, TFinal ], MMP)
     = [ 'cong-of-equiv-kleene positivity(downTerm(T1, 'bad-down-term), downTerm(TOrig,  sVar 'bad-down-term))
                               positivity(downTerm(T1, 'bad-down-term), downTerm(TFinal, sVar 'bad-down-term))
                               MMP ].

    --- special cases for state ctors
    eq lift-equality-to-context('check-ewp`[_`][ Ctx ], 'check-ewp`[_`][ TOrig ], 'check-ewp`[_`][ TFinal ], MMP)
     = lift-equality-to-context(Ctx, TOrig, TFinal, MMP) .

    eq lift-equality-to-context('<_>[ Ctx ], '<_>[ TOrig ], '<_>[ TFinal ], MMP)
     = lift-equality-to-context(Ctx, TOrig, TFinal, MMP) .

    eq lift-equality-to-context(Q [ Ctx ], Q[ TOrig ], Q[ TFinal ], MMP)
     = cong-of-equiv cong-thm(Q, "") lift-equality-to-context(Ctx, TOrig, TFinal, MMP) .
    eq lift-equality-to-context(Q [ Ctx , T2 ], Q [ TOrig , T2 ], Q [ TFinal , T2 ], MMP)
     = cong-of-equiv cong-thm(Q, "-l") lift-equality-to-context(Ctx, TOrig, TFinal, MMP) .
    eq lift-equality-to-context(Q [ T1 , Ctx ], Q [ T1 , TOrig ], Q [ T1 , TFinal ], MMP)
     = cong-of-equiv cong-thm(Q, "-r") lift-equality-to-context(Ctx, TOrig, TFinal, MMP) .

    *** push-s-subst *********************************************************

    op propag-sSubst : Qid Pattern -> MM0SExpr .
    eq propag-sSubst(X, bot) = 'sSubstitution-triv .
    eq propag-sSubst(X, top) = 'sSubstitution-triv .
    eq propag-sSubst(X, eVar X) = 'sSubstitution-triv .
    eq propag-sSubst(X, sVar X) = 'sSubstitution-in-same-sVar .
   ceq propag-sSubst(X, sVar Y) = 'sSubstitution-triv if X =/= Y .
    eq propag-sSubst(X, mu X Phi) = 'sSubstitution-in-same-mu .
   ceq propag-sSubst(X, mu Y Phi) = [ '-sSubst-mu propag-sSubst(X, Phi) ] if X =/= Y .
    eq propag-sSubst(X, Phi1 \/ Phi2) = [ '-sSubst-or propag-sSubst(X, Phi1) propag-sSubst(X, Phi2) ] .

    eq propag-sSubst(X, Phi1 . Phi2) = [ 'sSubst-concat propag-sSubst(X, Phi1) propag-sSubst(X, Phi2) ] .
    eq propag-sSubst(X, a) = 'sSubstitution-triv .
    eq propag-sSubst(X, b) = 'sSubstitution-triv .
    eq propag-sSubst(X, epsilon) = 'sSubstitution-triv .
    eq propag-sSubst(X, top-letter) = 'sSubstitution-triv .

    *** pos ******************************************************************
    op positivity : Qid Pattern -> MM0SExpr .
    eq positivity(X, sVar X) = 'positive-in-same-sVar .
   ceq positivity(X, sVar Y) = 'positive-triv if X =/= Y  .
    eq positivity(X, mu X Phi) = 'positive-in-same-mu .
   ceq positivity(X, mu Y Phi) = [ 'positive-in-mu positivity(X, Phi) ]  if X =/= Y .
    eq positivity(X, [kleene X Phi]) = 'positive-in-same-mu .
   ceq positivity(X, [kleene Y Phi]) = [ 'positive-in-mu positivity(X, Phi) ]  if X =/= Y .
    eq positivity(X, Phi1 \/ Phi2) = [ 'positive-in-or positivity(X, Phi1) positivity(X, Phi2) ] .
    eq positivity(X, epsilon) = 'positive-triv .
    eq positivity(X, a) = 'positive-triv .
    eq positivity(X, b) = 'positive-triv .
    eq positivity(X, Phi1 . Phi2) = [ 'positive-in-concat positivity(X, Phi1) positivity(X, Phi2) ] .

    *** unfold ***************************************************************
    op unfold-r : Pattern MM0SExpr -> MM0SExpr .
    eq unfold-r(mu X Phi, MMP) = [ 'unfold-r positivity(X, Phi) [ 'norm-lemma-r propag-sSubst(X, Phi) MMP ] ] .


    *** main-goal ************************************************************
    --- Here, we split the proof for a regular expression into
    --- two subgoals --- (top-implies-fp) and (fp-implies-regexp).

    op theorem-main-goal : Pattern -> MM0Decl .
    eq theorem-main-goal(Phi)
     = theorem-top-implies-fp(Phi)
       theorem-fp-implies-regex(Phi)
       pub theorem 'proof-main-goal { all-sVars(Phi) colon SVar }
             colon $ Phi $
                 = quote([ 'mp [ 'rsyl [ 'bang 'top-implies-fp 'X 'CCapbDDx ] 'fp-implies-regex ] 'domain-words ]) ; .
    op theorem-main-goal-mm0 : Pattern -> MM0Decl .
    eq theorem-main-goal-mm0(Phi)
     =  theorem-top-implies-fp-mm0(Phi)
        theorem-fp-implies-regex-mm0(Phi)
        theorem 'proof-main-goal { all-sVars(Phi) colon SVar } colon $ Phi $ ; .


    *** top-implies-fp *******************************************************
    op theorem-top-implies-fp : Pattern -> MM0Decl .
    eq theorem-top-implies-fp(Phi)
     = pub theorem 'top-implies-fp
             { all-sVars((top-word 'X) -> fp(proofHint(Phi))) colon SVar }
             colon $ (top-word 'X) -> fp(proofHint(Phi)) $
                 = quote(proof-top-implies-fp(proofHint(Phi))) ; .
    op theorem-top-implies-fp-mm0 : Pattern -> MM0Decl .
    eq theorem-top-implies-fp-mm0(Phi)
     = theorem 'top-implies-fp
             { all-sVars((top-word 'X) -> fp(proofHint(Phi))) colon SVar }
             colon $ (top-word 'X) -> fp(proofHint(Phi)) $ ; .

    op proof-top-implies-fp : Node -> MM0SExpr .
    eq proof-top-implies-fp(N) = [ 'top-implies-fp-init proof-top-implies-fp(fp(N), N) ] .
    op proof-top-implies-fp : Pattern Node -> MM0SExpr .
    eq proof-top-implies-fp(Phi, node(< Alpha >, eqEdge(applResult(R, Ctx, Subst), N)))
     = proof-top-implies-fp(Phi, N) .
    eq proof-top-implies-fp(sVar X, backlink(< Alpha >))
     = [ 'bang 'top-implies-fp-leaf 'X '- 'dummy ] .
    eq proof-top-implies-fp(mu Q (epsilon \/ ((a . Alpha) \/ (b . Beta))) ,
                            node(< Phi >, rlEdge(applResult('check-ewp, CtxEWP, Subst_EWP), N_EWP) ;
                                                             rlEdge(applResult('der-a,     Ctx_A, Subst_A), N_A) ;
                                                             rlEdge(applResult('der-b,     Ctx_B, Subst_B), N_B)
                           )                      )
     = ['top-implies-fp-interior
         [ 'norm-lemma-r propag-sSubst(Q, Alpha)
                       unfold-r( substitute[ mu Q (epsilon \/ ((a . Alpha) \/ (b . Beta))) / Q ] in Alpha , 'orl)]
         [ 'norm-lemma-r propag-sSubst(Q, Beta)
                       unfold-r( substitute[ mu Q (epsilon \/ ((a . Alpha) \/ (b . Beta))) / Q ] in Beta , 'orl)]
         [ 'norm-lemma-r propag-sSubst(Q, Alpha)
           ['norm-lemma propag-sSubst(Q, Alpha . top-letter) proof-top-implies-fp(Alpha, N_A) ] ]
         [ 'norm-lemma-r propag-sSubst(Q, Beta)
           [ 'norm-lemma propag-sSubst(Q, Beta . top-letter) proof-top-implies-fp(Beta, N_B) ] ]
       ] .


    *** fp-implies-regex ************************************************************
    op theorem-fp-implies-regex : Pattern -> MM0Decl .
    eq theorem-fp-implies-regex(Phi)
     = pub theorem 'fp-implies-regex
             { all-sVars(fp(proofHint(Phi)) -> Phi) colon SVar }
             colon $ fp(proofHint(Phi)) -> Phi $
                 = quote(proof-fp-implies-regex(proofHint(Phi))) ; .
    op theorem-fp-implies-regex-mm0 : Pattern -> MM0Decl .
    eq theorem-fp-implies-regex-mm0(Phi)
     = theorem 'fp-implies-regex
             { all-sVars(fp(proofHint(Phi)) -> Phi) colon SVar }
             colon $ fp(proofHint(Phi)) -> Phi $ ; .

    op proof-fp-implies-regex : Node -> MM0SExpr .
    eq proof-fp-implies-regex(node(check-ewp[ epsilon ], none)) = 'id .
    eq proof-fp-implies-regex(backlink(< Alpha >)) = 'fp-implies-regex-leaf .
    --- Context, Original Term, Continuation
    eq proof-fp-implies-regex(node(S, eqEdge(applResult(R, Ctx, Subst), N))) = [ 'apply-equiv lift-equality-to-context(Ctx, upTerm(S), upTerm(getState(N)), eq-thm(Subst, R)) proof-fp-implies-regex(N) ] .
    eq proof-fp-implies-regex(node(S, eqEdge(applResult(R, Ctx, Subst), N))) = [ 'apply-equiv lift-equality-to-context(Ctx, upTerm(S), upTerm(getState(N)), eq-thm(Subst, R)) proof-fp-implies-regex(N) ] .
    eq proof-fp-implies-regex(node(< Alpha >, rlEdge(applResult('check-ewp, CtxEWP, Subst_EWP), N_EWP) ;
                                       rlEdge(applResult('der-a,     Ctx_A, Subst_A), N_A) ;
                                       rlEdge(applResult('der-b,     Ctx_B, Subst_B), N_B)
                      )    )
     = [ 'fp-implies-regex-interior
            positivity(F(Alpha), fp(N_A))
            positivity(F(Alpha), fp(N_B))
            proof-fp-implies-regex(N_EWP)
            [ 'norm-lemma propag-sSubst(qid(str(Alpha)), fp(N_A))  proof-fp-implies-regex(N_A)]
            [ 'norm-lemma propag-sSubst(qid(str(Alpha)), fp(N_B))  proof-fp-implies-regex(N_B)]
       ]
     .

endm
