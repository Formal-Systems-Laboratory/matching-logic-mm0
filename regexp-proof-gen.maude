fmod PATTERN-METAMATH-CORE is
    protecting QID .
    sorts Symbol SVar EVar Pattern .
    subsorts Symbol SVar EVar < Pattern .

    vars phi phi1 phi2 psi psi1 psi2 : Pattern .
    vars x y X Y : Qid .

    *** Core ***************************************
    op sVar _ : Qid -> SVar [ctor] .
    op eVar _ : Qid -> EVar [ctor] .
    op sym  _ : Qid -> Symbol [ctor] .
    op app _ _ : Pattern Pattern -> Pattern [ctor] .
    op _ -> _  : Pattern Pattern -> Pattern [ctor] .
    op mu _ _  : Qid     Pattern -> Pattern [ctor] .
    op bot         : -> Pattern [ctor] .
    op exists _ _ : Qid Pattern -> Pattern [ctor] .

    *** Standard sugar **********************************
    op _ /\ _       : Pattern Pattern -> Pattern [ctor] .
    op _ \/ _       : Pattern Pattern -> Pattern [ctor] .
    op nu _ _       : Qid Pattern     -> Pattern [ctor] .
    op forall _ _   : Qid Pattern     -> Pattern [ctor] .
    op ~ _           : Pattern         -> Pattern [ctor] .

    *** ERE *********************************************
    op epsilon      :                 -> Pattern [ctor] .

    --- TODO: Ideally, we'd want to be parametric over an alphabet.
    --- However, two letters are enough to encode all words.
    sort Letter .
    subsort Letter < Pattern .
    op a            :                 -> Letter [ctor] .
    op b            :                 -> Letter [ctor] .
    op top-letter   :                 -> Pattern [ctor] .
    op kleene _ _   : Qid Pattern     -> Pattern [ctor prec 25] .

    op _ . _        : Pattern Pattern -> Pattern [ctor prec 28] .

    op (derivative _ _) : Pattern Pattern -> Pattern [ctor] .
endfm

fmod PATTERN-METAMATH is
    including PATTERN-METAMATH-CORE .

    *** ERE sugar
    vars Alpha Beta Gamma : Pattern .
    --- NOT FOR INTERNAL USE.
    op top : -> Pattern .
    eq top = ~ bot .

    op _ + _        : Pattern Pattern -> Pattern [prec 30] .
    eq Alpha + Beta = Alpha \/ Beta .

    op _ *          : Pattern -> Pattern [prec 30] .
    eq Alpha * = kleene 'Xk Alpha .

    op _ ->> _        : Pattern Pattern -> Pattern [prec 31] .
    eq Alpha ->> Beta = (~ Alpha) \/ Beta .

    op _ <<->> _       : Pattern Pattern -> Pattern [prec 32] .
    eq Alpha <<->> Beta = (Alpha ->> Beta) /\ (Beta ->> Alpha) .

    --- Internal sorting of patterns
    sort Comparison .
    ops LT EQ GT : -> Comparison [ctor] .

    op toNat : Pattern -> Nat .
    op (_ <=> _) : Pattern Pattern -> Comparison .

    vars phi phi1 phi2 psi psi1 psi2 : Pattern .
    vars x y X Y : Qid .

    *** ! Changing these values also requires changing the two *-choice-comm-leaf rules
    eq toNat(bot) = 0 .
    eq toNat(epsilon) = 1 .
    eq toNat(a) = 2 .
    eq toNat(b) = 3 .
    eq toNat(top) = 4 .
    eq toNat(kleene X phi) = 5 .
    eq toNat(~ phi) = 6 .
    eq toNat(phi1 . phi2) = 7 .
    eq toNat(phi1 /\ phi2) = 8 .
    eq toNat(phi1 \/ phi2) = 9 .
    eq toNat(phi1 -> phi2) = 10 .
    eq toNat(derivative phi1 phi2) = 11 .

    eq phi <=> phi = EQ .
    ceq phi <=> psi = LT if toNat(phi) < toNat(psi) .
    ceq phi <=> psi = GT if toNat(phi) > toNat(psi) .
    eq (kleene X phi) <=> (kleene X psi) = phi <=> psi .
    eq (~ phi) <=> (~ psi) = phi <=> psi .
    ceq (phi1 . phi2) <=> (psi1 . psi2) = phi2 <=> psi2 if phi1 <=> psi1 = EQ .
    eq (phi1 . phi2) <=> (psi1 . psi2) = phi1 <=> psi1 [owise] .
    ceq (phi1 /\ phi2) <=> (psi1 /\ psi2) = phi2 <=> psi2 if phi1 <=> psi1 = EQ .
    eq (phi1 /\ phi2) <=> (psi1 /\ psi2) = phi1 <=> psi1 [owise] .
    ceq (phi1 \/ phi2) <=> (psi1 \/ psi2) = phi2 <=> psi2 if phi1 <=> psi1 = EQ .
    eq (phi1 \/ phi2) <=> (psi1 \/ psi2) = phi1 <=> psi1 [owise] .
    ceq (phi1 -> phi2) <=> (psi1 -> psi2) = phi2 <=> psi2 if phi1 <=> psi1 = EQ .
    eq (phi1 -> phi2) <=> (psi1 -> psi2) = phi1 <=> psi1 [owise] .
    ceq (derivative phi1 phi2) <=> (derivative psi1 psi2) = phi2 <=> psi2 if phi1 <=> psi1 = EQ .
    eq (derivative phi1 phi2) <=> (derivative psi1 psi2) = phi1 <=> psi1 [owise] .
endfm

mod ERE-THEOREMS is
    protecting PATTERN-METAMATH .
    protecting META-TERM . --- TODO: I think this is required due to a bug in maude 2.7
                           --- I get this warning: Advisory: could not find sort Sort in meta-module ERE-THEOREMS.
                           --- Does this go away in newer versions of Maude?

    vars Alpha Alpha1 Alpha2 : Pattern .
    vars Beta  Beta1  Beta2  : Pattern .
    vars Gamma : Pattern .
    vars A B A1 A2 : Letter .
    vars X Y : Qid . 

    rl [regex_eq_der_bot]     : (derivative A bot)          => bot .
    rl [regex_eq_der_epsilon] : (derivative A epsilon)      => bot .
    rl [regex_eq_der_same_a]  : (derivative A A)            => epsilon .
   crl [regex_eq_der_diff_a]  : (derivative A B)            => bot if A =/= B .

    rl [regex_eq_der_kleene]  : (derivative A (kleene X Alpha))         => (derivative A Alpha) . (kleene X Alpha) .
    rl [regex_eq_der_concat]  : (derivative A (Alpha . Beta))  => ((derivative A Alpha) . Beta) \/  ((epsilon /\ Alpha) . (derivative A Beta)) .
    rl [regex_eq_der_choice]  : (derivative A (Alpha \/ Beta)) => (derivative A Alpha) \/ (derivative A Beta) .
    rl [regex_eq_der_conj]    : (derivative A (Alpha /\ Beta)) => (derivative A Alpha) /\ (derivative A Beta) .
    rl [regex_eq_der_neg]     : (derivative A ~ Alpha)         => ~ (derivative A Alpha) .

    rl [regex_eq_ewp_bot]     : epsilon /\ bot             => bot .
    rl [regex_eq_ewp_epsilon] : epsilon /\ epsilon         => epsilon .
    rl [regex_eq_ewp_a]       : epsilon /\ a               => bot .
    rl [regex_eq_ewp_b]       : epsilon /\ b               => bot .
    rl [regex_eq_ewp_concat]  : epsilon /\ (Alpha . Beta)  => (epsilon /\ Alpha) /\ (epsilon /\ Beta) .
    rl [regex_eq_ewp_and]     : epsilon /\ (Alpha /\ Beta) => (epsilon /\ Alpha) /\ (epsilon /\ Beta) .
    rl [regex_eq_ewp_choice]  : epsilon /\ (Alpha \/ Beta) => (epsilon /\ Alpha) \/ (epsilon /\ Beta) .
    rl [regex_eq_ewp_kleene]  : epsilon /\ (kleene X Alpha)       => epsilon .

    rl [regex_eq_ewp_not_bot]     : epsilon /\ ~(bot)           => epsilon .
    rl [regex_eq_ewp_not_eps]     : epsilon /\ ~(epsilon)       => bot .
    rl [regex_eq_ewp_not_a]       : epsilon /\ ~(a)             => epsilon .
    rl [regex_eq_ewp_not_b]       : epsilon /\ ~(b)             => epsilon .
    rl [regex_eq_ewp_not_concat]  : epsilon /\ ~(Alpha . Beta)  => (epsilon /\ ~ Alpha) \/ (epsilon /\ ~ Beta) .
    rl [regex_eq_ewp_not_and]     : epsilon /\ ~(Alpha /\ Beta) => (epsilon /\ ~ Alpha) \/ (epsilon /\ ~ Beta) .
    rl [regex_eq_ewp_not_choice]  : epsilon /\ ~(Alpha \/ Beta) => (epsilon /\ ~ Alpha) /\ (epsilon /\ ~ Beta) .
    rl [regex_eq_ewp_not_kleene]  : epsilon /\ ~(kleene X Alpha)       => bot .
    rl [regex_eq_ewp_not_not]     : epsilon /\ ~(~ Alpha)       => epsilon /\ Alpha .

    --- Identity and idemoptency of \/
    rl [regex_eq_or_choice_abs] : (~ bot)   \/ Alpha => (~ bot) .
    rl [regex_eq_or_choice_unit] : bot   \/ Alpha => Alpha .
    rl [regex_eq_or_choice_idem] : Alpha \/ Alpha => Alpha .
    rl [regex_eq_or_choice_assoc] : (Alpha \/ Beta) \/ Gamma  => Alpha \/ (Beta \/ Gamma) .
   crl [regex_eq_or_choice_comm_node] : Alpha \/ (Beta \/ Gamma) => Beta \/ (Alpha \/ Gamma) if Alpha <=> Beta = GT .
   crl [regex_eq_or_choice_comm_leaf] : Alpha \/ Beta => Beta \/ Alpha if (Alpha <=> Beta == GT) and (toNat(Beta) =/= 9) .

    --- Identity and idemoptency of /\
    rl [regex_eq_and_choice_abs] : bot   /\ Alpha => bot .
    rl [regex_eq_and_choice_unit] : (~ bot)   /\ Alpha => Alpha .
    rl [regex_eq_and_choice_idem] : Alpha /\ Alpha => Alpha .
    rl [regex_eq_and_choice_assoc] : (Alpha /\ Beta) /\ Gamma  => Alpha /\ (Beta /\ Gamma) .
   crl [regex_eq_and_choice_comm_node] : Alpha /\ (Beta /\ Gamma) => Beta /\ (Alpha /\ Gamma) if Alpha <=> Beta = GT .
   crl [regex_eq_and_choice_comm_leaf] : Alpha /\ Beta => Beta /\ Alpha if (Alpha <=> Beta == GT) and (toNat(Beta) =/= 8) .

    ---- Optional simplifications
    rl [regex_eq_bot_concat_l] : bot . Alpha => bot .
    rl [regex_eq_bot_concat_r] : Alpha . bot => bot .

    rl [regex_eq_eps_concat_l] : epsilon . Alpha => Alpha .
    rl [regex_eq_eps_concat_r] : Alpha . epsilon => Alpha .

    rl [regex_eq_double_neg] : ~ ~ Alpha => Alpha .
    rl [regex_eq_double_kleene] : (kleene X (kleene Y Alpha)) => (kleene X Alpha) .

    rl [regex_eq_eps_kleene] : (kleene X epsilon) => epsilon .
    rl [regex_eq_bot_kleene] : (kleene X bot) => epsilon .


    *** Rules *********************************
    *******************************************

    sort State .
    op < _ > : Pattern -> State [ctor] .
    op < invalid > : -> State [ctor] .

    eq < bot > = < invalid > . --- This should never be reached.
    rl [der-a]     : < Alpha > => < (derivative a Alpha) > .
    rl [der-b]     : < Alpha > => < (derivative b Alpha) > .
    rl [check-ewp] : < Alpha > => check-ewp[ (epsilon /\ Alpha) ] .

    --- We don't want the derivative rules to apply when checking EWS.
    op check-ewp[ _ ] : Pattern -> State [ctor] .
    op < id > : -> State [ctor] .
    eq check-ewp[ epsilon ] = < id > .
endm

--- Manually performs a search, and returns the search graph as a tree with backlinks.
mod PROOF-GEN is
    extending ERE-THEOREMS .
    protecting META-LEVEL .
    protecting NAT .

    sorts Edge NeEdges Edges Node EdgeLabel .
    subsorts Edge < NeEdges < Edges .
    op none : -> Edges [ctor] .
    op eqEdge : EdgeLabel Node -> Edge [ctor] .
    op rlEdge : EdgeLabel Node -> Edge [ctor] .
    op _ ; _ : NeEdges NeEdges -> NeEdges [ctor assoc comm id: none] .
    op _ ; _ : Edges Edges -> Edges [ditto] .

    op applResult : Qid Context Substitution -> EdgeLabel [ctor] .

    op node : State Edges -> Node [ctor] .
    op backlink : State -> Node [ctor] .
    op depthReached : State -> Node [ctor] .

    var NAT : Nat .
    vars Es : NeEdges . vars Es? : Edges .
    vars T : Term . vars TL TL' : TermList .
    vars P : Pattern .
    vars S : State . vars SL SL' : StateList .
    vars X Y Z R Q : Qid . vars Result : Result4Tuple .
    vars Es1 Es2 : NeEdges .
    vars EL : EdgeLabel .
    vars N N_EWP N_A N_B : Node .
    vars Subst Subst_EWP Subst_A Subst_B : Substitution .
    vars Ctx CtxEWP Ctx_A Ctx_B : Context .

    sorts NeStateList StateList .
    subsort State < NeStateList < StateList .

    op empty : -> StateList [ctor] .
    op _,_ : NeStateList StateList -> NeStateList [ctor assoc id: empty gather (e E) prec 121] . --- Same as TermList
    op _,_ : StateList NeStateList -> NeStateList [ctor ditto] .
    op _,_ : StateList StateList -> StateList [ctor ditto] .

    op _ in _ : State StateList -> Bool .
    eq S in (SL , S , SL') = true .
    eq S in SL = false [owise] .

   --- curr term, previous terms, depth
    op mkProofHint : State StateList Nat -> Node .
   ceq mkProofHint(S, SL, NAT) = backlink(S)                              if      S in SL .
   ceq mkProofHint(S, SL, NAT) = node(S, applyAnyEquation(S, SL, NAT))      if (not S in SL) /\ Es := applyAnyEquation(S, SL, NAT) .
   ceq mkProofHint(S, SL, s(NAT)) = node(S, applyAllRules(S, (SL, S), NAT)) if (not S in SL) /\ none = applyAnyEquation(S, SL, NAT) .
   ceq mkProofHint(S, SL, 0) = depthReached(S)                          if (not S in SL) /\ none = applyAnyEquation(S, SL, 0) .

    op applyAnyEquation : State StateList Nat -> Edges .
    eq applyAnyEquation(S, SL, NAT) =
        applyEq(S, SL, NAT, 'regex_eq_der_bot) or-else
        applyEq(S, SL, NAT, 'regex_eq_der_epsilon) or-else
        applyEq(S, SL, NAT, 'regex_eq_der_same_a) or-else
        applyEq(S, SL, NAT, 'regex_eq_der_diff_a) or-else
        applyEq(S, SL, NAT, 'regex_eq_der_kleene) or-else
        applyEq(S, SL, NAT, 'regex_eq_der_concat) or-else
        applyEq(S, SL, NAT, 'regex_eq_der_choice) or-else
        applyEq(S, SL, NAT, 'regex_eq_der_conj) or-else
        applyEq(S, SL, NAT, 'regex_eq_der_neg) or-else
        applyEq(S, SL, NAT, 'regex_eq_ewp_bot) or-else
        applyEq(S, SL, NAT, 'regex_eq_ewp_epsilon) or-else
        applyEq(S, SL, NAT, 'regex_eq_ewp_a) or-else
        applyEq(S, SL, NAT, 'regex_eq_ewp_b) or-else
        applyEq(S, SL, NAT, 'regex_eq_ewp_concat) or-else
        applyEq(S, SL, NAT, 'regex_eq_ewp_and) or-else
        applyEq(S, SL, NAT, 'regex_eq_ewp_choice) or-else
        applyEq(S, SL, NAT, 'regex_eq_ewp_kleene) or-else
        applyEq(S, SL, NAT, 'regex_eq_ewp_not_bot) or-else
        applyEq(S, SL, NAT, 'regex_eq_ewp_not_eps) or-else
        applyEq(S, SL, NAT, 'regex_eq_ewp_not_a) or-else
        applyEq(S, SL, NAT, 'regex_eq_ewp_not_b) or-else
        applyEq(S, SL, NAT, 'regex_eq_ewp_not_concat) or-else
        applyEq(S, SL, NAT, 'regex_eq_ewp_not_and) or-else
        applyEq(S, SL, NAT, 'regex_eq_ewp_not_choice) or-else
        applyEq(S, SL, NAT, 'regex_eq_ewp_not_kleene) or-else
        applyEq(S, SL, NAT, 'regex_eq_ewp_not_not) or-else


        applyEq(S, SL, NAT, 'regex_eq_or_choice_abs) or-else
        applyEq(S, SL, NAT, 'regex_eq_or_choice_unit) or-else
        applyEq(S, SL, NAT, 'regex_eq_or_choice_idem) or-else
        applyEq(S, SL, NAT, 'regex_eq_or_choice_assoc) or-else
        applyEq(S, SL, NAT, 'regex_eq_or_choice_comm_node) or-else
        applyEq(S, SL, NAT, 'regex_eq_or_choice_comm_leaf) or-else
        applyEq(S, SL, NAT, 'regex_eq_and_choice_abs) or-else
        applyEq(S, SL, NAT, 'regex_eq_and_choice_unit) or-else
        applyEq(S, SL, NAT, 'regex_eq_and_choice_idem) or-else
        applyEq(S, SL, NAT, 'regex_eq_and_choice_assoc) or-else
        applyEq(S, SL, NAT, 'regex_eq_and_choice_comm_node) or-else
        applyEq(S, SL, NAT, 'regex_eq_and_choice_comm_leaf) or-else

        applyEq(S, SL, NAT, 'regex_eq_bot_concat_l) or-else
        applyEq(S, SL, NAT, 'regex_eq_bot_concat_r) or-else
        applyEq(S, SL, NAT, 'regex_eq_eps_concat_l) or-else
        applyEq(S, SL, NAT, 'regex_eq_eps_concat_r) or-else
        applyEq(S, SL, NAT, 'regex_eq_double_neg) or-else
        applyEq(S, SL, NAT, 'regex_eq_double_kleene) or-else
        applyEq(S, SL, NAT, 'regex_eq_eps_kleene) or-else
        applyEq(S, SL, NAT, 'regex_eq_bot_kleene)
        .

    --- The strat attribute is needed to get decent preformance.
    --- Otherwise, it would compute all possible outward edges and throw all but one away,
    --- leading to exponential complexity.
    op _ or-else _ : Edges Edges -> Edges [strat (1 0) gather (e E)] .
    eq E:Edge or-else Es:Edges = E:Edge .
    eq none or-else Es? = Es? .

    op applyAllRules : State StateList Nat -> Edges .
    eq applyAllRules(S, SL, NAT) =
        applyRule(S, SL, NAT, 'check-ewp) ;
        applyRule(S, SL, NAT, 'der-a) ;
        applyRule(S, SL, NAT, 'der-b) .

    op myModule : -> Module .
    eq myModule = upModule('ERE-THEOREMS, false) .

    op < error > : -> [State] .

    op applyEq : State StateList Nat Qid -> Edges .
   ceq applyEq(S, SL, NAT, R) = eqEdge( applResult(R, getContext(Result), getSubstitution(Result))
                                      , mkProofHint(downTerm(getTerm(Result), < error >), SL, NAT)
                                      )
    if Result := metaXapply(myModule, upTerm(S), R, none, 0, unbounded, 0) .
    eq applyEq(S, SL, NAT, R) = none [owise] .

    op applyRule : State StateList Nat Qid -> Edges .
   ceq applyRule(S, SL, NAT, R) = rlEdge( applResult(R, getContext(Result), getSubstitution(Result))
                                        , mkProofHint(downTerm(getTerm(Result), < error >), SL, NAT)
                                        )
    if Result := metaXapply(myModule, upTerm(S), R, none, 0, unbounded, 0) .
    eq applyRule(S, SL, NAT, R) = none [owise] .

    vars Alpha Alpha1 Alpha2 : Pattern .
    vars Beta  Beta1  Beta2  : Pattern .
    vars Phi   Phi1   Phi2   : Pattern .
    vars A B A1 A2 : Letter .


    *** Proof hint generation ************************************************

    op getRegExp : State -> Pattern .
    eq getRegExp(< Alpha >) = Alpha .
    eq getRegExp(check-ewp[ Alpha ]) = Alpha .
    eq getRegExp(< id >) = epsilon -> epsilon .

    op ruleLabelToLetter : Qid -> Pattern .
    eq ruleLabelToLetter('check-ewp) = epsilon .
    eq ruleLabelToLetter('der-a) = a .
    eq ruleLabelToLetter('der-b) = b .

    op proofHint : Pattern -> Node .
    eq proofHint(Alpha) = mkProofHint(< Alpha >, empty, 6) .

    *** Mapping EREs to its Matching Logic signature *************************
    --- We may consider desugaring the constructors via the notation defined
    --- in some other module. But I'm not sure it will be necessary.

    --- Generate a fresh set variable for each regexp.
    op F : Pattern -> SVar .
    eq F(Alpha) = sVar (qid(str(Alpha))) .

    op str : Pattern -> String .
    eq str(bot) = "z" .
    eq str(a) = "a" .
    eq str(b) = "b" .
    eq str(epsilon) = "e" .
    eq str(Alpha . Beta) = "C" + str(Alpha) + str(Beta) + "D" .
    eq str(Alpha \/ Beta) = "C" + str(Alpha) + "p" + str(Beta) + "D" .
    eq str(Alpha /\ Beta) = "C" + str(Alpha) + "q" + str(Beta) + "D" .
    eq str(Alpha -> Beta) = "C" + str(Alpha) + "i" + str(Beta) + "D" .
    eq str(kleene X Alpha) = "C" + str(Alpha) + "Dx" .
    eq str(~ Alpha) = "nC" + str(Alpha) + "D" .

    *** fp *******************************************************************
    --- Here, we generate the fixedpoint needed for our proof.

    op fp : Node -> Pattern .
    eq fp(backlink(< Alpha >)) = F(Alpha) .
    eq fp(node(< Alpha >, eqEdge(EL, N))) = fp(N) .
    eq fp(node(< Alpha >, rlEdge(applResult('check-ewp, CtxEWP, Subst_EWP), N_EWP) ;
                          rlEdge(applResult('der-a,     Ctx_A, Subst_A), N_A) ;
                          rlEdge(applResult('der-b,     Ctx_B, Subst_B), N_B)
         )    )
     = mu qid(str(Alpha)) (epsilon \/ ((a . fp(N_A)) \/ (b . fp(N_B)))) [owise] .


    *** der-tree *************************************************************
    --- Simplify proofHint into derivative tree (debugging only).

    op der-tree : Node -> Node .
    eq der-tree(backlink(< Alpha >)) = backlink(< Alpha >) .
    eq der-tree(node(< Alpha >, eqEdge(EL, N))) = der-tree(N) .
    eq der-tree(node(< Alpha >, rlEdge(applResult('check-ewp, CtxEWP, Subst_EWP), N_EWP) ;
                                rlEdge(applResult('der-a,     Ctx_A, Subst_A), N_A) ;
                                rlEdge(applResult('der-b,     Ctx_B, Subst_B), N_B)
         )    )
     = node(< Alpha >, rlEdge(applResult('der-a,     [], none), der-tree(N_A)) ;
                       rlEdge(applResult('der-b,     [], none), der-tree(N_B))
           )    [owise] .


    *** Metamath proofs ******************************************************

    sort MetaMathProof .

    op id : -> MetaMathProof .
    --- The Qids corresponding to equational rules are all theorems.
    subsort Qid < MetaMathProof .
    vars MMP : MetaMathProof .

    *** Contextual reasoning with equalities *********************************

    vars LR : String .
    op cong-thm : Qid String -> Qid .
    eq cong-thm('_->_, LR) = qid("imp" + LR) .
    eq cong-thm('_\/_, LR) = qid("or" + LR) .
    eq cong-thm('_/\_, LR) = qid("and" + LR) .
    eq cong-thm('_._, LR) = qid("concat" + LR) .
    eq cong-thm('~_, LR) = 'not .
    eq cong-thm('kleene__, LR) = 'kleene .

    op eq-thm : Substitution Qid -> Qid .
    eq eq-thm('A:Letter <- Q ; Subst , R) = qid(string(R) + "-wrt-" + string(getName(Q))) .
    eq eq-thm(          Subst , R) = R [owise] .


    op cong-of-equiv _ _ : Qid MetaMathProof -> MetaMathProof [ctor] .

    op lift-equality-to-context _  _ : Context MetaMathProof -> MetaMathProof .
    eq lift-equality-to-context [] MMP = MMP .

    --- special cases for state ctors
    eq lift-equality-to-context ('check-ewp`[_`][ Ctx ]) MMP = lift-equality-to-context Ctx MMP .
    eq lift-equality-to-context ('<_>[ Ctx ]) MMP = lift-equality-to-context Ctx MMP .

    eq lift-equality-to-context (Q [ Ctx ]) MMP
     = cong-of-equiv cong-thm(Q, "") (lift-equality-to-context Ctx MMP) .
    eq lift-equality-to-context (Q [ Ctx , T ] ) MMP
     = cong-of-equiv cong-thm(Q, "-l") (lift-equality-to-context Ctx MMP) .
    eq lift-equality-to-context (Q [ T , Ctx ] ) MMP
     = cong-of-equiv cong-thm(Q, "-r") (lift-equality-to-context Ctx MMP) .

    op apply-equiv _ _ : MetaMathProof MetaMathProof -> MetaMathProof [ctor] .

    *** push-s-subst *********************************************************

    op propag-sSubst : Qid Pattern -> MetaMathProof .
    eq propag-sSubst(X, bot) = 'sSubstitution-triv .
    eq propag-sSubst(X, top) = 'sSubstitution-triv .
    eq propag-sSubst(X, eVar X) = 'sSubstitution-triv .
    eq propag-sSubst(X, sVar X) = 'sSubstitution-in-same-sVar .
   ceq propag-sSubst(X, sVar Y) = 'sSubstitution-triv if X =/= Y .
    eq propag-sSubst(X, mu X Phi) = 'sSubstitution-in-same-mu .
   ceq propag-sSubst(X, mu Y Phi) = -sSubst-mu propag-sSubst(X, Phi) if X =/= Y .
    eq propag-sSubst(X, Phi1 \/ Phi2) = -sSubst-or propag-sSubst(X, Phi1) propag-sSubst(X, Phi2) .

    eq propag-sSubst(X, Phi1 . Phi2) = sSubst-concat propag-sSubst(X, Phi1) propag-sSubst(X, Phi2) .
    eq propag-sSubst(X, a) = 'sSubstitution-triv .
    eq propag-sSubst(X, b) = 'sSubstitution-triv .
    eq propag-sSubst(X, epsilon) = 'sSubstitution-triv .
    eq propag-sSubst(X, top-letter) = 'sSubstitution-triv .

    op -sSubst-mu _ : MetaMathProof -> MetaMathProof [ctor] .
    op -sSubst-or _ _ : MetaMathProof MetaMathProof -> MetaMathProof [ctor] .
    op sSubst-concat _ _ : MetaMathProof MetaMathProof -> MetaMathProof [ctor] .

    op norm-lemma _ _ : MetaMathProof MetaMathProof -> MetaMathProof [ctor] .
    op norm-lemma-r _ _ : MetaMathProof MetaMathProof -> MetaMathProof [ctor] .

    *** pos ******************************************************************
    op positivity : Qid Pattern -> MetaMathProof .
    eq positivity(X, sVar X) = positive-in-same-sVar .
   ceq positivity(X, sVar Y) = positive-in-sVar if X =/= Y  .
    eq positivity(X, mu X Phi) = positive-in-same-mu .
   ceq positivity(X, mu Y Phi) = ( positive-in-mu positivity(X, Phi) )  if X =/= Y .
    eq positivity(X, Phi1 \/ Phi2) = positive-in-or positivity(X, Phi1) positivity(X, Phi2) .
    eq positivity(X, epsilon) = positive-triv .
    eq positivity(X, a) = positive-triv .
    eq positivity(X, b) = positive-triv .
    eq positivity(X, Phi1 . Phi2) = positive-in-concat positivity(X, Phi1) positivity(X, Phi2) .


    op positive-in-sVar : -> MetaMathProof .
    op positive-in-same-sVar : -> MetaMathProof .
    op positive-triv : -> MetaMathProof .
    op positive-in-mu _ : MetaMathProof -> MetaMathProof .
    op positive-in-same-mu : -> MetaMathProof .
    op positive-in-or _ _ : MetaMathProof MetaMathProof  -> MetaMathProof .
    op positive-in-concat _ _ : MetaMathProof MetaMathProof  -> MetaMathProof .

    *** unfold ***************************************************************
    op unfold-r : Pattern MetaMathProof -> MetaMathProof .
    eq unfold-r(mu X Phi, MMP) = (unfold-r positivity(X, Phi) MMP) .

    op unfold-r _ _ : MetaMathProof MetaMathProof -> MetaMathProof .

    *** top-implies-fp *******************************************************

    *** fp-implies-regex ************************************************************
    --- Here, we the proof for (fp -> Alpha) .

    op fp-implies-regex-leaf : -> MetaMathProof [ctor] .
    op fp-implies-regex-interior _ _ _ : MetaMathProof MetaMathProof MetaMathProof -> MetaMathProof [ctor] .

    op proof-fp-implies-regex : Node -> MetaMathProof .
    eq proof-fp-implies-regex(node(< id >, none)) = id .
    eq proof-fp-implies-regex(backlink(< Alpha >)) = fp-implies-regex-leaf .
    eq proof-fp-implies-regex(node(check-ewp[ Alpha ], eqEdge(applResult(R, Ctx, Subst), N))) = apply-equiv (lift-equality-to-context Ctx eq-thm(Subst, R)) proof-fp-implies-regex(N) .
    eq proof-fp-implies-regex(node(< Alpha >,          eqEdge(applResult(R, Ctx, Subst), N))) = apply-equiv (lift-equality-to-context Ctx eq-thm(Subst, R)) proof-fp-implies-regex(N) .
    eq proof-fp-implies-regex(node(< Alpha >, rlEdge(applResult('check-ewp, CtxEWP, Subst_EWP), N_EWP) ;
                                       rlEdge(applResult('der-a,     Ctx_A, Subst_A), N_A) ;
                                       rlEdge(applResult('der-b,     Ctx_B, Subst_B), N_B)
                      )    )
     = fp-implies-regex-interior
            proof-fp-implies-regex(N_EWP)
            (norm-lemma propag-sSubst(qid(str(Alpha)), fp(N_A))  proof-fp-implies-regex(N_A))
            (norm-lemma propag-sSubst(qid(str(Alpha)), fp(N_B))  proof-fp-implies-regex(N_B))
     .
endm

--- search in ERE-THEOREMS : ((a . a)* ->> ((a * . a) \/ epsilon)) =>* P:Pattern .
--- show search graph .

set print with parentheses on .
--- search  (epsilon -> (epsilon /\ (( ~ ((a . a) *)) \/ (((a *) . a) \/ epsilon)))) =>! P:Pattern .
--- show search graph .
--- reduce proofHint((a . a)* ->> ((a * . a) \/ epsilon)) .
--- reduce fp(proofHint((a . a)* ->> ((a * . a) \/ epsilon))) .
--- reduce proof-fp-implies-regex(proofHint((a . a)* ->> ((a * . a) \/ epsilon))) .
