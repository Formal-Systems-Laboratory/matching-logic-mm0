fmod PATTERN-METAMATH is
    protecting QID .
    sorts Symbol SVar EVar Pattern .
    subsorts Symbol SVar EVar < Pattern .

    vars phi phi1 phi2 psi psi1 psi2 : Pattern .
    vars x y X Y : Qid .

    *** core
    op sVar _ : Qid -> SVar [ctor] .
    op eVar _ : Qid -> EVar [ctor] .
    op app _ _ : Pattern Pattern -> Pattern [ctor] .
    op _ -> _  : Pattern Pattern -> Pattern [ctor] .
    op mu _ _  : Qid     Pattern -> Pattern [ctor] .
    op bot         : -> Pattern [ctor] .
    op exists _ _ : Qid Pattern -> Pattern [ctor] .

    op top : -> Pattern [ctor] .
    op _ /\ _       : Pattern Pattern -> Pattern [ctor] .
    op _ \/ _       : Pattern Pattern -> Pattern [ctor] .
    op nu _ _       : Qid Pattern     -> Pattern [ctor] .
    op forall _ _   : Qid Pattern     -> Pattern [ctor] .
    op _ <-> _       : Pattern Pattern -> Pattern [ctor] .
    op ~ _           : Pattern         -> Pattern [ctor] .

    *** ERE
    op epsilon      :                 -> Pattern [ctor] .

    --- TODO: Ideally, we'd want to be parametric over an alphabet.
    --- However, two letters are enough to encode all words.
    sort Letter .
    subsort Letter < Pattern .
    op a            :                 -> Letter [ctor] .
    op b            :                 -> Letter [ctor] .

    op _ . _        : Pattern Pattern -> Pattern [ctor] .
    op _ *          : Pattern         -> Pattern [ctor] .

    op (derivative _ _) : Pattern Pattern -> Pattern [ctor] .

    *** ERE sugar
    vars Alpha Beta Gamma : Pattern .
    --- NOT FOR INTERNAL USE.
    op _ + _        : Pattern Pattern -> Pattern .
    eq Alpha + Beta = Alpha \/ Beta .

    op _ --> _        : Pattern Pattern -> Pattern .
    eq Alpha --> Beta = (~ Alpha) \/ Beta .

    --- Internal sorting of patterns
    sort Comparison .
    ops LT EQ GT : -> Comparison [ctor] .

    op toNat : Pattern -> Nat .
    op (_ <=> _) : Pattern Pattern -> Comparison .

    *** ! Changing these values also requires changing the two *-choice-comm-leaf rules
    eq toNat(bot) = 0 .
    eq toNat(epsilon) = 1 .
    eq toNat(a) = 2 .
    eq toNat(b) = 3 .
    eq toNat(top) = 4 .
    eq toNat(phi *) = 5 .
    eq toNat(~ phi) = 6 .
    eq toNat(phi1 . phi2) = 7 .
    eq toNat(phi1 /\ phi2) = 8 .
    eq toNat(phi1 \/ phi2) = 9 .
    eq toNat(phi1 -> phi2) = 10 .
    eq toNat(derivative phi1 phi2) = 11 .

    eq phi <=> phi = EQ .
    ceq phi <=> psi = LT if toNat(phi) < toNat(psi) .
    ceq phi <=> psi = GT if toNat(phi) > toNat(psi) .
    eq (phi *) <=> (psi *) = phi <=> psi .
    eq (~ phi) <=> (~ psi) = phi <=> psi .
    ceq (phi1 . phi2) <=> (psi1 . psi2) = phi2 <=> psi2 if phi1 <=> psi1 = EQ .
    eq (phi1 . phi2) <=> (psi1 . psi2) = phi1 <=> psi1 [owise] .
    ceq (phi1 /\ phi2) <=> (psi1 /\ psi2) = phi2 <=> psi2 if phi1 <=> psi1 = EQ .
    eq (phi1 /\ phi2) <=> (psi1 /\ psi2) = phi1 <=> psi1 [owise] .
    ceq (phi1 \/ phi2) <=> (psi1 \/ psi2) = phi2 <=> psi2 if phi1 <=> psi1 = EQ .
    eq (phi1 \/ phi2) <=> (psi1 \/ psi2) = phi1 <=> psi1 [owise] .
    ceq (phi1 -> phi2) <=> (psi1 -> psi2) = phi2 <=> psi2 if phi1 <=> psi1 = EQ .
    eq (phi1 -> phi2) <=> (psi1 -> psi2) = phi1 <=> psi1 [owise] .
    ceq (derivative phi1 phi2) <=> (derivative psi1 psi2) = phi2 <=> psi2 if phi1 <=> psi1 = EQ .
    eq (derivative phi1 phi2) <=> (derivative psi1 psi2) = phi1 <=> psi1 [owise] .
endfm

mod ERE-THEOREMS is
    protecting PATTERN-METAMATH .

    vars Alpha Alpha1 Alpha2 : Pattern .
    vars Beta  Beta1  Beta2  : Pattern .
    vars Gamma : Pattern .
    vars A B A1 A2 : Letter .

    rl [regex_eq_der_bot]     : (derivative A bot)          => bot .
    rl [regex_eq_der_epsilon] : (derivative A epsilon)      => bot .
    rl [regex_eq_der_same_a]  : (derivative A A)            => epsilon .
   crl [regex_eq_der_diff_a]  : (derivative A B)            => bot if A =/= B .

    rl [regex_eq_der_kleene]  : (derivative A Alpha *)        => (derivative A Alpha) . (Alpha *) .
    rl [regex_eq_der_concat]  : (derivative A (Alpha . Beta)) => ((derivative A Alpha) . Beta) \/  ((epsilon /\ Alpha) . (derivative A Beta)) .
    rl [regex_eq_der_choice]  : (derivative A (Alpha \/ Beta)) => (derivative A Alpha) \/ (derivative A Beta) .
    rl [regex_eq_der_neg]     : (derivative A ~ Alpha)        => ~ (derivative A Alpha) .

    rl [regex_eq_ewp_bot]     : epsilon /\ bot             => bot .
    rl [regex_eq_ewp_epsilon] : epsilon /\ epsilon         => epsilon .
    rl [regex_eq_ewp_a]       : epsilon /\ a               => bot .
    rl [regex_eq_ewp_b]       : epsilon /\ b               => bot .
    rl [regex_eq_ewp_concat]  : epsilon /\ (Alpha . Beta)  => (epsilon /\ Alpha) /\ (epsilon /\ Beta) .
    rl [regex_eq_ewp_and]     : epsilon /\ (Alpha /\ Beta) => (epsilon /\ Alpha) /\ (epsilon /\ Beta) .
    rl [regex_eq_ewp_choice]  : epsilon /\ (Alpha \/ Beta) => (epsilon /\ Alpha) \/ (epsilon /\ Beta) .
    rl [regex_eq_ewp_kleene]  : epsilon /\ (Alpha *)       => epsilon .

    rl [regex_eq_ewp_not_bot]     : epsilon /\ ~(bot)           => epsilon .
    rl [regex_eq_ewp_not_eps]     : epsilon /\ ~(epsilon)       => bot .
    rl [regex_eq_ewp_not_a]       : epsilon /\ ~(a)             => epsilon .
    rl [regex_eq_ewp_not_b]       : epsilon /\ ~(b)             => epsilon .
    rl [regex_eq_ewp_not_concat]  : epsilon /\ ~(Alpha . Beta)  => (epsilon /\ ~ Alpha) \/ (epsilon /\ ~ Beta) .
    rl [regex_eq_ewp_not_and]     : epsilon /\ ~(Alpha /\ Beta) => (epsilon /\ ~ Alpha) \/ (epsilon /\ ~ Beta) .
    rl [regex_eq_ewp_not_choice]  : epsilon /\ ~(Alpha \/ Beta) => (epsilon /\ ~ Alpha) /\ (epsilon /\ ~ Beta) .
    rl [regex_eq_ewp_not_kleene]  : epsilon /\ ~(Alpha *)       => bot .
    rl [regex_eq_ewp_not_not]     : epsilon /\ ~(~ Alpha)       => epsilon /\ Alpha .

    --- Identity and idemoptency of \/
    rl [regex_eq_or_choice_abs] : top   \/ Alpha => top .
    rl [regex_eq_or_choice_unit] : bot   \/ Alpha => Alpha .
    rl [regex_eq_or_choice_idem] : Alpha \/ Alpha => Alpha .
    rl [regex_eq_or_choice_assoc] : (Alpha \/ Beta) \/ Gamma  => Alpha \/ (Beta \/ Gamma) .
   crl [regex_eq_or_choice_comm_node] : Alpha \/ (Beta \/ Gamma) => Beta \/ (Alpha \/ Gamma) if Alpha <=> Beta = GT .
   crl [regex_eq_or_choice_comm_leaf] : Alpha \/ Beta => Beta \/ Alpha if (Alpha <=> Beta == GT) and (toNat(Beta) =/= 9) .

    --- Identity and idemoptency of /\
    rl [regex_eq_and_choice_abs] : bot   /\ Alpha => bot .
    rl [regex_eq_and_choice_unit] : top   /\ Alpha => Alpha .
    rl [regex_eq_and_choice_idem] : Alpha /\ Alpha => Alpha .
    rl [regex_eq_and_choice_assoc] : (Alpha /\ Beta) /\ Gamma  => Alpha /\ (Beta /\ Gamma) .
   crl [regex_eq_and_choice_comm_node] : Alpha /\ (Beta /\ Gamma) => Beta /\ (Alpha /\ Gamma) if Alpha <=> Beta = GT .
   crl [regex_eq_and_choice_comm_leaf] : Alpha /\ Beta => Beta /\ Alpha if (Alpha <=> Beta == GT) and (toNat(Beta) =/= 8) .

    ---- Optional simplifications
    rl [regex_eq_bot_concat_l] : bot . Alpha => bot .
    rl [regex_eq_bot_concat_r] : Alpha . bot => bot .

    rl [regex_eq_eps_concat_l] : epsilon . Alpha => Alpha .
    rl [regex_eq_eps_concat_r] : Alpha . epsilon => Alpha .

    rl [regex_eq_double_neg] : ~ ~ Alpha => Alpha .
    rl [regex_eq_double_kleene] : Alpha * * => Alpha .

    rl [regex_eq_eps_kleene] : epsilon * => epsilon .
    rl [regex_eq_bot_kleene] : bot * => epsilon .


    *** Rules *********************************
    *******************************************

    sort State .
    op < _ > : Pattern -> State [ctor] .
    op < invalid > : -> State [ctor] .

    eq < bot > = < invalid > . --- This should never be reached.
    rl [der-a]     : < Alpha > => < (derivative a Alpha) > .
    rl [der-b]     : < Alpha > => < (derivative b Alpha) > .
    rl [check-ewp] : < Alpha > => check-ewp[ epsilon -> (epsilon /\ Alpha) ] .

    --- We don't want the derivative rules to apply when checking EWS.
    op check-ewp[ _ ] : Pattern -> State [ctor] .
    op < id > : -> State [ctor] .
    eq check-ewp[ epsilon -> epsilon ] = < id > .
endm

--- Manually performs a search, and returns the search graph as a tree with backlinks.
mod PROOF-GEN is
    extending ERE-THEOREMS .
    protecting META-LEVEL .
    protecting NAT .

    sorts Edge NeEdges Edges Node EdgeLabel .
    subsorts Edge < NeEdges < Edges .
    op none : -> Edges [ctor] .
    op eqEdge : EdgeLabel Node -> Edge [ctor] .
    op rlEdge : EdgeLabel Node -> Edge [ctor] .
    op _ ; _ : NeEdges NeEdges -> NeEdges [ctor assoc comm id: none] .
    op _ ; _ : Edges Edges -> Edges [ditto] .

    op applResult : Qid Context Substitution -> EdgeLabel [ctor] .

    op node : State Edges -> Node [ctor] .
    op backlink : State -> Node [ctor] .
    op depthReached : State -> Node [ctor] .

    var NAT : Nat .
    vars Es : NeEdges . vars Es? : Edges .
    vars T : Term . vars TL TL' : TermList .
    vars P : Pattern .
    vars S : State . vars SL SL' : StateList .
    vars R Q : Qid . vars Result : Result4Tuple .
    vars Es1 Es2 : NeEdges .
    vars EL : EdgeLabel .
    vars N N_EWP N_A N_B : Node .
    vars Subst Subst_EWP Subst_A Subst_B : Substitution .
    vars Ctx CtxEWP Ctx_A Ctx_B : Context .

    sorts NeStateList StateList .
    subsort State < NeStateList < StateList .

    op empty : -> StateList [ctor] .
    op _,_ : NeStateList StateList -> NeStateList [ctor assoc id: empty gather (e E) prec 121] . --- Same as TermList
    op _,_ : StateList NeStateList -> NeStateList [ctor ditto] .
    op _,_ : StateList StateList -> StateList [ctor ditto] .

    op _ in _ : State StateList -> Bool .
    eq S in (SL , S , SL') = true .
    eq S in SL = false [owise] .

   --- curr term, previous terms, depth
    op mkProofHint : State StateList Nat -> Node .
   ceq mkProofHint(S, SL, NAT) = backlink(S)                              if      S in SL .
   ceq mkProofHint(S, SL, NAT) = node(S, applyAnyEquation(S, SL, NAT))      if (not S in SL) /\ Es := applyAnyEquation(S, SL, NAT) .
   ceq mkProofHint(S, SL, s(NAT)) = node(S, applyAllRules(S, (SL, S), NAT)) if (not S in SL) /\ none = applyAnyEquation(S, SL, NAT) .
   ceq mkProofHint(S, SL, 0) = depthReached(S)                          if (not S in SL) /\ none = applyAnyEquation(S, SL, 0) .

    op applyAnyEquation : State StateList Nat -> Edges .
    eq applyAnyEquation(S, SL, NAT) =
        applyEq(S, SL, NAT, 'regex_eq_der_bot) or-else
        applyEq(S, SL, NAT, 'regex_eq_der_epsilon) or-else
        applyEq(S, SL, NAT, 'regex_eq_der_same_a) or-else
        applyEq(S, SL, NAT, 'regex_eq_der_diff_a) or-else
        applyEq(S, SL, NAT, 'regex_eq_der_kleene) or-else
        applyEq(S, SL, NAT, 'regex_eq_der_concat) or-else
        applyEq(S, SL, NAT, 'regex_eq_der_choice) or-else
        applyEq(S, SL, NAT, 'regex_eq_der_neg) or-else
        applyEq(S, SL, NAT, 'regex_eq_ewp_bot) or-else
        applyEq(S, SL, NAT, 'regex_eq_ewp_epsilon) or-else
        applyEq(S, SL, NAT, 'regex_eq_ewp_a) or-else
        applyEq(S, SL, NAT, 'regex_eq_ewp_b) or-else
        applyEq(S, SL, NAT, 'regex_eq_ewp_concat) or-else
        applyEq(S, SL, NAT, 'regex_eq_ewp_and) or-else
        applyEq(S, SL, NAT, 'regex_eq_ewp_choice) or-else
        applyEq(S, SL, NAT, 'regex_eq_ewp_kleene) or-else
        applyEq(S, SL, NAT, 'regex_eq_ewp_not_bot) or-else
        applyEq(S, SL, NAT, 'regex_eq_ewp_not_eps) or-else
        applyEq(S, SL, NAT, 'regex_eq_ewp_not_a) or-else
        applyEq(S, SL, NAT, 'regex_eq_ewp_not_b) or-else
        applyEq(S, SL, NAT, 'regex_eq_ewp_not_concat) or-else
        applyEq(S, SL, NAT, 'regex_eq_ewp_not_and) or-else
        applyEq(S, SL, NAT, 'regex_eq_ewp_not_choice) or-else
        applyEq(S, SL, NAT, 'regex_eq_ewp_not_kleene) or-else
        applyEq(S, SL, NAT, 'regex_eq_ewp_not_not) or-else


        applyEq(S, SL, NAT, 'regex_eq_or_choice_abs) or-else
        applyEq(S, SL, NAT, 'regex_eq_or_choice_unit) or-else
        applyEq(S, SL, NAT, 'regex_eq_or_choice_idem) or-else
        applyEq(S, SL, NAT, 'regex_eq_or_choice_assoc) or-else
        applyEq(S, SL, NAT, 'regex_eq_or_choice_comm_node) or-else
        applyEq(S, SL, NAT, 'regex_eq_or_choice_comm_leaf) or-else
        applyEq(S, SL, NAT, 'regex_eq_and_choice_abs) or-else
        applyEq(S, SL, NAT, 'regex_eq_and_choice_unit) or-else
        applyEq(S, SL, NAT, 'regex_eq_and_choice_idem) or-else
        applyEq(S, SL, NAT, 'regex_eq_and_choice_assoc) or-else
        applyEq(S, SL, NAT, 'regex_eq_and_choice_comm_node) or-else
        applyEq(S, SL, NAT, 'regex_eq_and_choice_comm_leaf) or-else

        applyEq(S, SL, NAT, 'regex_eq_bot_concat_l) or-else
        applyEq(S, SL, NAT, 'regex_eq_bot_concat_r) or-else
        applyEq(S, SL, NAT, 'regex_eq_eps_concat_l) or-else
        applyEq(S, SL, NAT, 'regex_eq_eps_concat_r) or-else
        applyEq(S, SL, NAT, 'regex_eq_double_neg) or-else
        applyEq(S, SL, NAT, 'regex_eq_double_kleene) or-else
        applyEq(S, SL, NAT, 'regex_eq_eps_kleene) or-else
        applyEq(S, SL, NAT, 'regex_eq_bot_kleene)
        .

    --- The strat attribute is needed to get decent preformance.
    --- Otherwise, it would compute all possible outward edges and throw all but one away,
    --- leading to exponential complexity.
    op _ or-else _ : Edges Edges -> Edges [strat (1 0) gather (e E)] .
    eq E:Edge or-else Es:Edges = E:Edge .
    eq none or-else Es? = Es? .

    op applyAllRules : State StateList Nat -> Edges .
    eq applyAllRules(S, SL, NAT) =
        applyRule(S, SL, NAT, 'check-ewp) ;
        applyRule(S, SL, NAT, 'der-a) ;
        applyRule(S, SL, NAT, 'der-b) .

    op myModule : -> Module .
    eq myModule = upModule('ERE-THEOREMS, false) .

    op < error > : -> [State] .

    op applyEq : State StateList Nat Qid -> Edges .
   ceq applyEq(S, SL, NAT, R) = eqEdge( applResult(R, getContext(Result), getSubstitution(Result))
                                      , mkProofHint(downTerm(getTerm(Result), < error >), SL, NAT)
                                      )
    if Result := metaXapply(myModule, upTerm(S), R, none, 0, unbounded, 0) .
    eq applyEq(S, SL, NAT, R) = none [owise] .

    op applyRule : State StateList Nat Qid -> Edges .
   ceq applyRule(S, SL, NAT, R) = rlEdge( applResult(R, getContext(Result), getSubstitution(Result))
                                        , mkProofHint(downTerm(getTerm(Result), < error >), SL, NAT)
                                        )
    if Result := metaXapply(myModule, upTerm(S), R, none, 0, unbounded, 0) .
    eq applyRule(S, SL, NAT, R) = none [owise] .

    vars Alpha Alpha1 Alpha2 : Pattern .
    vars Beta  Beta1  Beta2  : Pattern .
    vars A B A1 A2 : Letter .


    *** Proof hint generation ************************************************
    --- As a first step to producing a metamath proof,
    --- we convert the generated metaSearchTree into a term that will
    --- be a precursor to both the fixedpoint used for proving the equality
    --- as well as for the final metamath proof term.
    --- This will (eventually) include the edges corresponding
    --- the various simpl rules as well as those corresponding to
    --- taking the derivative.

    --- Currently we will ignore Contexts and Substitutions,
    --- but we will eventually need to convert them into metamath proof terms.

    op getRegExp : State -> Pattern .
    eq getRegExp(< Alpha >) = Alpha .
    eq getRegExp(check-ewp[ Alpha ]) = Alpha .
    eq getRegExp(< id >) = epsilon -> epsilon .

    op ruleLabelToLetter : Qid -> Pattern .
    eq ruleLabelToLetter('check-ewp) = epsilon .
    eq ruleLabelToLetter('der-a) = a .
    eq ruleLabelToLetter('der-b) = b .

    op proofHint : Pattern -> Node .
    eq proofHint(Alpha) = mkProofHint(< Alpha >, empty, 6) .

    *** Mapping EREs to its Matching Logic signature *************************
    --- We may consider desugaring the constructors via the notation defined
    --- in some other module. But I'm not sure it will be necessary.

    --- Generate a fresh set variable for each regexp.
    op F : Pattern -> SVar .
    eq F(Alpha) = sVar (qid(str(Alpha))) .

    op str : Pattern -> String .
    eq str(bot) = "z" .
    eq str(a) = "a" .
    eq str(b) = "b" .
    eq str(epsilon) = "e" .
    eq str(Alpha . Beta) = "C" + str(Alpha) + str(Beta) + "D" .
    eq str(Alpha \/ Beta) = "C" + str(Alpha) + "p" + str(Beta) + "D" .
    eq str(Alpha -> Beta) = "C" + str(Alpha) + "i" + str(Beta) + "D" .
    eq str(Alpha *)      = "C" + str(Alpha) + "Dx" .
    eq str(~ Alpha)      = "nC" + str(Alpha) + "D" .

    *** fp *******************************************************************
    --- Here, we generate the fixedpoint needed for our proof.

    op fp : Node -> Pattern .
    eq fp(backlink(< Alpha >)) = F(Alpha) .
    eq fp(node(< Alpha >, eqEdge(EL, N))) = fp(N) .
    eq fp(node(< Alpha >, rlEdge(applResult('check-ewp, CtxEWP, Subst_EWP), N_EWP) ;
                          rlEdge(applResult('der-a,     Ctx_A, Subst_A), N_A) ;
                          rlEdge(applResult('der-b,     Ctx_B, Subst_B), N_B)
         )    )
     = mu qid(str(Alpha)) (epsilon \/ ((a . fp(N_A)) \/ (b . fp(N_B)))) [owise] .

    *** top-implies-fp ************************************************************

    *** main-goal ************************************************************
    --- Here, we the proof for (fp -> Alpha) .

    sort MetaMathProof .

    op id : -> MetaMathProof .
    --- The Qids corresponding to equational rules are all theorems.
    subsort Qid < MetaMathProof .
    vars MMP : MetaMathProof .

    op cong-thm : Qid -> Qid .
    eq cong-thm('_->_) = 'imp .
    eq cong-thm('_\/_) = 'or .
    eq cong-thm('_/\_) = 'and .
    eq cong-thm('_._) = 'concat .
    eq cong-thm('~_) = 'not .

    op eq-thm : Substitution Qid -> Qid .
    eq eq-thm('A:Letter <- Q ; Subst , R) = qid(string(R) + "-wrt-" + string(getName(Q))) .
    eq eq-thm(          Subst , R) = R [owise] .


    op apply-subst _ _ : Pattern MetaMathProof -> MetaMathProof  .
    eq apply-subst (mu Q Alpha) MMP = apply-subst Q Alpha MMP .
    op apply-subst _ _  _ : Qid Pattern MetaMathProof -> MetaMathProof [ctor] .

    op cong-of-equiv _ _ : Qid MetaMathProof -> MetaMathProof [ctor] .

    op lift-equality-to-context _  _ : Context MetaMathProof -> MetaMathProof .
    eq lift-equality-to-context [] MMP = MMP .

    --- special cases for state ctors
    eq lift-equality-to-context ('check-ewp`[_`][ Ctx ]) MMP = lift-equality-to-context Ctx MMP .
    eq lift-equality-to-context ('<_>[ Ctx ]) MMP = lift-equality-to-context Ctx MMP .

    eq lift-equality-to-context (Q [ Ctx ]) MMP
     = cong-of-equiv cong-thm(Q) (lift-equality-to-context Ctx MMP) .
    eq lift-equality-to-context (Q [ Ctx , T ] ) MMP
     = cong-of-equiv qid(string(cong-thm(Q)) + "-l") (lift-equality-to-context Ctx MMP) .
    eq lift-equality-to-context (Q [ T , Ctx ] ) MMP
     = cong-of-equiv qid(string(cong-thm(Q)) + "-r") (lift-equality-to-context Ctx MMP) .

    op apply-equiv _ _ : MetaMathProof MetaMathProof -> MetaMathProof [ctor] .
    op main-goal-leaf : -> MetaMathProof [ctor] .
    op main-goal-interior _ _ _ : MetaMathProof MetaMathProof MetaMathProof -> MetaMathProof [ctor] .

    op proof-main-goal : Node -> MetaMathProof .
    eq proof-main-goal(node(< id >, none)) = id .
    eq proof-main-goal(backlink(< Alpha >)) = main-goal-leaf .
    eq proof-main-goal(node(check-ewp[ Alpha ], eqEdge(applResult(R, Ctx, Subst), N))) = apply-equiv (lift-equality-to-context Ctx eq-thm(Subst, R)) proof-main-goal(N) .
    eq proof-main-goal(node(< Alpha >,          eqEdge(applResult(R, Ctx, Subst), N))) = apply-equiv (lift-equality-to-context Ctx eq-thm(Subst, R)) proof-main-goal(N) .
    eq proof-main-goal(node(< Alpha >, rlEdge(applResult('check-ewp, CtxEWP, Subst_EWP), N_EWP) ;
                                       rlEdge(applResult('der-a,     Ctx_A, Subst_A), N_A) ;
                                       rlEdge(applResult('der-b,     Ctx_B, Subst_B), N_B)
                      )    )
     = main-goal-interior
            (apply-subst fp(node(< Alpha >, rlEdge(applResult('check-ewp, CtxEWP, Subst_EWP), N_EWP) ; rlEdge(applResult('der-a,     Ctx_A, Subst_A), N_A) ; rlEdge(applResult('der-b,     Ctx_B, Subst_B), N_B) )) proof-main-goal(N_EWP)) 
            (apply-subst fp(node(< Alpha >, rlEdge(applResult('check-ewp, CtxEWP, Subst_EWP), N_EWP) ; rlEdge(applResult('der-a,     Ctx_A, Subst_A), N_A) ; rlEdge(applResult('der-b,     Ctx_B, Subst_B), N_B) )) proof-main-goal(N_A))
            (apply-subst fp(node(< Alpha >, rlEdge(applResult('check-ewp, CtxEWP, Subst_EWP), N_EWP) ; rlEdge(applResult('der-a,     Ctx_A, Subst_A), N_A) ; rlEdge(applResult('der-b,     Ctx_B, Subst_B), N_B) )) proof-main-goal(N_B))
     .

endm

--- search in ERE-THEOREMS : ((a . a)* --> ((a * . a) \/ epsilon)) =>* P:Pattern .
--- show search graph .

set print with parentheses on .
--- search  (epsilon -> (epsilon /\ (( ~ ((a . a) *)) \/ (((a *) . a) \/ epsilon)))) =>! P:Pattern .
--- show search graph .
--- reduce proofHint((a . a)* --> ((a * . a) \/ epsilon)) .
reduce fp(proofHint((a . a)* --> ((a * . a) \/ epsilon))) .
reduce proof-main-goal(proofHint((a . a)* --> ((a * . a) \/ epsilon))) .
