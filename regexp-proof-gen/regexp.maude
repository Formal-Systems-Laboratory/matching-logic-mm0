fmod PATTERN-METAMATH is
    protecting QID .
    sorts Symbol SVar EVar Pattern .
    subsorts Symbol SVar EVar < Pattern .

    *** core
    ops sVar _ : Qid -> SVar [ctor] .
    ops eVar _ : Qid -> EVar [ctor] .
    op app _ _ : Pattern Pattern -> Pattern [ctor] .
    op _ -> _  : Pattern Pattern -> Pattern [ctor] .
    op mu _ _  : Qid     Pattern -> Pattern [ctor] .
    op bot         : -> Pattern [ctor] .
    op exists _ _ : Qid Pattern -> Pattern [ctor] .

    op top : -> Pattern [ctor] .
    op _ /\ _       : Pattern Pattern -> Pattern [ctor] .
    op _ \/ _       : Pattern Pattern -> Pattern [ctor] .
    op nu _ _       : Qid Pattern     -> Pattern [ctor] .
    op forall _ _   : Qid Pattern     -> Pattern [ctor] .
    op _ <-> _       : Pattern Pattern -> Pattern [ctor] .
    op ~ _           : Pattern         -> Pattern [ctor] .

    *** ERE
    op epsilon      :                 -> Pattern [ctor] .

    --- TODO: Ideally, we'd want to be parametric over an alphabet.
    --- However, two letters are enough to encode all words.
    sort Letter .
    subsort Letter < Pattern .
    op a            :                 -> Letter [ctor] .
    op b            :                 -> Letter [ctor] .

    op _ . _        : Pattern Pattern -> Pattern [ctor] .
    op _ *          : Pattern         -> Pattern [ctor] .

    op (derivative _ _) : Pattern Pattern -> Pattern [ctor] .

    *** ERE sugar
    vars Alpha Beta Gamma : Pattern .
    --- NOT FOR INTERNAL USE.
    op _ + _        : Pattern Pattern -> Pattern .
    eq Alpha + Beta = Alpha \/ Beta .

    op _ --> _        : Pattern Pattern -> Pattern .
    eq Alpha --> Beta = (~ Alpha) \/ Beta .
endfm

mod ERE-THEOREMS is
    protecting PATTERN-METAMATH .

    vars Alpha Alpha1 Alpha2 : Pattern .
    vars Beta  Beta1  Beta2  : Pattern .
    vars Gamma : Pattern .
    vars A B A1 A2 : Letter .

    rl [eq-der-bot]     : (derivative A bot)          => bot .
    rl [eq-der-epsilon] : (derivative A epsilon)      => bot .
    rl [eq-der-same-a]  : (derivative A A)            => epsilon .
   crl [eq-der-diff-a]  : (derivative A B)            => bot if A =/= B .

    rl [eq-der-kleene]  : (derivative A Alpha *)        => (derivative A Alpha) . (Alpha *) .
    rl [eq-der-concat]  : (derivative A (Alpha . Beta)) => ((derivative A Alpha) . Beta) \/  ((epsilon /\ Alpha) . (derivative A Beta)) .
    rl [eq-der-choice]  : (derivative A (Alpha \/ Beta)) => (derivative A Alpha) \/ (derivative A Beta) .
    rl [eq-der-neg]     : (derivative A ~ Alpha)        => ~ (derivative A Alpha) .

    rl [eq-ewp-bot]     : epsilon /\ bot             => bot .
    rl [eq-ewp-epsilon] : epsilon /\ epsilon         => epsilon .
    rl [eq-ewp-a]       : epsilon /\ a               => bot .
    rl [eq-ewp-b]       : epsilon /\ b               => bot .
    rl [eq-ewp-concat]  : epsilon /\ (Alpha . Beta)  => (epsilon /\ Alpha) /\ (epsilon /\ Beta) .
    rl [eq-ewp-and]     : epsilon /\ (Alpha /\ Beta) => (epsilon /\ Alpha) /\ (epsilon /\ Beta) .
    rl [eq-ewp-choice]  : epsilon /\ (Alpha \/ Beta) => (epsilon /\ Alpha) \/ (epsilon /\ Beta) .
    rl [eq-ewp-kleene]  : epsilon /\ (Alpha *)       => epsilon .

    rl [eq-ewp-not-bot]     : epsilon /\ ~(bot)           => epsilon .
    rl [eq-ewp-not-eps]     : epsilon /\ ~(epsilon)       => bot .
    rl [eq-ewp-not-a]       : epsilon /\ ~(a)             => epsilon .
    rl [eq-ewp-not-b]       : epsilon /\ ~(b)             => epsilon .
    rl [eq-ewp-not-concat]  : epsilon /\ ~(Alpha . Beta)  => (epsilon /\ ~ Alpha) \/ (epsilon /\ ~ Beta) .
    rl [eq-ewp-not-and]     : epsilon /\ ~(Alpha /\ Beta) => (epsilon /\ ~ Alpha) \/ (epsilon /\ ~ Beta) .
    rl [eq-ewp-not-choice]  : epsilon /\ ~(Alpha \/ Beta) => (epsilon /\ ~ Alpha) /\ (epsilon /\ ~ Beta) .
    rl [eq-ewp-not-kleene]  : epsilon /\ ~(Alpha *)       => bot .
    rl [eq-ewp-not-not]     : epsilon /\ ~(~ Alpha)       => epsilon /\ Alpha .

    --- Identity and idemoptency of \/
    rl [eq-choice-unit-xxx] : Alpha \/ bot => Alpha . --- TODO: Remove when we have comm
    rl [eq-choice-unit] : bot   \/ Alpha => Alpha .
    rl [eq-choice-idem] : Alpha \/ Alpha => Alpha .
    rl [eq-choice-assoc] : (Alpha \/ Beta) \/ Gamma  => Alpha \/ (Beta \/ Gamma) .

   --- TODO: add a rule the rearrances disjuncts so that they are sorted.
   --- Make sure to remove the comm attribute.
   --- crl [eq-comm] : Alpha \/ Beta => Beta \/ Alpha if Alpha < Beta .
   --- Following that, add it to the list of equations in applyAnyEquation.

    ---- Optional simplifications
    rl [eq-bot-concat-l] : bot . Alpha => bot .
    rl [eq-bot-concat-r] : Alpha . bot => bot .

    rl [eq-eps-concat-l] : epsilon . Alpha => Alpha .
    rl [eq-eps-concat-r] : Alpha . epsilon => Alpha .

    rl [eq-double-neg] : ~ ~ Alpha => Alpha .
    rl [eq-double-kleene] : Alpha * * => Alpha .

    rl [eq-eps-kleene] : epsilon * => epsilon .
    rl [eq-bot-kleene] : bot * => epsilon .


    *** Rules *********************************
    *******************************************

    sort State .
    op < _ > : Pattern -> State [ctor] .
    op < invalid > : -> State [ctor] .

    eq < bot > = < invalid > . --- This should never be reached.
    rl [der-a]     : < Alpha > => < (derivative a Alpha) > .
    rl [der-b]     : < Alpha > => < (derivative b Alpha) > .
    rl [check-ewp] : < Alpha > => check-ewp[ epsilon -> (epsilon /\ Alpha) ] .

    --- We don't want the derivative rules to apply when checking EWS.
    op check-ewp[ _ ] : Pattern -> State [ctor] .
    op < id > : -> State [ctor] .
    eq check-ewp[ epsilon -> epsilon ] = < id > .
endm

--- Manually performs a search, and returns the search graph as a tree with backlinks.
mod PROOF-GEN is
    extending ERE-THEOREMS .
    protecting META-LEVEL .
    protecting NAT .

    sorts Edge NeEdges Edges Node EdgeLabel .
    subsorts Edge < NeEdges < Edges .
    op none : -> Edges [ctor] .
    op eqEdge : EdgeLabel Node -> Edge [ctor] .
    op rlEdge : EdgeLabel Node -> Edge [ctor] .
    op _ ; _ : NeEdges NeEdges -> NeEdges [ctor assoc comm id: none] .
    op _ ; _ : Edges Edges -> Edges [ditto] .

    op applResult : Qid Context Substitution -> EdgeLabel [ctor] .

    op node : State Edges -> Node [ctor] .
    op backlink : State -> Node [ctor] .
    op depthReached : State -> Node [ctor] .

    var NAT : Nat .
    vars Es : NeEdges . vars Es? : Edges .
    vars T : Term . vars TL TL' : TermList .
    vars P : Pattern .
    vars S : State . vars SL SL' : StateList .
    vars R Q : Qid . vars Result : Result4Tuple .
    vars Es1 Es2 : NeEdges .
    vars EL : EdgeLabel .
    vars N N_EWP N_A N_B : Node .
    vars Subst Subst_EWP Subst_A Subst_B : Substitution .
    vars Ctx CtxEWP Ctx_A Ctx_B : Context .

    sorts NeStateList StateList .
    subsort State < NeStateList < StateList .

    op empty : -> StateList [ctor] .
    op _,_ : NeStateList StateList -> NeStateList [ctor assoc id: empty gather (e E) prec 121] . --- Same as TermList
    op _,_ : StateList NeStateList -> NeStateList [ctor ditto] .
    op _,_ : StateList StateList -> StateList [ctor ditto] .

    op _ in _ : State StateList -> Bool .
    eq S in (SL , S , SL') = true .
    eq S in SL = false [owise] .

   --- curr term, previous terms, depth
    op mkProofHint : State StateList Nat -> Node .
   ceq mkProofHint(S, SL, NAT) = backlink(S)                              if      S in SL .
   ceq mkProofHint(S, SL, NAT) = node(S, applyAnyEquation(S, SL, NAT))      if (not S in SL) /\ Es := applyAnyEquation(S, SL, NAT) .
   ceq mkProofHint(S, SL, s(NAT)) = node(S, applyAllRules(S, (SL, S), NAT)) if (not S in SL) /\ none = applyAnyEquation(S, SL, NAT) .
   ceq mkProofHint(S, SL, 0) = depthReached(S)                          if (not S in SL) /\ none = applyAnyEquation(S, SL, 0) .

    op applyAnyEquation : State StateList Nat -> Edges .
    eq applyAnyEquation(S, SL, NAT) =
        applyEq(S, SL, NAT, 'eq-der-bot) or-else
        applyEq(S, SL, NAT, 'eq-der-epsilon) or-else
        applyEq(S, SL, NAT, 'eq-der-same-a) or-else
        applyEq(S, SL, NAT, 'eq-der-diff-a) or-else
        applyEq(S, SL, NAT, 'eq-der-kleene) or-else
        applyEq(S, SL, NAT, 'eq-der-concat) or-else
        applyEq(S, SL, NAT, 'eq-der-choice) or-else
        applyEq(S, SL, NAT, 'eq-der-neg) or-else
        applyEq(S, SL, NAT, 'eq-ewp-bot) or-else
        applyEq(S, SL, NAT, 'eq-ewp-epsilon) or-else
        applyEq(S, SL, NAT, 'eq-ewp-a) or-else
        applyEq(S, SL, NAT, 'eq-ewp-b) or-else
        applyEq(S, SL, NAT, 'eq-ewp-concat) or-else
        applyEq(S, SL, NAT, 'eq-ewp-and) or-else
        applyEq(S, SL, NAT, 'eq-ewp-choice) or-else
        applyEq(S, SL, NAT, 'eq-ewp-kleene) or-else
        applyEq(S, SL, NAT, 'eq-ewp-not-bot) or-else
        applyEq(S, SL, NAT, 'eq-ewp-not-eps) or-else
        applyEq(S, SL, NAT, 'eq-ewp-not-a) or-else
        applyEq(S, SL, NAT, 'eq-ewp-not-b) or-else
        applyEq(S, SL, NAT, 'eq-ewp-not-concat) or-else
        applyEq(S, SL, NAT, 'eq-ewp-not-and) or-else
        applyEq(S, SL, NAT, 'eq-ewp-not-choice) or-else
        applyEq(S, SL, NAT, 'eq-ewp-not-kleene) or-else
        applyEq(S, SL, NAT, 'eq-ewp-not-not) or-else

        applyEq(S, SL, NAT, 'eq-choice-unit-xxx) or-else
        applyEq(S, SL, NAT, 'eq-choice-unit) or-else
        applyEq(S, SL, NAT, 'eq-choice-idem) or-else
        applyEq(S, SL, NAT, 'eq-choice-assoc) or-else
        --- applyEq(S, SL, NAT, 'eq-comm) or-else

        applyEq(S, SL, NAT, 'eq-bot-concat-l) or-else
        applyEq(S, SL, NAT, 'eq-bot-concat-r) or-else
        applyEq(S, SL, NAT, 'eq-eps-concat-l) or-else
        applyEq(S, SL, NAT, 'eq-eps-concat-r) or-else
        applyEq(S, SL, NAT, 'eq-double-neg) or-else
        applyEq(S, SL, NAT, 'eq-double-kleene) or-else
        applyEq(S, SL, NAT, 'eq-eps-kleene) or-else
        applyEq(S, SL, NAT, 'eq-bot-kleene)
        .

    --- The strat attribute is needed to get decent preformance.
    --- Otherwise, it would compute all possible outward edges and throw all but one away,
    --- leading to exponential complexity.
    op _ or-else _ : Edges Edges -> Edges [strat (1 0) gather (e E)] .
    eq E:Edge or-else Es:Edges = E:Edge .
    eq none or-else Es? = Es? .

    op applyAllRules : State StateList Nat -> Edges .
    eq applyAllRules(S, SL, NAT) =
        applyRule(S, SL, NAT, 'check-ewp) ;
        applyRule(S, SL, NAT, 'der-a) ;
        applyRule(S, SL, NAT, 'der-b) .

    op myModule : -> Module .
    eq myModule = upModule('ERE-THEOREMS, false) .

    op < error > : -> [State] .

    op applyEq : State StateList Nat Qid -> Edges .
   ceq applyEq(S, SL, NAT, R) = eqEdge( applResult(R, getContext(Result), getSubstitution(Result))
                                      , mkProofHint(downTerm(getTerm(Result), < error >), SL, NAT)
                                      )
    if Result := metaXapply(myModule, upTerm(S), R, none, 0, unbounded, 0) .
    eq applyEq(S, SL, NAT, R) = none [owise] .

    op applyRule : State StateList Nat Qid -> Edges .
   ceq applyRule(S, SL, NAT, R) = rlEdge( applResult(R, getContext(Result), getSubstitution(Result))
                                        , mkProofHint(downTerm(getTerm(Result), < error >), (S, SL), NAT)
                                        )
    if Result := metaXapply(myModule, upTerm(S), R, none, 0, unbounded, 0) .
    eq applyRule(S, SL, NAT, R) = none [owise] .

    vars Alpha Alpha1 Alpha2 : Pattern .
    vars Beta  Beta1  Beta2  : Pattern .
    vars A B A1 A2 : Letter .


    *** Proof hint generation ************************************************
    --- As a first step to producing a metamath proof,
    --- we convert the generated metaSearchTree into a term that will
    --- be a precursor to both the fixedpoint used for proving the equality
    --- as well as for the final metamath proof term.
    --- This will (eventually) include the edges corresponding
    --- the various simpl rules as well as those corresponding to
    --- taking the derivative.

    --- Currently we will ignore Contexts and Substitutions,
    --- but we will eventually need to convert them into metamath proof terms.

    op getRegExp : State -> Pattern .
    eq getRegExp(< Alpha >) = Alpha .
    eq getRegExp(check-ewp[ Alpha ]) = Alpha .
    eq getRegExp(< id >) = epsilon -> epsilon .

    op ruleLabelToLetter : Qid -> Pattern .
    eq ruleLabelToLetter('check-ewp) = epsilon .
    eq ruleLabelToLetter('der-a) = a .
    eq ruleLabelToLetter('der-b) = b .

    op proofHint : Pattern -> Node .
    eq proofHint(Alpha) = mkProofHint(< Alpha >, empty, 3) .

    *** Mapping EREs to its Matching Logic signature *************************
    --- We may consider desugaring the constructors via the notation defined
    --- in some other module. But I'm not sure it will be necessary.

    --- Generate a fresh set variable for each regexp.
    op F : Pattern -> SVar .
    eq F(Alpha) = sVar (qid(str(Alpha))) .

    op str : Pattern -> String .
    eq str(bot) = "z" .
    eq str(a) = "a" .
    eq str(b) = "b" .
    eq str(epsilon) = "e" .
    eq str(Alpha . Beta) = "C" + str(Alpha) + str(Alpha) + "D" .
    eq str(Alpha \/ Beta) = "C" + str(Alpha) + "p" + str(Alpha) + "D" .
    eq str(Alpha -> Beta) = "C" + str(Alpha) + "i" + str(Alpha) + "D" .
    eq str(Alpha *)      = "C" + str(Alpha) + "Dx" .
    eq str(~ Alpha)      = "nC" + str(Alpha) + "D" .

    *** fp *******************************************************************
    --- Here, we generate the fixedpoint needed for our proof.

    op fp : Node -> Pattern .
    eq fp(backlink(< Alpha >)) = F(Alpha) .
    eq fp(node(< Alpha >, eqEdge(EL, N))) = fp(N) .
    eq fp(node(< Alpha >, rlEdge(applResult('check-ewp, CtxEWP, Subst_EWP), N_EWP) ;
                          rlEdge(applResult('der-a,     Ctx_A, Subst_A), N_A) ;
                          rlEdge(applResult('der-b,     Ctx_B, Subst_B), N_B)
         )    )
     = mu qid(str(Alpha)) (epsilon \/ ((a . fp(N_A)) \/ (b . fp(N_B)))) [owise] .

    *** top-implies-fp ************************************************************

    *** main-goal ************************************************************
    --- Here, we the proof for (fp -> Alpha) .

    sort MetaMathProof .

    op id : -> MetaMathProof .
    --- The Qids corresponding to equational rules are all theorems.
    subsort Qid < MetaMathProof .
    vars MMP : MetaMathProof .

    op qid-to-cong-thm : Qid -> Qid .
    eq qid-to-cong-thm('_->_) = 'imp .
    eq qid-to-cong-thm('_\/_) = 'or .
    eq qid-to-cong-thm('_/\_) = 'and .
    eq qid-to-cong-thm('_._) = 'concat .
    eq qid-to-cong-thm('~_) = 'not .

    op apply-subst _ : MetaMathProof -> MetaMathProof [ctor] .
    op cong-of-equiv _ _ : Qid MetaMathProof -> MetaMathProof [ctor] .

    op lift-equality-to-context _  _ : Context MetaMathProof -> MetaMathProof .
    eq lift-equality-to-context [] MMP = MMP .

    --- special cases for state ctors
    eq lift-equality-to-context ('check-ewp`[_`][ Ctx ]) MMP = lift-equality-to-context Ctx MMP .
    eq lift-equality-to-context ('<_>[ Ctx ]) MMP = lift-equality-to-context Ctx MMP .

    eq lift-equality-to-context (Q [ Ctx ]) MMP
     = cong-of-equiv qid-to-cong-thm(Q) (lift-equality-to-context Ctx MMP) .
    eq lift-equality-to-context (Q [ Ctx , T ] ) MMP
     = cong-of-equiv qid-to-cong-thm(Q) (lift-equality-to-context Ctx MMP) .
    eq lift-equality-to-context (Q [ T , Ctx ] ) MMP
     = cong-of-equiv qid-to-cong-thm(Q) (lift-equality-to-context Ctx MMP) .

    op apply-equiv _ _ : MetaMathProof MetaMathProof -> MetaMathProof [ctor] .
    op main-goal-leaf : -> MetaMathProof [ctor] .
    op main-goal-interior _ _ _ : MetaMathProof MetaMathProof MetaMathProof -> MetaMathProof [ctor] .

    op proof-main-goal : Node -> MetaMathProof .
    eq proof-main-goal(node(< id >, none)) = id .
    eq proof-main-goal(backlink(< Alpha >)) = main-goal-leaf .
    eq proof-main-goal(node(check-ewp[ Alpha ], eqEdge(applResult(R, Ctx, Subst), N))) = apply-equiv (lift-equality-to-context Ctx R) proof-main-goal(N) .
    eq proof-main-goal(node(< Alpha >,          eqEdge(applResult(R, Ctx, Subst), N))) = apply-equiv (lift-equality-to-context Ctx R) proof-main-goal(N) .
    eq proof-main-goal(node(< Alpha >, rlEdge(applResult('check-ewp, CtxEWP, Subst_EWP), N_EWP) ;
                                       rlEdge(applResult('der-a,     Ctx_A, Subst_A), N_A) ;
                                       rlEdge(applResult('der-b,     Ctx_B, Subst_B), N_B)
                      )    )
     = main-goal-interior
            (apply-subst proof-main-goal(N_EWP)) 
            (apply-subst proof-main-goal(N_A))
            (apply-subst proof-main-goal(N_B)) .
endm

--- search in ERE-THEOREMS : ((a . a)* --> ((a * . a) \/ epsilon)) =>* P:Pattern .
--- show search graph .

set print with parentheses on .
--- search  (epsilon -> (epsilon /\ (( ~ ((a . a) *)) \/ (((a *) . a) \/ epsilon)))) =>! P:Pattern .
--- show search graph .
--- reduce proofHint((a . a)* --> ((a * . a) \/ epsilon)) .
reduce fp(proofHint((a . a)* --> ((a * . a) \/ epsilon))) .
reduce proof-main-goal(proofHint((a . a)* --> ((a * . a) \/ epsilon))) .
