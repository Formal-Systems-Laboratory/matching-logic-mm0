fmod PATTERN-METAMATH is
    protecting QID .
    sorts Symbol SVar EVar Pattern .
    subsorts Symbol SVar EVar < Pattern .

    *** core
    ops sVar _ : Qid -> SVar [ctor] .
    ops eVar _ : Qid -> EVar [ctor] .
    op app _ _ : Pattern Pattern -> Pattern [ctor] .
    op _ -> _  : Pattern Pattern -> Pattern [ctor] .
    op mu _ _  : Qid     Pattern -> Pattern [ctor] .
    op bot         : -> Pattern [ctor] .
    op exists _ _ : Qid Pattern -> Pattern [ctor] .

    op top : -> Pattern [ctor] .
    op _ /\ _       : Pattern Pattern -> Pattern [ctor assoc comm] .
    op _ \/ _       : Pattern Pattern -> Pattern [ctor assoc comm] .
    op nu _ _       : Qid Pattern     -> Pattern [ctor] .
    op forall _ _   : Qid Pattern     -> Pattern [ctor] .
    op _ <-> _       : Pattern Pattern -> Pattern [ctor] .
    op ~ _           : Pattern         -> Pattern [ctor] .

    *** ERE
    op epsilon      :                 -> Pattern [ctor] .

    --- TODO: Ideally, we'd want to be parametric over an alphabet.
    --- However, two letters are enough to encode all words.
    sort Letter .
    subsort Letter < Pattern .
    op a            :                 -> Letter [ctor] .
    op b            :                 -> Letter [ctor] .

    op _ . _        : Pattern Pattern -> Pattern [ctor] .
    op _ *          : Pattern         -> Pattern [ctor] .

    op (derivative _ _) : Pattern Pattern -> Pattern [ctor] .

    *** ERE sugar
    --- NOT FOR INTERNAL USE.
    vars Alpha Beta : Pattern .
    op _ + _        : Pattern Pattern -> Pattern .
    eq Alpha + Beta = Alpha \/ Beta .

    op _ --> _        : Pattern Pattern -> Pattern .
    eq Alpha --> Beta = (~ Alpha) \/ Beta .
endfm

mod ERE-THEOREMS is
    protecting PATTERN-METAMATH .

    vars Alpha Alpha1 Alpha2 : Pattern .
    vars Beta  Beta1  Beta2  : Pattern .
    vars A B A1 A2 : Letter .

    --- Identity and idemoptency of \/
    rl [eq-choice-unit] : bot   \/ Alpha => Alpha .
    rl [eq-choice-idem] : Alpha \/ Alpha => Alpha .

   --- TODO: add a rule the rearrances disjuncts so that they are sorted.
   --- Make sure to remove the comm attribute.
   --- crl [eq-comm] : Alpha \/ Beta => Beta \/ Alpha if Alpha < Beta .
   --- Following that, add it to the list of equations in applyAnyEquation.

    rl [eq-der-bot]     : (derivative A bot)          => bot .
    rl [eq-der-epsilon] : (derivative A epsilon)      => bot .
    rl [eq-der-same-a]  : (derivative A A)            => epsilon .

   --- Note: our meta rewriting doesnt support crl, but equational theorems are applied in order.
   crl [eq-der-diff-a]  : (derivative A B)            => bot if A =/= B .

    rl [eq-der-kleene]  : (derivative A Alpha *)        => (derivative A Alpha) . (Alpha *) .
    rl [eq-der-concat]  : (derivative A (Alpha . Beta)) => ((derivative A Alpha) . Beta) \/  ((epsilon /\ Alpha) . (derivative A Beta)) .
    rl [eq-der-choice]  : (derivative A (Alpha \/ Beta)) => (derivative A Alpha) \/ (derivative A Beta) .
    rl [eq-der-neg]     : (derivative A ~ Alpha)        => ~ (derivative A Alpha) .

    rl [eq-ewp-bot]     : epsilon /\ bot          => bot .
    rl [eq-ewp-epsilon] : epsilon /\ epsilon        => epsilon .
    rl [eq-ewp-a]       : epsilon /\ a              => bot .
    rl [eq-ewp-concat]  : epsilon /\ (Alpha . Beta) => (epsilon /\ Alpha) /\ (epsilon /\ Beta) .
    rl [eq-ewp-choice]  : epsilon /\ (Alpha \/ Beta) => (epsilon /\ Alpha) \/ (epsilon /\ Beta) .
    rl [eq-ewp-kleene]  : epsilon /\ (Alpha *)      => epsilon .

    rl [eq-ewp-not-bot] : epsilon /\ (~ bot)        => epsilon .
    rl [eq-ewp-not-eps] : epsilon /\ (~ epsilon)    => bot .
    rl [eq-ewp-not-not] : ~ (~ Alpha)               => Alpha .
   --- Note: Similarly, our meta rewriting doesnt support owise, but equational theorems are applied in order.
    rl [eq-ewp-not]     : epsilon /\ (~ Alpha)      => epsilon /\ ~(epsilon /\ Alpha) . --- [owise]

    ---- Optional simplifications
    rl [eq-bot-concat-l] : bot . Alpha => bot .
    rl [eq-bot-concat-r] : Alpha . bot => bot .

    rl [eq-eps-concat-l] : epsilon . Alpha => Alpha .
    rl [eq-eps-concat-r] : Alpha . epsilon => Alpha .

    rl [eq-double-neg] : ~ ~ Alpha => Alpha .
    rl [eq-double-kleene] : Alpha * * => Alpha .

    rl [eq-eps-kleene] : epsilon * => epsilon .
    rl [eq-bot-kleene] : bot * => epsilon .


    *** Rules *********************************
    *******************************************

    op hasEWP : Pattern -> Bool .
    eq hasEWP(bot)  = false .
    eq hasEWP(epsilon      )  = true  .
    eq hasEWP(A            )  = false .
    eq hasEWP(Alpha .  Beta)  = hasEWP(Alpha) and hasEWP(Beta) .
    eq hasEWP(Alpha /\ Beta)  = hasEWP(Alpha) or  hasEWP(Beta) .
    eq hasEWP(Alpha *      )  = true .
    eq hasEWP(~ Alpha      )  = not hasEWP(Alpha) .

    sort State .
    op < _ > : Pattern -> State [ctor] .
    op < invalid > : -> State [ctor] .
    op < error > : -> State [ctor] . --- Used for down term errors.

   ceq < Alpha > = < invalid > if not hasEWP(Alpha) . --- This should never be reached.
    rl [der-a] : < Alpha > => < (derivative a Alpha) > .
    rl [der-b] : < Alpha > => < (derivative b Alpha) > .
endm

--- Manually performs a search, and returns the search graph as a tree with backlinks.
fmod MY-META-SEARCH-TREE is
    protecting META-LEVEL .
    protecting NAT .

    sorts Edge NeEdges Edges Node EdgeLabel .
    subsorts Edge < NeEdges < Edges .
    op none : -> Edges [ctor] .
    op eqEdge : EdgeLabel Node -> Edge [ctor] .
    op rlEdge : EdgeLabel Node -> Edge [ctor] .
    op _ ; _ : NeEdges NeEdges -> NeEdges [ctor assoc comm id: none] .
    op _ ; _ : Edges Edges -> Edges [ditto] .

    op apply : Qid Context Substitution -> EdgeLabel [ctor] .

    op node : Term Edges -> Node [ctor] .
    op backlink : Term -> Node [ctor] .
    op depthReached : Term -> Node [ctor] .

    var N : Nat .
    vars Es : NeEdges . vars Es? : Edges .
    vars T : Term . vars TL TL' : TermList .
    vars R : Qid . vars Result : Result4Tuple .

    op _ in _ : Term TermList -> Bool .
    eq T in (TL , T , TL') = true .
    eq T in TL = false [owise] .

   --- curr term, previous terms, depth
    op myMetaSearchTree : Term TermList Nat -> Node .
   ceq myMetaSearchTree(T, TL, N) = backlink(T)                              if      T in TL .
   ceq myMetaSearchTree(T, TL, N) = node(T, applyAnyEquation(T, TL, N))      if (not T in TL) /\ Es := applyAnyEquation(T, TL, N) .
   ceq myMetaSearchTree(T, TL, s(N)) = node(T, applyAllRules(T, (TL, T), N)) if (not T in TL) /\ none = applyAnyEquation(T, TL, N) .
   ceq myMetaSearchTree(T, TL, 0) = depthReached(T)                          if (not T in TL) /\ none = applyAnyEquation(T, TL, 0) .

    op applyAnyEquation : Term TermList Nat -> Edges .
    eq applyAnyEquation(T, TL, N) =
                applyEq(T, TL, N, 'eq-choice-unit) or-else
                applyEq(T, TL, N, 'eq-choice-idem) or-else

                applyEq(T, TL, N, 'eq-der-bot) or-else
                applyEq(T, TL, N, 'eq-der-epsilon) or-else
                applyEq(T, TL, N, 'eq-der-same-a) or-else
                applyEq(T, TL, N, 'eq-der-diff-a) or-else
                applyEq(T, TL, N, 'eq-der-kleene) or-else
                applyEq(T, TL, N, 'eq-der-concat) or-else
                applyEq(T, TL, N, 'eq-der-choice) or-else
                applyEq(T, TL, N, 'eq-der-neg) or-else

                applyEq(T, TL, N, 'eq-ewp-bot) or-else
                applyEq(T, TL, N, 'eq-ewp-epsilon) or-else
                applyEq(T, TL, N, 'eq-ewp-a) or-else
                applyEq(T, TL, N, 'eq-ewp-concat) or-else
                applyEq(T, TL, N, 'eq-ewp-choice) or-else
                applyEq(T, TL, N, 'eq-ewp-kleene) or-else
                applyEq(T, TL, N, 'eq-ewp-not-bot) or-else
                applyEq(T, TL, N, 'eq-ewp-not-eps) or-else
                applyEq(T, TL, N, 'eq-ewp-not-not) or-else
                applyEq(T, TL, N, 'eq-ewp-not) or-else

                applyEq(T, TL, N, 'eq-bot-concat-l) or-else
                applyEq(T, TL, N, 'eq-bot-concat-r) or-else
                applyEq(T, TL, N, 'eq-eps-concat-l) or-else
                applyEq(T, TL, N, 'eq-eps-concat-r) or-else
                applyEq(T, TL, N, 'eq-double-neg) or-else
                applyEq(T, TL, N, 'eq-double-kleene) or-else
                applyEq(T, TL, N, 'eq-eps-kleene) or-else
                applyEq(T, TL, N, 'eq-bot-kleene)
                .

    --- The strat attribute is needed to get decent preformance.
    --- Otherwise, it would compute all possible outward edges and throw all but one away,
    --- leading to exponential complexity.
    op _ or-else _ : Edges Edges -> Edges [strat (1 0) gather (e E)] .
    eq E:Edge or-else Es:Edges = E:Edge .
    eq none or-else Es? = Es? .

    op applyAllRules : Term TermList Nat -> Edges .
    eq applyAllRules(T, TL, N) =
        applyRule(T, TL, N, 'der-a) ;
        applyRule(T, TL, N, 'der-b) .

    op myModule : -> Module .
    eq myModule = upModule('ERE-THEOREMS, false) .

    op applyEq : Term TermList Nat Qid -> Edges .
   ceq applyEq(T, TL, N, R) = eqEdge( apply(R, getContext(Result), getSubstitution(Result))
                                 , myMetaSearchTree(getTerm(Result), TL, N))
    if Result := metaXapply(myModule, T, R, none, 0, unbounded, 0) .
    eq applyEq(T, TL, N, R) = none [owise] .

    op applyRule : Term TermList Nat Qid -> Edges .
   ceq applyRule(T, TL, N, R) = rlEdge( apply(R, getContext(Result), getSubstitution(Result))
                                      , myMetaSearchTree(getTerm(Result), (TL, T), N))
    if Result := metaXapply(myModule, T, R, none, 0, unbounded, 0) .
    eq applyRule(T, TL, N, R) = none [owise] .
endfm

mod REGEX-PROOF-GENERATOR is
    protecting MY-META-SEARCH-TREE .
    protecting ERE-THEOREMS .
    extending PATTERN-METAMATH .

    vars Alpha Alpha1 Alpha2 : Pattern .
    vars Beta  Beta1  Beta2  : Pattern .
    vars A B A1 A2 : Letter .

    vars T : Term .
    vars Es Es1 Es2 : NeEdges .
    vars EL : EdgeLabel .
    vars N : Node .
    vars TL TL' : TermList .
    vars R : Qid .
    vars Subst : Substitution .
    vars Ctx : Context .


    *** Proof hint generation ************************************************
    --- As a first step to producing a metamath proof,
    --- we convert the generated metaSearchTree into a term that will
    --- be a precursor to both the fixedpoint used for proving the equality
    --- as well as for the final metamath proof term.
    --- This will (eventually) include the edges corresponding
    --- the various simpl rules as well as those corresponding to
    --- taking the derivative.

    --- Currently we will ignore Contexts and Substitutions,
    --- but we will eventually need to convert them into metamath proof terms.

    sorts ProofHint NeProofHintEdges ProofHintEdges .
    subsort NeProofHintEdges < ProofHintEdges .
    op node : Pattern ProofHintEdges -> ProofHint [ctor] .
    op depthReached : Pattern -> ProofHint [ctor] .
    op backlink : Pattern -> ProofHint [ctor] .

    op none : -> ProofHintEdges [ctor] .
    op transition : Letter ProofHint -> NeProofHintEdges [ctor] .
    op simpl : Qid ProofHint -> NeProofHintEdges [ctor] .
    op _ ; _ : NeProofHintEdges NeProofHintEdges -> NeProofHintEdges [ctor assoc comm id: none] .
    op _ ; _ : ProofHintEdges ProofHintEdges -> ProofHintEdges [ditto] .

    vars PH : ProofHint .
    vars PHE1 PHE2 : NeProofHintEdges .

    op mkProofHint : Node -> ProofHint .
    op mkProofHint : Edges -> ProofHintEdges .
    eq mkProofHint(backlink(T)) = backlink(getRegExp(downTerm(T, < error >))) .
    eq mkProofHint(node(T, Es)) = node(getRegExp(downTerm(T, < error > )), mkProofHint(Es)) .
    eq mkProofHint(depthReached(T)) = depthReached(getRegExp(downTerm(T, < error > ))) .
    eq mkProofHint(Es1 ; Es2) = mkProofHint(Es1) ; mkProofHint(Es2) .
    eq mkProofHint(rlEdge(apply(R, Ctx, Subst), N:Node)) = transition(ruleLabelToLetter(R), mkProofHint(N)) .
    eq mkProofHint(eqEdge(apply(R, Ctx, Subst), N:Node)) = simpl(R, mkProofHint(N)) .

    op getRegExp : State -> Pattern .
    eq getRegExp(< Alpha >) = Alpha .

    op ruleLabelToLetter : Qid -> Letter .
    eq ruleLabelToLetter('der-a) = a .
    eq ruleLabelToLetter('der-b) = b .
---    eq ruleLabelToLetter('der-c) = c .
---    eq ruleLabelToLetter('der-d) = d .

    op proofHint : Pattern -> ProofHint .
    eq proofHint(Alpha) = mkProofHint(myMetaSearchTree(upTerm(< Alpha >), empty, 10)) .

    *** Mapping EREs to its Matching Logic signature *************************
    --- We may consider desugaring the constructors via the notation defined
    --- in some other module. But I'm not sure it will be necessary.

    --- Generate a fresh set variable for each regexp.
    op F : Pattern -> SVar .
    eq F(Alpha) = sVar (qid(str(Alpha))) .

    op str : Pattern -> String .
    eq str(bot) = "z" .
    eq str(a) = "a" .
    eq str(b) = "b" .
    eq str(epsilon) = "e" .
    eq str(Alpha . Beta) = "C" + str(Alpha) + str(Alpha) + "D" .
    eq str(Alpha \/ Beta) = "C" + str(Alpha) + "p" + str(Alpha) + "D" .
    eq str(Alpha *)      = "C" + str(Alpha) + "Dx" .
    eq str(~ Alpha)      = "nC" + str(Alpha) + "D" .

    *** fp *******************************************************************
    --- Here, we generate the fixedpoint needed for our proof.

    op fp : ProofHint -> Pattern .
    op fp : ProofHintEdges -> Pattern .
    eq fp(backlink(Alpha)) = F(Alpha) .
    eq fp(node(Alpha, simpl(R, PH))) = fp(PH) .
    eq fp(node(Alpha, PHE1)) = mu qid(str(Alpha)) (epsilon \/ fp(PHE1)) [owise] .
    eq fp(transition(A , PH)) = A . fp(PH) .
    eq fp(PHE1 ; PHE2) = fp(PHE1) \/ fp(PHE2) .
endm

set print with parentheses on .
reduce proofHint((a . a)* --> ((a * . a) + epsilon)) .
reduce fp(proofHint((a . a)* --> ((a * . a) + epsilon))) .
