mod ERE is
    sorts Letter Epsilon RegExp .
    subsorts Epsilon Letter < RegExp .

    --- In thoery an alphabet of {0, 1} is enough to encode all words, but we
    --- will use four letters for convenience.
    op a : -> Letter [ctor] .
    op b : -> Letter [ctor] .
    op c : -> Letter [ctor] .
    op d : -> Letter [ctor] .

    op empty   :               -> RegExp [ctor] .
    op epsilon :               -> Epsilon [ctor] .
    op _ _     : RegExp RegExp -> RegExp [ctor prec 2 assoc] .
    op _ *     : RegExp        -> RegExp [ctor prec 1] .
    op _ + _   : RegExp RegExp -> RegExp [ctor prec 3 assoc comm] .
    op ~ _     : RegExp        -> RegExp [ctor prec 1] .

    vars Alpha Alpha1 Alpha2 : RegExp .
    vars Beta  Beta1  Beta2  : RegExp .
    vars A B A1 A2 : Letter .

    --- Identity and idemoptency of +
    rl [eq-choice-unit] : empty + Alpha => Alpha .
    rl [eq-choice-idem] : Alpha + Alpha => Alpha .

    op hasEWP : RegExp -> Bool .
    eq hasEWP(empty       )  = false .
    eq hasEWP(epsilon     )  = true  .
    eq hasEWP(A           )  = false .
    eq hasEWP(Alpha Beta  )  = hasEWP(Alpha) and hasEWP(Beta) .
    eq hasEWP(Alpha + Beta)  = hasEWP(Alpha) or  hasEWP(Beta) .
    eq hasEWP(Alpha *     )  = true .
    eq hasEWP(~ Alpha     )  = not hasEWP(Alpha) .

    op der(_, _) : Letter RegExp -> RegExp .
    rl [eq-der-empty]   : der(A, empty)        => empty .
    rl [eq-der-epsilon] : der(A, epsilon)      => empty .
    rl [eq-der-letter]  : der(A, B)            => if A == B then epsilon else empty fi .
    rl [eq-der-kleene]  : der(A, Alpha *)      => der(A, Alpha) (Alpha *) .
    rl [eq-der-concat]  : der(A, Alpha Beta)   => (der(A, Alpha) Beta) + if hasEWP(Alpha) then der(A, Beta) else empty fi .
    rl [eq-der-choice]  : der(A, Alpha + Beta) => der(A, Alpha) + der(A, Beta) .
    rl [eq-der-neg]     : der(A, ~ Alpha)      => ~ der(A, Alpha) .
endm

--- While, in theory, the AC and idemoptency of + is enough to make
--- the derivatives based algorithm terminate, it is far from minimal.
--- We add some additional equations to make things more well behaved.
mod ERE-SIMPLIFIED is
    including ERE .

    vars Alpha Alpha1 Alpha2 : RegExp .
    vars Beta  Beta1  Beta2  : RegExp .
    vars A B A1 A2 : Letter .

    rl [eq-empty-concat-l] : empty Alpha => empty .
    rl [eq-empty-concat-r] : Alpha empty => empty .

    rl [eq-eps-concat-l] : epsilon Alpha => Alpha .
    rl [eq-eps-concat-r] : Alpha epsilon => Alpha .

    rl [eq-double-neg] : ~ ~ Alpha => Alpha .
    rl [eq-double-kleene] : Alpha * * => Alpha .

    rl [eq-eps-kleene] : epsilon * => epsilon .
    rl [eq-empty-kleene] : empty * => epsilon .
endm

--- reduce der( a , ( (c *) a ) + (((c c + c)*) b)) .
--- reduce der( b , ( (c *) a ) + (((c c + c)*) b)) .
--- reduce der( c , ( (c *) a ) + (((c c + c)*) b)) .
--- reduce der( d , ( (c *) a ) + (((c c + c)*) b)) .
--- reduce hasEWP(( (c *) a ) + (((c c + c)*) b)) .
---
--- reduce der(a, empty *) .
--- reduce der(a, epsilon *) .
--- reduce der(a, empty) .
--- reduce der(a, empty * *) .
--- reduce der(a, epsilon * *) .
--- reduce der(a, a * *) .

mod ERE-VALIDITY is
    protecting ERE-SIMPLIFIED .

    vars Alpha Alpha1 Alpha2 : RegExp .
    vars Beta  Beta1  Beta2  : RegExp .
    vars A B A1 A2 : Letter .

    --- For convenienct checking of equality.
    op _ <--> _ : RegExp RegExp -> RegExp .
    op _ & _ : RegExp RegExp -> RegExp .
    op _ --> _ : RegExp RegExp -> RegExp .
    --- TODO: We use double dashes to avoid clash with Pattern implication, though we want them to parse to the same thing.
    eq Alpha <--> Beta = ( Alpha --> Beta ) & ( Beta --> Alpha ) .
    eq Alpha --> Beta = (~ Alpha) + Beta .
    eq Alpha & Beta = ~( ( ~ Alpha ) + ( ~ Beta ) ) .

    sort State .
    op < _ > : RegExp -> State [ctor] .
    op < invalid > : -> State [ctor] .
    op < error > : -> State [ctor] . --- Used for down term errors.

   ceq < Alpha > = < invalid > if not hasEWP(Alpha) .
    rl [der-a] : < Alpha > => < der(a, Alpha) > .
    rl [der-b] : < Alpha > => < der(b, Alpha) > .
    rl [der-c] : < Alpha > => < der(c, Alpha) > .
    rl [der-d] : < Alpha > => < der(d, Alpha) > .
endm

--- search ((c)* b) =>* R:RegExp .
--- show path 3 .

--- reduce der(b,(c)* b) .

--- search < ((c)* b) > =>* < invalid > .
--- search [, 1000] < (((c c + c)*) b) <--> (((c c c + c)*) b) > =>* < invalid > . --- valid
--- search [, 1000] < (((c c + c)*) b) <--> (((c c + c)*) b) > =>* < invalid >   . --- valid
--- search [, 1000] < (((c c + c)*) b) <--> (((c c + c)*) a) > =>* < invalid >   . --- invalid
--- search [, 1000] < (((c c + c)*) c) -> (((c c + c)*) ) > =>* < invalid > . --- valid
--- search [, 1000] < (((c c + c)*) c) <--> (((c c + c)*) c) > =>* < invalid > . --- valid
--- search [, 1000] < (((c c c + c)*) c) <--> (((c c c + c)*) c) > =>* < invalid > . --- valid
--- search [, 1000] < (((c c + c)*) c) <--> (((c c c + c)*) c) > =>* < invalid >  . --- valid
--- search [, 1000] < (a b)* a <--> a (b a)* > =>* < invalid >  . --- valid

--- Manually performs a search, and returns the search graph as a tree with backlinks.

fmod MY-META-SEARCH-TREE is
    protecting META-LEVEL .

    sorts Edge NeEdges Edges Node EdgeLabel .
    subsorts Edge < NeEdges < Edges .

    *** Constructors.
    op none : -> Edges [ctor] .
    op eqEdge : EdgeLabel Node -> Edge [ctor] .
    op rlEdge : EdgeLabel Node -> Edge [ctor] .
    op _ ; _ : NeEdges NeEdges -> NeEdges [ctor assoc comm id: none] .
    op _ ; _ : Edges Edges -> Edges [ditto] .

    op apply : Qid Context Substitution -> EdgeLabel [ctor] .

    op node : Term Edges -> Node [ctor] .
    op backlink : Term -> Node [ctor] .

    vars T : Term .
    vars TL TL' : TermList .
    vars R : Qid .
    vars Result : Result4Tuple .
    vars Es : NeEdges .
    vars Es? : Edges .

    op _ in _ : Term TermList -> Bool .
    eq T in (TL , T , TL') = true .
    eq T in TL = false [owise] .

    op myMetaSearchTree : Term TermList -> Node .
   ceq myMetaSearchTree(T, TL) = backlink(T)
    if     T in TL
     .
   ceq myMetaSearchTree(T, TL) = node(T, applyAnyEquation(T, TL))
    if    (not T in TL)
       /\ Es := applyAnyEquation(T, TL)
     .
   ceq myMetaSearchTree(T, TL) = node(T, applyAllRules(T, (TL, T)))
    if    (not T in TL)
       /\ none = applyAnyEquation(T, TL)
     .

    op applyAnyEquation : Term TermList -> Edges .
    eq applyAnyEquation(T, TL) =
                applyEq(T, TL, 'eq-der-empty) or-else
                applyEq(T, TL, 'eq-der-epsilon) or-else
                applyEq(T, TL, 'eq-der-letter) or-else
                applyEq(T, TL, 'eq-der-kleene) or-else
                applyEq(T, TL, 'eq-der-concat) or-else
                applyEq(T, TL, 'eq-der-choice) or-else
                applyEq(T, TL, 'eq-der-neg) or-else
                applyEq(T, TL, 'eq-choice-unit) or-else
                applyEq(T, TL, 'eq-choice-idem) or-else
                applyEq(T, TL, 'eq-empty-concat-l) or-else
                applyEq(T, TL, 'eq-empty-concat-r) or-else
                applyEq(T, TL, 'eq-eps-concat-l) or-else
                applyEq(T, TL, 'eq-eps-concat-r) or-else
                applyEq(T, TL, 'eq-double-neg) or-else
                applyEq(T, TL, 'eq-double-kleene) or-else
                applyEq(T, TL, 'eq-eps-kleene) or-else
                applyEq(T, TL, 'eq-empty-kleene)
                .

    --- The strat attribute is needed to get decent preformance.
    --- Otherwise, it would compute all possible outward edges and throw all but one away,
    --- leading to exponential complexity.
    op _ or-else _ : Edges Edges -> Edges [strat (1 0) gather (e E)] .
    eq E:Edge or-else Es:Edges = E:Edge .
    eq none or-else Es? = Es? .

    op applyAllRules : Term TermList -> Edges .
    eq applyAllRules(T, TL) =
        applyRule(T, TL, 'der-a) ;
        applyRule(T, TL, 'der-b) ;
        applyRule(T, TL, 'der-c) ;
        applyRule(T, TL, 'der-d) .

    op myModule : -> Module .
    eq myModule = upModule('ERE-VALIDITY, false) .

    op applyEq : Term TermList Qid -> Edges .
   ceq applyEq(T, TL, R) = eqEdge( apply(R, getContext(Result), getSubstitution(Result))
                                 , myMetaSearchTree(getTerm(Result), TL))
    if Result := metaXapply(myModule, T, R, none, 0, unbounded, 0) .
    eq applyEq(T, TL, R) = none [owise] .


    op applyRule : Term TermList Qid -> Edges .
   ceq applyRule(T, TL, R) = rlEdge( apply(R, getContext(Result), getSubstitution(Result))
                                   , myMetaSearchTree(getTerm(Result), (TL, T)))
    if Result := metaXapply(myModule, T, R, none, 0, unbounded, 0) .
    eq applyRule(T, TL, R) = none [owise] .
endfm

fmod PATTERN is
    sorts Symbol SVar EVar Pattern .
    subsorts Symbol SVar EVar < Pattern .

    *** core
    ops X Y Z : -> SVar [ctor] .
    ops x y z : -> EVar [ctor] .
    op app(_ _) : Pattern Pattern -> Pattern [ctor] .
    op _ -> _ : Pattern Pattern -> Pattern [ctor] .
    op mu _ . _ : SVar Pattern -> Pattern [ctor] .
    op bottom : -> Pattern [ctor] .
    op exists _ . _ : EVar Pattern -> Pattern [ctor] .

    *** sugar
    op top : -> Pattern [ctor] .
    op _ /\ _ : Pattern Pattern -> Pattern [ctor] .
    op _ \/ _ : Pattern Pattern -> Pattern [ctor] .
    op nu _ . _ : SVar Pattern -> Pattern [ctor] .
    op forall _ . _ : EVar Pattern -> Pattern [ctor] .
endfm

mod REGEX-PROOF-GENERATOR is
    protecting MY-META-SEARCH-TREE .
    protecting ERE-VALIDITY .
    extending PATTERN .

    vars Alpha Alpha1 Alpha2 : RegExp .
    vars Beta  Beta1  Beta2  : RegExp .
    vars A B A1 A2 : Letter .

    vars T : Term .
    vars Es Es1 Es2 : NeEdges .
    vars EL : EdgeLabel .
    vars N : Node .
    vars TL TL' : TermList .
    vars R : Qid .
    vars Subst : Substitution .
    vars Ctx : Context .


    *** Proof hint generation ************************************************
    --- As a first step to producing a metamath proof,
    --- we convert the generated metaSearchTree into a term that will
    --- be a precursor to both the fixedpoint used for proving the equality
    --- as well as for the final metamath proof term.
    --- This will (eventually) include the edges corresponding
    --- the various simpl rules as well as those corresponding to
    --- taking the derivative.

    --- Currently we will ignore Contexts and Substitutions,
    --- but we will eventually need to convert them into metamath proof terms.

    sorts ProofHint NeProofHintEdges ProofHintEdges .
    subsort NeProofHintEdges < ProofHintEdges .
    op node : RegExp ProofHintEdges -> ProofHint [ctor] .
    op backlink : RegExp -> ProofHint [ctor] .

    op none : -> ProofHintEdges [ctor] .
    op transition : Letter ProofHint -> NeProofHintEdges [ctor] .
    op simpl : Qid ProofHint -> NeProofHintEdges [ctor] .
    op _ ; _ : NeProofHintEdges NeProofHintEdges -> NeProofHintEdges [ctor assoc comm id: none] .
    op _ ; _ : ProofHintEdges ProofHintEdges -> ProofHintEdges [ditto] .

    vars PH : ProofHint .
    vars PHE1 PHE2 : NeProofHintEdges .

    op mkProofHint : Node -> ProofHint .
    op mkProofHint : Edges -> ProofHintEdges .
    eq mkProofHint(backlink(T)) = backlink(getRegExp(downTerm(T, < error >))) .
    eq mkProofHint(node(T, Es)) = node(getRegExp(downTerm(T, < error > )), mkProofHint(Es)) .
    eq mkProofHint(Es1 ; Es2) = mkProofHint(Es1) ; mkProofHint(Es2) .
    eq mkProofHint(rlEdge(apply(R, Ctx, Subst), N:Node)) = transition(ruleLabelToLetter(R), mkProofHint(N)) .
    eq mkProofHint(eqEdge(apply(R, Ctx, Subst), N:Node)) = simpl(R, mkProofHint(N)) .

    op getRegExp : State -> RegExp .
    eq getRegExp(< Alpha >) = Alpha .

    op ruleLabelToLetter : Qid -> Letter .
    eq ruleLabelToLetter('der-a) = a .
    eq ruleLabelToLetter('der-b) = b .
    eq ruleLabelToLetter('der-c) = c .
    eq ruleLabelToLetter('der-d) = d .

    op proofHint : RegExp -> ProofHint .
    eq proofHint(Alpha) = mkProofHint(myMetaSearchTree(upTerm(< Alpha >), empty)) .

    *** Mapping EREs to its Matching Logic signature *************************
    --- We may consider desugaring the constructors via the notation defined
    --- in some other module. But I'm not sure it will be necessary.

    --- Useful subsorting / overloading
    subsort Epsilon Letter < Symbol .
    subsort RegExp < Pattern .
    op _ _ : Pattern Pattern -> Pattern [prec 2 assoc] . --- concat operator

    --- Generate a fresh set variable for each regexp.
    op F : RegExp -> SVar [ctor] .

    *** fp *******************************************************************
    --- Here, we generate the fixedpoint needed for our proof.

    op fp : ProofHint -> Pattern .
    op fp : ProofHintEdges -> Pattern .
    eq fp(backlink(Alpha)) = F(Alpha) .
    eq fp(node(Alpha, simpl(R, PH))) = fp(PH) .
    eq fp(node(Alpha, PHE1)) = mu F(Alpha) . ( epsilon \/ fp(PHE1)) [owise] .
    eq fp(transition(A , PH)) = A fp(PH) .
    eq fp(PHE1 ; PHE2) = fp(PHE1) \/ fp(PHE2) .
endm

reduce proofHint((a + b + c + d)*) .
reduce fp(proofHint((a + b + c + d)*)) .
reduce fp(proofHint(~ empty)) .
reduce fp(proofHint((a b)* a <--> a (b a)*)) .
reduce fp(proofHint((a b)* a  --> a (b a)*)) .
reduce fp(proofHint((((c c + c)*) b) <--> (((c c c + c)*) b))) .
reduce fp(proofHint((((c c + c)*) b)  --> (((c c c + c)*) b))) .

