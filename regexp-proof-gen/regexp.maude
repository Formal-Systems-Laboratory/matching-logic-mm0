fmod ERE is
    sort Letter .
    sort RegExp .

    --- In thoery an alphabet of {0, 1} is enough to encode all words, but we
    --- will use four letters for convenience.
    op a : -> Letter [ctor] .
    op b : -> Letter [ctor] .
    op c : -> Letter [ctor] .
    op d : -> Letter [ctor] .
    subsort Letter < RegExp .

    op empty   :               -> RegExp [ctor] .
    op epsilon :               -> RegExp [ctor] .
    op _ _     : RegExp RegExp -> RegExp [ctor prec 2 assoc] .
    op _ *     : RegExp        -> RegExp [ctor prec 1] .
    op _ + _   : RegExp RegExp -> RegExp [ctor prec 3 assoc comm] .
    op ~ _     : RegExp        -> RegExp [ctor prec 1] .

    vars Alpha Alpha1 Alpha2 : RegExp .
    vars Beta  Beta1  Beta2  : RegExp .
    vars A B A1 A2 : Letter .

    --- Identity and idemoptency of +
    eq [eq-choice-unit] : empty + Alpha = Alpha .
    eq [eq-choice-idem] : Alpha + Alpha = Alpha .

    op hasEWP : RegExp -> Bool .
    eq hasEWP(empty       )  = false .
    eq hasEWP(epsilon     )  = true  .
    eq hasEWP(A           )  = false .
    eq hasEWP(Alpha Beta  )  = hasEWP(Alpha) and hasEWP(Beta) .
    eq hasEWP(Alpha + Beta)  = hasEWP(Alpha) or  hasEWP(Beta) .
    eq hasEWP(Alpha *     )  = true .
    eq hasEWP(~ Alpha     )  = not hasEWP(Alpha) .

    op der(_, _) : Letter RegExp -> RegExp .
    eq [eq-der-empty]   : der(A, empty)        = empty .
    eq [eq-der-epsilon] : der(A, epsilon)      = empty .
    eq [eq-der-letter]  : der(A, B)            = if A == B then epsilon else empty fi .
    eq [eq-der-kleene]  : der(A, Alpha *)      = der(A, Alpha) (Alpha *) .
    eq [eq-der-concat]  : der(A, Alpha Beta)   = (der(A, Alpha) Beta) + if hasEWP(Alpha) then der(A, Beta) else empty fi .
    eq [eq-der-choice]  : der(A, Alpha + Beta) = der(A, Alpha) + der(A, Beta) .
    eq [eq-der-neg]     : der(A, ~ Alpha)      = ~ der(A, Alpha) .
endfm

--- While, in theory, the AC and idemoptency of + is enough to make
--- the derivatives based algorithm terminate, it is far from minimal.
--- We add some additional equations to make things more well behaved.
fmod ERE-SIMPLIFIED is
    including ERE .

    vars Alpha Alpha1 Alpha2 : RegExp .
    vars Beta  Beta1  Beta2  : RegExp .
    vars A B A1 A2 : Letter .

    eq [eq-empty-concat-l] : empty Alpha = empty .
    eq [eq-empty-concat-r] : Alpha empty = empty .

    eq [eq-eps-concat-l] : epsilon Alpha = Alpha .
    eq [eq-eps-concat-r] : Alpha epsilon = Alpha .

    eq [eq-double-neg] : ~ ~ Alpha = Alpha .
    eq [eq-double-kleene] : Alpha * * = Alpha .

    eq [eq-eps-kleene] : epsilon * = epsilon .
    eq [eq-empty-kleene] : empty * = epsilon .
endfm

--- reduce der( a , ( (c *) a ) + (((c c + c)*) b)) .
--- reduce der( b , ( (c *) a ) + (((c c + c)*) b)) .
--- reduce der( c , ( (c *) a ) + (((c c + c)*) b)) .
--- reduce der( d , ( (c *) a ) + (((c c + c)*) b)) .
--- reduce hasEWP(( (c *) a ) + (((c c + c)*) b)) .
---
--- reduce der(a, empty *) .
--- reduce der(a, epsilon *) .
--- reduce der(a, empty) .
--- reduce der(a, empty * *) .
--- reduce der(a, epsilon * *) .
--- reduce der(a, a * *) .

mod ERE-VALIDITY is
    protecting ERE-SIMPLIFIED .

    vars Alpha Alpha1 Alpha2 : RegExp .
    vars Beta  Beta1  Beta2  : RegExp .
    vars A B A1 A2 : Letter .

    --- For convenienct checking of equality.
    op _ <-> _ : RegExp RegExp -> RegExp .
    op _ & _ : RegExp RegExp -> RegExp .
    op _ -> _ : RegExp RegExp -> RegExp .
    eq Alpha <-> Beta = ( Alpha -> Beta ) & ( Beta -> Alpha ) .
    eq Alpha -> Beta = (~ Alpha) + Beta .
    eq Alpha & Beta = ~( ( ~ Alpha ) + ( ~ Beta ) ) .

    sort State .
    op < _ > : RegExp -> State [ctor] .
    op < invalid > : -> State [ctor] .

   ceq < Alpha > = < invalid > if not hasEWP(Alpha) .
    rl [der-a] : < Alpha > => < der(a, Alpha) > .
    rl [der-b] : < Alpha > => < der(b, Alpha) > .
    rl [der-c] : < Alpha > => < der(c, Alpha) > .
    rl [der-d] : < Alpha > => < der(d, Alpha) > .
endm

--- search ((c)* b) =>* R:RegExp .
--- show path 3 .

--- reduce der(b,(c)* b) .

--- search < ((c)* b) > =>* < invalid > .
--- search [, 1000] < (((c c + c)*) b) <-> (((c c c + c)*) b) > =>* < invalid > . --- valid
--- search [, 1000] < (((c c + c)*) b) <-> (((c c + c)*) b) > =>* < invalid >   . --- valid
--- search [, 1000] < (((c c + c)*) b) <-> (((c c + c)*) a) > =>* < invalid >   . --- invalid
--- search [, 1000] < (((c c + c)*) c) -> (((c c + c)*) ) > =>* < invalid > . --- valid
--- search [, 1000] < (((c c + c)*) c) <-> (((c c + c)*) c) > =>* < invalid > . --- valid
--- search [, 1000] < (((c c c + c)*) c) <-> (((c c c + c)*) c) > =>* < invalid > . --- valid
--- search [, 1000] < (((c c + c)*) c) <-> (((c c c + c)*) c) > =>* < invalid >  . --- valid
--- search [, 1000] < (a b)* a <-> a (b a)* > =>* < invalid >  . --- valid

--- Manually performs a search, and returns the search graph as a tree with backlinks.

fmod MY-META-SEARCH-TREE is
    protecting META-LEVEL .

    sorts NeEdges Edges Node EdgeLabel .
    subsorts NeEdges < Edges .

    *** Constructors.
    op none : -> Edges [ctor] .
    op eqEdge : EdgeLabel Node -> NeEdges [ctor] .
    op rlEdge : EdgeLabel Node -> NeEdges [ctor] .
    op _ ; _ : NeEdges NeEdges -> NeEdges [ctor assoc comm id: none] .
    op _ ; _ : Edges Edges -> Edges [ditto] .

    op apply : Qid Context Substitution -> EdgeLabel [ctor] .

    op node : Term Edges -> Node [ctor] .
    op backlink : Term -> Node [ctor] .

    vars T : Term .
    vars TL TL' : TermList .
    vars R : Qid .
    vars Result : Result4Tuple .

    op _ in _ : Term TermList -> Bool .
    eq T in (TL , T , TL') = true .
    eq T in TL = false [owise] .

    op myMetaSearchTree : Term TermList -> Node .
   ceq myMetaSearchTree(T, TL) = backlink(T)
    if     T in TL
     .
---   ceq myMetaSearchTree(T, TL) = node(T, eqEdge(Result, TL))
---    if     (not T in TL)
---       and Result:ApplictionResult := applyEquation(TL)
---     .
   ceq myMetaSearchTree(T, TL) = node(T, applyAllRules(T, (TL, T)))
    if     (not T in TL)
---       and (not Result:ApplictionResult := applyEquation(T))
     .

    op applyAllRules : Term TermList -> Edges .
    eq applyAllRules(T, TL) =
        applyRule(T, TL, 'der-a) ;
        applyRule(T, TL, 'der-b) ;
        applyRule(T, TL, 'der-c) ;
        applyRule(T, TL, 'der-d) .

    op myModule : -> Module .
    eq myModule = upModule('ERE-VALIDITY, false) .

    op applyRule : Term TermList Qid -> Edges .
   ceq applyRule(T, TL, R) = rlEdge( apply(R, getContext(Result), getSubstitution(Result))
                                   , myMetaSearchTree(getTerm(Result), (TL, T)))
    if Result := metaXapply(myModule, T, R, none, 0, unbounded, 0) .
endfm

mod DERIVATIVE-TREE is
    extending MY-META-SEARCH-TREE .
    protecting ERE-VALIDITY .

    op derivativeTree : State  -> Node .
    eq derivativeTree(S:State) = myDownMetaSearchTree(myMetaSearchTree(upTerm(S:State), empty)) .

    --- For readability, we allow object level trees.
    vars T : Term .
    vars Es Es1 Es2 : NeEdges .
    vars EL : EdgeLabel .
    vars N : Node .
    vars TL TL' : TermList .
    vars R : Qid .
    vars Subst : Substitution .
    vars Ctx : Context .

    op downFailed : -> State [ctor] .
    op enode : State Edges -> Node [ctor] .
    op ebacklink : State -> Node [ctor] .
    op apply : Qid -> EdgeLabel [ctor] .

    op myDownMetaSearchTree : Node -> Node .
    op myDownMetaSearchTree : Edges -> Edges .
    op myDownMetaSearchTree : Substitution -> Substitution .
    op myDownMetaSearchTree : Context -> Context .
    eq myDownMetaSearchTree(backlink(T)) = ebacklink(downTerm(T, downFailed)) .
    eq myDownMetaSearchTree(node(T, Es)) = enode(downTerm(T, downFailed), myDownMetaSearchTree(Es)) .

    eq myDownMetaSearchTree(Es1 ; Es2) = myDownMetaSearchTree(Es1) ; myDownMetaSearchTree(Es2) .
    eq myDownMetaSearchTree(rlEdge(apply(R, Ctx, Subst), N:Node)) = rlEdge(apply(R), myDownMetaSearchTree(N)) .
endm

reduce derivativeTree(< (a b)* a <-> a (b a)* >) .
reduce derivativeTree(< (a b)* a  -> a (b a)* >) .
reduce derivativeTree(< (((c c + c)*) b) <-> (((c c c + c)*) b) >) .
reduce derivativeTree(< (((c c + c)*) b)  -> (((c c c + c)*) b) >) .
