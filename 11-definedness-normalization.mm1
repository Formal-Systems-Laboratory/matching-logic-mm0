import "01-propositional.mm1";
import "02-ml-normalization.mm1";
import "10-theory-definedness.mm1";


--- Normalizations over various sugar
-------------------------------------

def defCtx {box: SVar}: Pattern box = $ (|^ sVar box ^|) $;
theorem defNorm {box: SVar} (phi: Pattern):
  $ Norm (app[ phi / box ] (defCtx box)) (|^ phi ^|) $ =
  '(norm_trans appCtxR @ norm_app norm_refl appCtxVar);
theorem defNorm2 {box: SVar} (phi: Pattern):
  $ Norm (app[ phi / box ] (|^ defCtx box ^|)) (|^ (|^ phi ^|) ^|) $ =
  '(norm_trans appCtxR @ norm_app norm_refl defNorm);
theorem singletonDef {x: EVar} (phi: Pattern x):
  $ ~(|^ eVar x /\ phi ^| /\ |^ eVar x /\ ~phi ^|) $ =
  '(singleton_norm (! defNorm box1) (! defNorm box2));
theorem norm_def (h: $ Norm phi psi $):
  $ Norm (|^ phi ^|) (|^ psi ^|) $ =
  '(norm_app norm_refl h);
theorem norm_mem {x: EVar} (phi1 phi2: Pattern x)
  (h: $ Norm phi1 phi2 $):
  $ Norm (x in phi1) (x in phi2) $ =
  '(norm_def @ norm_and norm_refl h);


--- High level versions of axioms
---------------------------------

theorem framing_def (h: $ phi1 -> phi2 $):
  $ |^ phi1 ^| -> |^ phi2 ^| $ =
  '(framing_norm (! defNorm box) defNorm h);

theorem propag_or_def (phi1 phi2: Pattern)
  (h: $ |^ phi1 \/ phi2 ^| $):
  $ |^ phi1 ^| \/ |^ phi2 ^| $ =
  '(norm (norm_or defNorm defNorm) @ propag_or @ norm (norm_sym (! defNorm box)) h);
