import "00-matching-logic.mm0";
import "01-propositional.mm1";


--- Normalizations over various sugar
-------------------------------------

--- not
theorem norm_not (phi phi2: Pattern)
  (h: $ Norm phi phi2 $):
  $ Norm (~phi) (~phi2) $ =
  '(norm_imp h norm_refl);
theorem norm_imp_l (phi1 phi2 psi: Pattern)
  (h: $ Norm phi1 phi2 $):
  $ Norm (phi1 -> psi) (phi2 -> psi) $ =
  '(norm_imp h norm_refl);
theorem norm_imp_r (phi psi1 psi2: Pattern)
  (h: $ Norm psi1 psi2 $):
  $ Norm (phi -> psi1) (phi -> psi2) $ =
  '(norm_imp norm_refl h);
theorem eFresh_not {x: EVar} (phi: Pattern x)
  (h: $ _eFresh x phi $):
  $ _eFresh x (~ phi) $ =
  '(eFresh_imp h eFresh_triv);
theorem eSubstitution_in_not {x: EVar} (psi phi: Pattern x):
  $ Norm (e[ psi / x ] ~phi) (~e[ psi / x ] phi) $ =
  '(norm_trans eSubstitution_in_imp @ norm_imp norm_refl eSubstitution_triv);
theorem sSubstitution_in_not {X: SVar} (psi phi: Pattern X):
  $ Norm (s[ psi / X ] ~phi) (~(s[ psi / X ] phi)) $ =
  '(norm_trans sSubstitution_in_imp @ norm_imp norm_refl sSubstitution_triv);

--- or
theorem norm_or (phi psi phi2 psi2: Pattern)
  (h1: $ Norm phi phi2 $)
  (h2: $ Norm psi psi2 $):
  $ Norm (phi \/ psi) (phi2 \/ psi2) $ =
  '(norm_imp (norm_not h1) h2);
theorem eFresh_or {x: EVar} (phi1 phi2: Pattern x)
  (h1: $ _eFresh x phi1 $)
  (h2: $ _eFresh x phi2 $):
  $ _eFresh x (phi1 \/ phi2) $ =
  '(eFresh_imp (eFresh_not h1) h2);

--- and
theorem norm_and (phi psi phi2 psi2: Pattern)
  (h1: $ Norm phi phi2 $)
  (h2: $ Norm psi psi2 $):
  $ Norm (phi /\ psi) (phi2 /\ psi2) $ =
  '(norm_not @ norm_imp h1 (norm_not h2));
theorem eFresh_and {x: EVar} (phi1 phi2: Pattern x)
  (h1: $ _eFresh x phi1 $)
  (h2: $ _eFresh x phi2 $):
  $ _eFresh x (phi1 /\ phi2) $ =
  '(eFresh_not @ eFresh_imp h1 @ eFresh_not h2);
theorem eSubstitution_in_and {x: EVar} (psi phi1 phi2: Pattern x):
  $ Norm (e[ psi / x ] (phi1 /\ phi2)) ((e[ psi / x ] phi1) /\ e[ psi / x ] phi2) $ =
  '(norm_trans eSubstitution_in_not @ norm_not @ norm_trans eSubstitution_in_imp @ norm_imp_r eSubstitution_in_not);


--- High level versions of axioms
---------------------------------

theorem exists_generalization_strict {x: EVar} (phi1: Pattern x) (phi2: Pattern)
  (h: $ phi1 -> phi2 $):
  $ (exists x phi1) -> phi2 $ =
  '(exists_generalization eFresh_triv h);
theorem propag_exists_strict {box: SVar} {x: EVar} (ctx: Pattern box) (phi: Pattern x):
  $ app[ exists x phi / box ] ctx -> exists x (app[ phi / box ] ctx) $ =
  '(propag_exists eFresh_triv);

theorem exists_framing {x: EVar} (phi1 phi2: Pattern x)
  (h: $ phi1 -> phi2 $):
  $ (exists x phi1) -> exists x phi2 $ =
  '(exists_generalization eFresh_exists_same_var @ syl exists_intro_same_var h);

theorem or_exists {x: EVar} (phi1: Pattern) (phi2: Pattern x):
  $ (phi1 \/ exists x phi2) <-> exists x (phi1 \/ phi2) $ =
  '(ibii
    (eori
      (syl exists_intro_same_var orl)
      (exists_generalization eFresh_exists_same_var @ syl exists_intro_same_var orr))
    (exists_generalization (eFresh_or eFresh_triv eFresh_exists_same_var) @ eori orl @ orrd exists_intro_same_var));

theorem imp_exists {x: EVar} (phi1: Pattern) (phi2: Pattern x):
  $ (phi1 -> exists x phi2) <-> exists x (phi1 -> phi2) $ =
  '(ibii
    (rsyl (imim1 dne) @ rsyl (anl or_exists) @ exists_framing @ imim1 notnot1)
    (rsyl (exists_framing @ imim1 dne) @ rsyl (anr or_exists) @ imim1 notnot1));

theorem and_exists_forwards {x: EVar} (phi1: Pattern) (phi2: Pattern x):
  $ (exists x (phi1 /\ phi2)) -> (phi1 /\ exists x phi2) $ =
  '(iand
    (rsyl (exists_framing anl) (exists_generalization_strict id))
    (exists_framing anr));
theorem and_exists_reverse {x: EVar} (phi1: Pattern) (phi2: Pattern x):
  $ (phi1 /\ exists x phi2) -> (exists x (phi1 /\ phi2)) $ =
  '(impcom @ imim2 (anr imp_exists) (exists_framing ian2));
theorem and_exists {x: EVar} (phi1: Pattern) (phi2: Pattern x):
  $ (exists x (phi1 /\ phi2)) <-> (phi1 /\ exists x phi2) $ =
  '(ibii and_exists_forwards and_exists_reverse);

theorem framing_norm {box: SVar} (ctx: Pattern box) (phi1 phi2 rho1 rho2: Pattern)
  (h1: $ Norm (app[ phi1 / box ] ctx) rho1 $)
  (h2: $ Norm (app[ phi2 / box ] ctx) rho2 $)
  (h3: $ phi1 -> phi2 $):
  $ rho1 -> rho2 $ = '(norm (norm_imp h1 h2) @ framing h3);
theorem singleton_norm {box1 box2: SVar} {x: EVar}
  (ctx1 rho1: Pattern box1 x) (ctx2 rho2: Pattern box2 x)
  (phi: Pattern x)
  (h1: $ Norm (app[ (eVar x) /\ phi / box1 ] ctx1) rho1 $)
  (h2: $ Norm (app[ (eVar x) /\ ~phi / box2 ] ctx2) rho2 $):
  $ ~(rho1 /\ rho2) $ =
  '(norm (norm_not @ norm_and h1 h2) singleton);



-- propagation of eSubst
do {
  -- appCtx
      -- ['bot       (error "application context is invalid")]
      -- [('sym S)   (error "application context is invalid")]
      -- [('eVar x)  (error "application context is invalid")]
      -- [('SVar box)  'appCtxVar]
      -- [('SVar X)  (error "application context is invalid")]
      -- [('imp P1 P2) (error "application context is invalid")]

--   (def (propag_e_subst_auto refine g) @ match g @ $ Norm (e[ ,phi / ,x_o ] ,ctx_o) ,res $ @ letrec (
--     [(propag_e_subst x ctx) @ match ctx
--       [('bot)      'eSubstitution_triv]
--       [('top)      'eSubstitution_triv]
--       [('sym S)  'eSubstitution_triv]
--       [('sVar X) 'eSubstitution_triv]
--       [('eVar y) (if (== x y) 'eSubstitution_in_same_eVar 'eSubstitution_triv)]
--       [('imp phi1 phi2) '(_eSubst_imp ,(propag_e_subst x phi1) ,(propag_e_subst x phi2))]
--       [('app phi1 phi2) '(_eSubst_app ,(propag_e_subst x phi1) ,(propag_e_subst x phi2))]
--       [('exists y psi)  (if (== x y) 'eSubstitution_in_same_exists '(norm_trans eSubstitution_in_exists (norm_exists ,(propag_e_subst x psi))))]
--       [('forall y psi)  (propag_e_subst x $ not (exists y (not psi)) $)]
--       [('mu Y psi)      '(_eSubst_mu ,(propag_e_subst X psi))]
--       [('not psi)       '(_eSubst_not ,(propag_e_subst x psi))]
--       [('or phi1 phi2)  '(_eSubst_or ,(propag_e_subst x phi1) ,(propag_e_subst x phi2))]
--       [('and phi1 phi2)  '(_eSubst_and ,(propag_e_subst x phi1) ,(propag_e_subst x phi2))]
--       [('concat psi1 psi2) '(_eSubst_concat ,(propag_e_subst x psi1) ,(propag_e_subst x psi2))]
--       [('_eq psi1 psi2) '(propag_e_subst x $ not (_ceil (not (and (imp psi1 psi2) (imp psi2 psi1)))) $)]
--       [_               '(norm_refl)]
--       -- [('e[ phi2 / x] psi) '(norm_trans sSubstitution_in_eSubst_same_var (norm_trans (norm_evSubst_pt norm_id ,(propag_e_subst phi x phi2)) ,(propag_e_subst x psi)))]
--       -- [('e[ phi2 / y] psi) '()]
--       -- [('s[ phi2 / x] psi) '()]
--       -- [('app[ phi2 / box] psi) '()]
--       -- equiv forall
--     ]
--     ) @ refine g (propag_e_subst x_o ctx_o))

  (def (propag_s_subst X ctx) @ match ctx
    [$bot$     'sSubstitution_triv]
    [$top$     'sSubstitution_triv]
    [$sym ,S$  'sSubstitution_triv]
    [$eVar ,x$ 'sSubstitution_triv]
    [$sVar ,Y$ (if (== X Y) 'sSubstitution_in_same_sVar 'sSubstitution_triv)]
    [$imp ,phi1 ,phi2$    '(_sSubst_imp             ,(propag_s_subst X phi1) ,(propag_s_subst X phi2))]
    [$app ,phi1 ,phi2$    '(_sSubst_app             ,(propag_s_subst X phi1) ,(propag_s_subst X phi2))]
    [$exists ,y ,psi$     '(_sSubst_exists          ,(propag_s_subst X psi))]
    [$mu ,Y ,psi$ (if (== X Y) 
                          'sSubstitution_in_same_mu 
                          '(_sSubst_mu              ,(propag_s_subst X psi)))]
    [$not ,psi$           '(_sSubst_not             ,(propag_s_subst X psi))]
    [$or ,phi1 ,phi2$     '(_sSubst_or              ,(propag_s_subst X phi1) ,(propag_s_subst X phi2))]
    [$and ,phi1 ,phi2$    '(_sSubst_and             ,(propag_s_subst X phi1) ,(propag_s_subst X phi2))]
    [$svSubst ,Y ,psi1 ,psi2$ (if (== X Y)
                          '(_eSubst_eSubst_same_var ,(propag_s_subst X psi1) ,(propag_s_subst X psi2))
                          (error "not implemented"))]

    [$epsilon$  'sSubstitution_triv]
    [$a$        'sSubstitution_triv]
    [$b$        'sSubstitution_triv]
    [$concat ,psi1 ,psi2$ '(_sSubst_concat          ,(propag_s_subst X psi1) ,(propag_s_subst X psi2))]
    [$kleene ,Y ,psi$ (if (== X Y)
                          'sSubstitution_in_same_mu
                          '(_sSubst_mu @ _sSubst_or sSubstitution_triv @ _sSubst_concat ,(propag_s_subst X psi) sSubstitution_triv))]
    [$nnimp ,phi1 ,phi2$  '(_sSubst_nnimp           ,(propag_s_subst X phi1) ,(propag_s_subst X phi2))]
    [_  'norm_refl]
    -- [('e[ phi2 / y] psi) '()]
    -- [('s[ phi2 / X] psi) '()]
    -- [('app[ phi2 / box] psi) '()]
    -- equiv forall
  )


  (def (propag_s_subst_auto refine g) @ match g @ $ Norm (s[ ,phi_o / ,X_o ] ,ctx_o) ,res $ @ refine g (propag_s_subst X_o ctx_o))

  (def dbg @ match-fn* [(x) (print x) x]
    [(x y) (display @ string-append (->string x) ": " (->string y)) y])
};

theorem _sSubst_app {X: SVar} (phi phi1 phi2 psi1 psi2: Pattern X)
  (h1: $ Norm (s[ phi / X ] phi1) psi1 $)
  (h2: $ Norm (s[ phi / X ] phi2) psi2 $):
  $ Norm (s[ phi / X ] (app phi1 phi2)) (app psi1 psi2) $ =
  '(norm_trans sSubstitution_in_app (norm_app h1 h2));

theorem _sSubst_imp {X: SVar} (phi phi1 phi2 psi1 psi2: Pattern X)
  (h1: $ Norm (s[ phi / X ] phi1) psi1 $)
  (h2: $ Norm (s[ phi / X ] phi2) psi2 $):
  $ Norm (s[ phi / X ] (phi1 -> phi2)) (psi1 -> psi2) $ =
  '(norm_trans sSubstitution_in_imp (norm_imp h1 h2));

theorem _sSubst_mu {X Y: SVar} (psi rho: Pattern X Y) (phi: Pattern X)
  (h : $ Norm (s[ phi / X ] psi) rho $):
  $ Norm (s[ phi / X ] (mu Y psi)) (mu Y rho) $
  = '(norm_trans sSubstitution_in_mu (norm_mu h));

theorem _sSubst_not {X: SVar} (phi psi rho: Pattern X)
  (h: $ Norm (s[ phi / X ] psi) rho $):
  $ Norm (s[ phi / X ] (~ psi)) (~ rho) $ =
  '(_sSubst_imp h sSubstitution_triv);

theorem _sSubst_or {X: SVar} (phi phi1 phi2 psi1 psi2: Pattern X)
  (h1: $ Norm (s[ phi / X ] phi1) psi1 $)
  (h2: $ Norm (s[ phi / X ] phi2) psi2 $):
  $ Norm (s[ phi / X ] (phi1 \/ phi2)) (psi1 \/ psi2) $ =
  '(_sSubst_imp (_sSubst_not h1) h2);

theorem _sSubst_and {X: SVar} (phi phi1 phi2 psi1 psi2: Pattern X)
  (h1: $ Norm (s[ phi / X ] phi1) psi1 $)
  (h2: $ Norm (s[ phi / X ] phi2) psi2 $):
  $ Norm (s[ phi / X ] (phi1 /\ phi2)) (psi1 /\ psi2) $ =
  '(_sSubst_not @ _sSubst_imp h1 (_sSubst_not h2));

theorem _sSubst_exists {X: SVar} {x: EVar} (psi rho: Pattern X x) (phi: Pattern X)
  (h: $ Norm (s[ phi / X ] psi) rho $):
  $ Norm (s[ phi / X ] (exists x psi)) (exists x rho) $ =
  '(norm_trans sSubstitution_in_exists (norm_exists h));

theorem _eSubst_eSubst_same_var {X: SVar} (phi1 phi2 phi3 psi1 psi2: Pattern X)
  (h1: $ Norm (s[ psi1 / X ] phi3) psi2 $)
  (h2: $ Norm (s[ phi1 / X ] phi2) psi1 $):
  $ Norm (s[ phi1 / X ] (s[ phi2 / X ] phi3)) psi2 $ =
  '(norm_trans sSubstitution_in_sSubst_same_var @ norm_trans (norm_svSubst_pt norm_refl h2) h1);


theorem _eSubst_app {x: EVar} (phi phi1 phi2 psi1 psi2: Pattern x)
  (h1: $ Norm (e[ phi / x ] phi1) psi1 $)
  (h2: $ Norm (e[ phi / x ] phi2) psi2 $):
  $ Norm (e[ phi / x ] (app phi1 phi2)) (app psi1 psi2) $ =
  '(norm_trans eSubstitution_in_app (norm_app h1 h2));

theorem _eSubst_imp {x: EVar} (phi phi1 phi2 psi1 psi2: Pattern x)
  (h1: $ Norm (e[ phi / x ] phi1) psi1 $)
  (h2: $ Norm (e[ phi / x ] phi2) psi2 $):
  $ Norm (e[ phi / x ] (phi1 -> phi2)) (psi1 -> psi2) $ =
  '(norm_trans eSubstitution_in_imp (norm_imp h1 h2));

theorem _eSubst_mu {x: EVar} {X: SVar} (psi rho: Pattern x X) (phi: Pattern x)
  (h : $ Norm (e[ phi / x ] psi) rho $):
  $ Norm (e[ phi / x ] (mu X psi)) (mu X rho) $
  = '(norm_trans eSubstitution_in_mu (norm_mu h));

theorem _eSubst_not {x: EVar} (phi psi rho: Pattern x)
  (h: $ Norm (e[ phi / x ] psi) rho $):
  $ Norm (e[ phi / x ] (~ psi)) (~ rho) $ =
  '(_eSubst_imp h eSubstitution_triv);

theorem _eSubst_or {x: EVar} (phi phi1 phi2 psi1 psi2: Pattern x)
  (h1: $ Norm (e[ phi / x ] phi1) psi1 $)
  (h2: $ Norm (e[ phi / x ] phi2) psi2 $):
  $ Norm (e[ phi / x ] (phi1 \/ phi2)) (psi1 \/ psi2) $ =
  '(_eSubst_imp (_eSubst_not h1) h2);

theorem _eSubst_and {x: EVar} (phi phi1 phi2 psi1 psi2: Pattern x)
  (h1: $ Norm (e[ phi / x ] phi1) psi1 $)
  (h2: $ Norm (e[ phi / x ] phi2) psi2 $):
  $ Norm (e[ phi / x ] (phi1 /\ phi2)) (psi1 /\ psi2) $ =
  '(_eSubst_not @ _eSubst_imp h1 (_eSubst_not h2));


theorem example_1 {X: SVar} (phi: Pattern):
  $ Norm (s[ phi / X ] (sVar X)) phi $ =
  propag_s_subst_auto;

-- theorem example_1_e {x: EVar} (phi: Pattern):
--   $ Norm (e[ phi / x ] (eVar x)) phi $ =
--   propag_e_subst_auto;

theorem example_2 {X: SVar} (phi: Pattern):
  $ Norm (s[ phi / X ] (app bot (sVar X))) (app bot phi) $ =
  propag_s_subst_auto;

theorem example_3 {X: SVar} (phi psi: Pattern X):
  $ Norm (s[ phi / X ] (imp psi (sVar X))) (imp (s[ phi / X ] psi) phi) $ =
  propag_s_subst_auto;

theorem example_4 {X Y: SVar} (phi: Pattern):
  $ Norm (s[ phi / X ] (mu Y (sVar X))) (mu Y phi) $ =
  propag_s_subst_auto;

theorem example_5 {Y: SVar} (phi: Pattern):
  $ Norm (s[ phi / Y ] (mu Y (sVar Y))) (mu Y (sVar Y)) $ =
  propag_s_subst_auto;

theorem example_6 {X: SVar} (phi psi: Pattern X):
  $ Norm (~ (s[ phi / X ] (imp psi (sVar X)))) (~ (imp (s[ phi / X ] psi) phi)) $ =
  '(norm_not ,(propag_s_subst 'X $ (imp psi (sVar X)) $ ));