import "../sorts.mm1";

-- Atom sorts
term atoms_sym: Symbol;
def atoms: Pattern = $ sym atoms_sym $;
axiom sort_atoms: $ is_sort atoms $;

term nominal_sorts_sym: Symbol;
def nominal_sorts: Pattern = $ sym nominal_sorts_sym $;
axiom sort_nominal_sorts: $ is_sort nominal_sorts $;

axiom atoms_nominal_sorts: $ dom atoms C= dom nominal_sorts $;

term sort_abstraction_sym: Symbol;
def sort_abstraction (abs body: Pattern): Pattern = $ (sym sort_abstraction_sym) @@ abs @@ body $;
-- TODO: Check if output sort should be `sorts` or it's okay for it to be `nominal_sorts` (e,g, can we have something like `[a1] [a2] t`? The choice of `nominal_sorts` assumes yes)
axiom function_sort_abstraction: $ ,(is_function '(sym sort_abstraction_sym) '[atoms nominal_sorts] 'nominal_sorts) $;

def is_atom_sort (alpha: Pattern): Pattern = $ (is_func alpha) /\ (alpha C= dom atoms) $;
def is_nominal_sort (tau: Pattern): Pattern = $ (is_func tau) /\ (tau C= dom nominal_sorts) $;
def is_atom (a alpha: Pattern): Pattern = $ is_sorted_func alpha a $;

term swap_sym: Symbol;
def swap (a b phi: Pattern): Pattern = $ (sym swap_sym) @@ a @@ b @@ phi $;
term abstraction_sym: Symbol;
def abstraction (phi rho: Pattern): Pattern = $ (sym abstraction_sym) @@ phi @@ rho $;
term supp_sym: Symbol;
def supp (phi: Pattern): Pattern = $ (sym supp_sym) @@ phi $;
def fresh_for (phi psi: Pattern): Pattern = $ ~ (phi C= supp psi) $;

def EV_pattern {.a .b: EVar} (alpha phi: Pattern): Pattern =
$ s_forall alpha a (s_forall alpha b ((swap (eVar a) (eVar b) phi) == phi)) $;

axiom function_swap:
  $ is_atom_sort alpha $ >
  $ is_nominal_sort tau $ >
  $ ,(is_function '(sym swap_sym) '[alpha alpha tau] 'tau) $;
axiom function_swap_atom:
  $ is_atom_sort alpha $ >
  $ ,(is_function '(sym swap_sym) '[alpha alpha alpha] 'alpha) $;
axiom function_abstraction:
  $ is_atom_sort alpha $ >
  $ is_nominal_sort tau $ >
  $ ,(is_function '(sym abstraction_sym) '[alpha tau] '(sort_abstraction alpha tau)) $;
axiom multifunction_supp:
  $ is_atom_sort alpha $ >
  $ is_nominal_sort tau $ >
  $ ,(is_multi_function '(sym supp_sym) '[tau] 'alpha) $;

axiom EV_abstraction {a b: EVar} (alpha tau: Pattern) (phi psi: Pattern a b):
  $ is_atom_sort alpha $ >
  $ is_nominal_sort tau $ >
  $ s_forall alpha a (s_forall alpha b (
    (is_of_sort phi alpha) ->
    (is_of_sort psi tau) ->
    ((swap (eVar a) (eVar b) (abstraction phi psi)) == abstraction (swap (eVar a) (eVar b) phi) (swap (eVar a) (eVar b) psi)))) $;
-- add EV axiom for swap
axiom EV_supp {a b: EVar}  (tau: Pattern) (phi: Pattern a b):
  $ is_atom_sort alpha $ >
  $ is_nominal_sort tau $ >
  $ s_forall alpha a (s_forall alpha b (
    (is_of_sort phi tau) ->
    ((swap (eVar a) (eVar b) (supp phi)) == supp (swap (eVar a) (eVar b) phi)))) $;

axiom EV_pred (alpha tau: Pattern):
  $ is_atom_sort alpha $ >
  $ is_nominal_sort tau $ >
  $ EV_pattern alpha (dom tau) $;
axiom S1 (alpha tau a phi: Pattern):
  $ is_atom_sort alpha $ >
  $ is_nominal_sort tau $ >
  $ (is_atom a alpha) ->
    (is_of_sort phi tau) ->
    ((swap a a phi) == phi) $;
axiom S2 {a b: EVar} (alpha tau phi: Pattern a b):
  $ is_atom_sort alpha $ >
  $ is_nominal_sort tau $ >
  $ s_forall alpha a (
    s_forall alpha b (
    (is_of_sort phi tau) ->
    ((swap (eVar a) (eVar b) (swap (eVar a) (eVar b) phi)) == phi))) $;
axiom S3 {a b: EVar} (alpha: Pattern a b):
  $ is_atom_sort alpha $ >
  $ s_forall alpha a (
    s_forall alpha b (
    ((swap (eVar a) (eVar b) (eVar a)) == (eVar b)))) $;
axiom S4 (alpha tau a b phi: Pattern):
  $ is_atom_sort alpha $ >
  $ is_nominal_sort tau $ >
  $ (is_atom a alpha) ->
    (is_atom b alpha) ->
    (is_of_sort phi tau) ->
    ((swap a b phi) == (swap b a phi)) $;
axiom F1 (alpha tau a b phi: Pattern):
  $ is_atom_sort alpha $ >
  $ is_nominal_sort tau $ >
  $ (is_atom a alpha) ->
    (is_atom b alpha) ->
    (is_of_sort phi tau) ->
    ((fresh_for a phi) /\ (fresh_for b phi) -> ((swap a b phi) == phi)) $;
axiom F2 (alpha a b: Pattern):
  $ is_atom_sort alpha $ >
  $ (is_atom a alpha) ->
    (is_atom b alpha) ->
    ((a != b) <-> (fresh_for a b)) $;
axiom F3 (alpha1 alpha2 a b: Pattern):
  $ is_atom_sort alpha1 $ >
  $ is_atom_sort alpha2 $ >
  $ (is_atom a alpha1) ->
    (is_atom b alpha2) ->
    (alpha1 != alpha2) ->
    (a != b) $;
-- We restrict F4 to only accept singleton phi's to avoid inconsistencies
-- caused by using the full set of atoms in place of phi
axiom F4 {a: EVar} (alpha tau phi: Pattern):
  $ is_atom_sort alpha $ >
  $ is_nominal_sort tau $ >
  $ (is_sorted_func tau phi) ->
    (s_exists alpha a (fresh_for (eVar a) phi)) $;
axiom A1 (alpha tau a b phi rho: Pattern):
  $ is_atom_sort alpha $ >
  $ is_nominal_sort tau $ >
  $ (is_atom a alpha) ->
    (is_atom b alpha) ->
    (is_of_sort phi tau) ->
    (is_of_sort rho tau) ->
    (((abstraction a phi) == (abstraction b rho)) <->
    ((a == b) /\ (phi == rho)) \/
    ((fresh_for a rho) /\ ((swap a b phi) == rho))) $;
axiom A2 (alpha tau: Pattern) {x a y: EVar}:
  $ is_atom_sort alpha $ >
  $ is_nominal_sort tau $ >
  $ s_forall (sort_abstraction alpha tau) x
    (s_exists alpha a (s_exists tau y (eVar x == abstraction (eVar a) (eVar y)))) $;

def coercion (a phi: Pattern) {.y: EVar}: Pattern =
  $ exists y (eVar y /\ ((abstraction a (eVar y)) == phi)) $;
