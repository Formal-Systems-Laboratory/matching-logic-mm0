import "../sorts.mm1";

-- Atom sorts
term atoms_sym: Symbol;
def atoms: Pattern = $ sym atoms_sym $;
axiom sort_atoms: $ is_sort atoms $;

term nominal_sorts_sym: Symbol;
def nominal_sorts: Pattern = $ sym nominal_sorts_sym $;
axiom sort_nominal_sorts: $ is_sort nominal_sorts $;

axiom atoms_nominal_sorts: $ dom atoms C= dom nominal_sorts $;

term sort_abstraction_sym: Symbol;
def sort_abstraction (abs body: Pattern): Pattern = $ (sym sort_abstraction_sym) @@ abs @@ body $;
-- TODO: Check if output sort should be `sorts` or it's okay for it to be `nominal_sorts` (e,g, can we have something like `[a1] [a2] t`? The choice of `nominal_sorts` assumes yes)
axiom function_sort_abstraction: $ ,(is_function '(sym sort_abstraction_sym) '[atoms nominal_sorts] 'nominal_sorts) $;

def is_atom_sort (alpha: Pattern): Pattern = $ (is_func alpha) /\ (alpha C= dom atoms) $;
def is_nominal_sort (tau: Pattern): Pattern = $ (is_func tau) /\ (tau C= dom nominal_sorts) $;
def is_atom {a: EVar} (alpha: Pattern): Pattern a = $ is_of_sort (eVar a) alpha $;

term swap_sym: Symbol;
def swap {a b: EVar} (phi: Pattern a b): Pattern a b = $ (sym swap_sym) @@ eVar a @@ eVar b @@ phi $;
def moot_swap {a: EVar} (phi: Pattern a): Pattern a = $ (sym swap_sym) @@ eVar a @@ eVar a @@ phi $;
term abstraction_sym: Symbol;
def abstraction (phi rho: Pattern): Pattern = $ (sym abstraction_sym) @@ phi @@ rho $;
term supp_sym: Symbol;
def supp (phi: Pattern): Pattern = $ (sym supp_sym) @@ phi $;
def fresh_for (phi psi: Pattern): Pattern = $ ~ (phi C= supp psi) $;

def EV_pattern {.a .b: EVar} (alpha phi: Pattern): Pattern =
$ s_forall alpha a (s_forall alpha b ((swap a b phi) == phi)) $;

axiom function_swap:
  $ is_atom_sort alpha $ >
  $ is_nominal_sort tau $ >
  $ ,(is_function '(sym swap_sym) '[alpha alpha tau] 'tau) $;
axiom function_abstraction:
  $ is_atom_sort alpha $ >
  $ is_nominal_sort tau $ >
  $ ,(is_function '(sym abstraction_sym) '[alpha tau] '(sort_abstraction alpha tau)) $;
axiom multifunction_supp:
  $ is_atom_sort alpha $ >
  $ is_nominal_sort tau $ >
  $ ,(is_multi_function '(sym supp_sym) '[tau] 'alpha) $;

axiom EV_abstraction {a b: EVar} (alpha tau: Pattern) (phi psi: Pattern a b):
  $ is_atom_sort alpha $ >
  $ is_nominal_sort tau $ >
  $ (is_of_sort phi alpha) ->
   (is_of_sort psi tau) ->
   (s_forall alpha a (s_forall alpha b ((swap a b (abstraction phi psi)) == abstraction (swap a b phi) (swap a b psi)))) $;
  

axiom EV_pred (alpha tau: Pattern):
  $ is_atom_sort alpha $ >
  $ is_nominal_sort tau $ >
  $ EV_pattern alpha (dom tau) $;
axiom S1 (alpha tau: Pattern) {a: EVar} (phi: Pattern a):
  $ is_atom_sort alpha $ >
  $ is_nominal_sort tau $ >
  $ (is_atom a alpha) ->
    (is_of_sort phi tau) ->
    ((moot_swap a phi) == phi) $;
axiom S2 (alpha tau: Pattern) {a b: EVar} (phi: Pattern a b):
  $ is_atom_sort alpha $ >
  $ is_nominal_sort tau $ >
  $ (is_atom a alpha) ->
    (is_atom b alpha) ->
    (is_of_sort phi tau) ->
    (swap a b (swap a b phi)) == phi $;
axiom S3 (alpha: Pattern) {a b: EVar}:
  $ is_atom_sort alpha $ >
  $ (is_atom a alpha) ->
    (is_atom b alpha) ->
    ((swap a b (eVar a)) == eVar b) $;
axiom S4 (alpha tau: Pattern) {a b: EVar} (phi: Pattern a b):
  $ is_atom_sort alpha $ >
  $ is_nominal_sort tau $ >
  $ (is_atom a alpha) ->
    (is_atom b alpha) ->
    (is_of_sort phi tau) ->
    ((swap a b phi) == (swap b a phi)) $;
axiom F1 (alpha tau: Pattern) {a b: EVar} (phi: Pattern a b):
  $ is_atom_sort alpha $ >
  $ is_nominal_sort tau $ >
  $ (is_atom a alpha) ->
    (is_atom b alpha) ->
    (is_of_sort phi tau) ->
    ((fresh_for (eVar a) phi) /\ (fresh_for (eVar b) phi) -> ((swap a b phi) == phi)) $;
axiom F2 (alpha: Pattern) {a b: EVar}:
  $ is_atom_sort alpha $ >
  $ (is_atom a alpha) ->
    (is_atom b alpha) ->
    (((eVar a) != (eVar b)) <-> (fresh_for (eVar a) (eVar b))) $;
axiom F3 (alpha1 alpha2: Pattern) {a b: EVar}:
  $ is_atom_sort alpha1 $ >
  $ is_atom_sort alpha2 $ >
  $ (is_atom a alpha1) ->
    (is_atom b alpha2) ->
    (alpha1 != alpha2) ->
    ((eVar a) != (eVar b)) $;
axiom F4 (alpha tau phi: Pattern) {a: EVar}:
  $ is_atom_sort alpha $ >
  $ is_nominal_sort tau $ >
  $ (is_of_sort phi tau) ->
    (s_exists alpha a (fresh_for (eVar a) phi)) $;
axiom A1 (alpha tau: Pattern) {a b: EVar} (phi rho: Pattern a b):
  $ is_atom_sort alpha $ >
  $ is_nominal_sort tau $ >
  $ (is_atom a alpha) ->
    (is_atom b alpha) ->
    (is_of_sort phi tau) ->
    (is_of_sort rho tau) ->
    (((abstraction (eVar a) phi) == (abstraction (eVar b) rho)) <->
    ((eVar a == eVar b) /\ (phi == rho)) \/
    ((fresh_for (eVar a) rho) /\ ((swap a b phi) == rho))) $;
axiom A2 (alpha tau: Pattern) {x a y: EVar}:
  $ is_atom_sort alpha $ >
  $ is_nominal_sort tau $ >
  $ s_forall (sort_abstraction alpha tau) x
    (s_exists alpha a (s_exists tau y (eVar x == abstraction (eVar a) (eVar y)))) $;

def coercion {a: EVar} (phi: Pattern a) {.y: EVar}: Pattern a =
  $ exists y (eVar y /\ ((abstraction (eVar a) (eVar y)) == phi)) $;
