import "core.mm1";

term Var_sym: Symbol;
def Var: Pattern = $ sym Var_sym $;
def Vars: Pattern = $ dom Var $;
def is_var (p: Pattern): Pattern = $ is_of_sort p Var $;
axiom Var_atom: $ is_atom_sort Var $;

term Exp_sym: Symbol;
def Exp: Pattern = $ sym Exp_sym $;
def Exps: Pattern = $ dom Exp $;
def is_exp (p: Pattern): Pattern = $ is_of_sort p Exp $;
axiom Exp_sort: $ is_nominal_sort Exp $;

term lc_var_sym: Symbol;
def lc_var (phi: Pattern): Pattern = $ (sym lc_var_sym) @@ phi $;
axiom function_lc_var: $ ,(is_function '(sym lc_var_sym) '[Var] 'Exp) $;
axiom EV_lc_var {a b: EVar} (c: Pattern a b):
  $ s_forall Var a (s_forall Var b (
    (is_of_sort c Var) ->
    ((swap (eVar a) (eVar b) (lc_var c)) == lc_var (swap (eVar a) (eVar b) c)))) $;

term lc_app_sym: Symbol;
def lc_app (phi rho: Pattern): Pattern = $ (sym lc_app_sym) @@ phi @@ rho $;
axiom function_lc_app: $ ,(is_function '(sym lc_var_app) '[Exp Exp] 'Exp) $;

term lc_lam_sym: Symbol;
def lc_lam (phi: Pattern): Pattern = $ (sym lc_lam_sym) @@ phi $;
def lc_lam_a (a p: Pattern): Pattern = $ lc_lam (abstraction a p) $;
axiom function_lc_lam: $ ,(is_function '(sym lc_lam_sym) '[(sort_abstraction Var Exp)] 'Exp) $;
axiom EV_lc_lam {a b: EVar} (phi: Pattern a b):
  $ s_forall Var a (s_forall Var b (
    (is_of_sort phi (sort_abstraction Var Exp)) ->
    ((swap (eVar a) (eVar b) (lc_lam phi)) == lc_lam (swap (eVar a) (eVar b) phi)))) $;

axiom no_junk {X: SVar}:
  $ Exps == mu X ( (lc_var Vars)
                \/ (lc_app (sVar X) (sVar X))
                \/ (lc_lam (abstraction Vars (sVar X)))) $;

--- add no_confusion axioms for the symbols
--- add EV axioms for the symbols

do {
  (def (subst_at_depth n) (if {n = 0} 'appCtxVar @ if {n = 1} 'appCtxRVar '(norm_trans appCtxL_disjoint @ norm_app ,(subst_at_depth {n - 1}) norm_refl)))
  (def (uncurry_n n) (if {n < 2} 'id '(rsyl (anl impexp) @ imim2 ,(uncurry_n {n - 1}))))
  (def (function_sorting_full n) (if {n = 0} 'domain_func_sorting '(syl ,(pointwise_decomposition_imp_subst (subst_at_depth n)) @ forall_framing @ imim2 ,(function_sorting_full {n - 1}))))
  (def (function_sorting_lemma n pf) (if {n = 0} pf @
    if {n = 1} '(rsyl ,(imp_subset_framing_subst 'appCtxRVar) (mp (com12 subset_trans) ,pf))
    '(syl (curry subset_trans) @ anim ,(imp_subset_framing_subst (subst_at_depth n)) ,(function_sorting_lemma {n - 1} pf))))
  (def (function_sorting n function_pf) '(mp ,(uncurry_n n) ,(function_sorting_lemma n '(mp ,(function_sorting_full n) ,function_pf)))) 
};

theorem abstraction_sorting_full:
  $ is_of_sort (abstraction Vars Exps) (sort_abstraction Var Exp) $ =
  (named '(mp ,(function_sorting_full 2) @
    function_abstraction Var_atom Exp_sort));

theorem abstraction_sorting (phi rho: Pattern):
  $ is_var phi -> is_exp rho -> is_of_sort (abstraction phi rho) (sort_abstraction Var Exp) $ =
  (named (function_sorting 2 '(function_abstraction Var_atom Exp_sort)));

theorem swap_sorting {a b: EVar} (phi: Pattern a b):
  $ is_var (eVar a) -> is_var (eVar b) -> (is_exp phi) -> (is_exp (swap (eVar a) (eVar b) phi)) $ =
  (named (function_sorting 3 '(function_swap Var_atom Exp_sort)));
theorem swap_sorting_var {a b: EVar} (phi: Pattern a b):
  $ is_var (eVar a) -> is_var (eVar b) -> (is_var phi) -> (is_var (swap (eVar a) (eVar b) phi)) $ =
  (named (function_sorting 3 '(function_swap_atom Var_atom)));

theorem EV_lc_lam_abstraction {a b: EVar} (phi: Pattern a b):
  $ s_forall Var a (s_forall Var b (is_exp phi -> ((swap (eVar a) (eVar b) (lc_lam_a (eVar a) phi)) == lc_lam_a (eVar b) (swap (eVar a) (eVar b) phi)))) $ =
  (named '(
    univ_gene @
    anr imp_r_forall_disjoint @
    univ_gene @
    syl (anl impexp) @
    exp @
    rsyl (anr anass) @
    rsyl ancom @
    sylc eq_trans (
      rsyl (anr anass) @
      curry @
      rsyl (iand (impcom abstraction_sorting) anr) @
      curry @
      com12 @
      imim2 (anl com12b) @
      -- unquantification of EV_lc_lam
      var_subst_same_var @
      anl imp_r_forall_disjoint @
      var_subst_same_var EV_lc_lam
    )
    ( sylc eq_trans (
      syl ,(imp_eq_framing_subst 'appCtxRVar) @
      rsyl (anr anass) @
      curry @
      rsyl (iand anr id) @
      rsyl (anr anass) @
      curry @
      curry @
      --- unquantification of EV_abstraction
      rsyl (var_subst_same_var @ anl imp_r_forall_disjoint @ var_subst_same_var @ EV_abstraction Var_atom Exp_sort) @
      rsyl (imim2 @ anl com12b) @
      rsyl (anl com12b) @
      imim2 @
      anl com12b
    ) (
      rsyl anr @
      syl ,(imp_eq_framing_subst 'appCtxRLRVar) @
      curry @
      var_subst_same_var @
      anl imp_r_forall_disjoint @
      var_subst_same_var @
      S3 Var_atom
    ))
  ));

theorem EV_lc_var_lemma {a b: EVar} (phi: Pattern a b):
  $ s_forall Var a (s_forall Var b (is_var phi -> ((swap (eVar a) (eVar b) (lc_var phi)) == lc_var (swap (eVar a) (eVar b) phi)))) $ =
  '(
    univ_gene @
    anr imp_r_forall_disjoint @
    univ_gene @
    syl (anl impexp) @
    exp @
    rsyl (anr anass) @
    rsyl ancom @
    rsyl (anr anass) @
    curry @
    curry @
    com12 @
    imim2 (anl com12b) @
    -- unquantification of EV_lc_var
    var_subst_same_var @
    anl imp_r_forall_disjoint @
    var_subst_same_var EV_lc_var
    );
  

theorem exp_pred_ev_unquantified {x y: EVar} (exp_pred: Pattern):
  $ EV_pattern Var exp_pred -> (is_var (eVar x)) /\ (is_var (eVar y)) -> ((swap (eVar x) (eVar y) exp_pred) == exp_pred) $ =
  '(rsyl var_subst_same_var @ rsyl (imim2 var_subst_same_var) @ anr impexp);

theorem lc_lemma_1 {x: EVar} (exp_pred exp_suff_fresh: Pattern):
  $ is_var exp_suff_fresh ->
    |^ exp_suff_fresh ^| ->
    ((lc_lam (abstraction exp_suff_fresh exp_pred)) C= exp_pred) ->
    s_exists Var x ((lc_lam_a (eVar x) exp_pred) C= exp_pred) $ =
  '(exp @ exp @
    rsyl (anim1 @ anim2 @ anl lemma_ceil_exists_membership) @
    rsyl (anim1 and_exists_disjoint_reverse) @
    rsyl and_exists_disjoint_r_reverse @
    exists_framing @
    rsyl (anim1 @ iand anr @ rsyl (anim2 @ anl eVar_in_subset) @ impcom subset_trans) @
    rsyl (anl anass) @
    rsyl (anl anlass) @
    anim2 @
    curry @
    syl subset_trans @
    rsyl (anl eVar_in_subset) @
    syl ,(imp_subset_framing_subst 'appCtxRVar)
    ,(imp_subset_framing_subst 'appCtxLRVar));

theorem lc_lmma_1_var {x: EVar} (exp_pred exp_suff_fresh: Pattern):
  $ is_var exp_suff_fresh ->
    |^ exp_suff_fresh ^| ->
    ((lc_var exp_suff_fresh) C= exp_pred) ->
    s_exists Var x ((lc_var (eVar x)) C= exp_pred) $ =
  '(exp @ exp @
    rsyl (anim1 @ anim2 @ anl lemma_ceil_exists_membership) @
    rsyl (anim1 and_exists_disjoint_reverse) @
    rsyl and_exists_disjoint_r_reverse @
    exists_framing @
    rsyl (anim1 @ iand anr @ rsyl (anim2 @ anl eVar_in_subset) @ impcom subset_trans) @
    rsyl (anl anass) @
    rsyl (anl anlass) @
    anim2 @
    curry @
    syl subset_trans @
    rsyl (anl eVar_in_subset)
    ,(imp_subset_framing_subst 'appCtxRVar)
  );

theorem lc_lemma_2 {x y: EVar} (exp_pred: Pattern):
  $ (is_exp exp_pred) ->
    (EV_pattern Var exp_pred) ->
    ((is_var (eVar x)) /\ (is_var (eVar y)) /\ ((lc_lam_a (eVar y) exp_pred) C= exp_pred)) ->
    ((lc_lam_a (eVar x) exp_pred) C= exp_pred) $ =
  '(exp @ exp @
    rsyl (anim2 @ anim2 ,(imp_subset_framing_subst 'appCtxRVar)) @
    rsyl (anim1 ancom) @
    rsyl (anl anass) @
    rsyl (anim2 @ iand (rsyl anr anl) @
      syl (curry subset_trans) @
      rsyl (anr anass) @
      anim1 @
      rsyl (anim2 ancom) @
      rsyl (curry @ com12 @ curry @ var_subst_same_var @ anl imp_r_forall_disjoint @ var_subst_same_var EV_lc_lam_abstraction) @
      rsyl eq_sym
      eq_imp_subset) @
    rsyl (anr anass) @
    rsyl (anim1 @ anim2 ancom) @
    rsyl (anim1 @ curry exp_pred_ev_unquantified) @
    curry @
    syl anl ,(func_subst_explicit_helper 'hole $(_ @@ (_ @@ (eVar hole))) C= (eVar hole)$));

theorem lc_lemma_2_var {x y: EVar} (exp_pred: Pattern):
  $ is_var (eVar y) /\ ((lc_var (eVar y)) C= exp_pred) ->
    (EV_pattern Var exp_pred) ->
    (is_var (eVar x)) ->
    ((lc_var (eVar x)) C= exp_pred) $ =
  '(com12 @ exp @ exp @
    rsyl (anl anass) @
    rsyl (anim2 @ rsyl ancom @ anr anass) @
    rsyl (anim2 @ anim2 ,(imp_subset_framing_subst 'appCtxRVar)) @
    rsyl (anim2 @ anim1 @ iand id @ rsyl (anim2 @ iand id id) @ rsyl (anr anass) @ rsyl (anim1 ancom) @ curry @ curry @ var_subst_same_var @ anl imp_r_forall_disjoint @ var_subst_same_var EV_lc_var_lemma) @
    rsyl (anim2 @ anl anass) @
    rsyl (anim2 @ anim2 @ anim1 @ rsyl eq_sym eq_imp_subset) @
    rsyl (anim2 @ anim2 @ curry subset_trans) @
    rsyl (anr anass) @
    rsyl (anim1 ancom) @
    rsyl (iand anl id) @
    rsyl (anim2 @ anim1 @ anim1 ancom) @
    rsyl (anim2 @ anim1 @ syl eq_imp_subset @ rsyl (anim2 @ rsyl (syl var_subst_same_var @ syl (anl imp_r_forall_disjoint) var_subst_same_var) @ anr impexp) appl) @
    rsyl (anim2 @ impcom subset_trans) @
    rsyl (anim1 @ rsyl anl @ rsyl ancom @ curry @ var_subst_same_var @ anl imp_r_forall_disjoint @ var_subst_same_var @ S3 Var_atom) @
    rsyl (anim1 @ rsyl eq_sym eq_imp_subset) @
    rsyl (anim1 ,(imp_subset_framing_subst 'appCtxRVar)) @
    curry subset_trans
    );

theorem lc_lemma_3 {y: EVar} (exp_pred: Pattern):
  $ is_var exp_suff_fresh ->
    |^ exp_suff_fresh ^| ->
    ((lc_lam (abstraction exp_suff_fresh exp_pred)) C= exp_pred) ->
    is_exp exp_pred ->
    EV_pattern Var exp_pred ->
    is_var (eVar y) ->
    ((lc_lam_a (eVar y) exp_pred) C= exp_pred) $ = (named
  '(imim2 (imim2 @ imim2 @
    exp @ rsyl and_exists_disjoint_r_reverse @
    exp @ rsyl and_exists_disjoint_r_reverse @
    exp @ rsyl and_exists_disjoint_r_reverse @
    exists_generalization_disjoint @
    rsyl (anl anass) @
    rsyl (anl anass) @
    rsyl ancom @
    rsyl (anim1 @ anr anass) @
    rsyl (anl anass) @
    rsyl (anim2 @ anr anass) @
    curry @ curry lc_lemma_2
  ) lc_lemma_1));
 
theorem freshness_irrelevance_lam (exp_pred exp_suff_fresh: Pattern):
  $ is_var exp_suff_fresh ->
    |^ exp_suff_fresh ^| ->
    ((lc_lam (abstraction exp_suff_fresh exp_pred)) C= exp_pred) ->
    is_exp exp_pred ->
    EV_pattern Var exp_pred ->
    ((lc_lam (abstraction Vars exp_pred)) C= exp_pred) $ = (named
  '(imim2 (
    rsyl (anr imp_r_forall_disjoint) @ imim2 @
    rsyl (anr imp_r_forall_disjoint) @ imim2 @
    rsyl (anr imp_r_forall_disjoint) @ imim2 @
    rsyl (anr imp_r_forall_disjoint) @ imim2
    ,(pointwise_decomposition_imp_subst 'appCtxRLRVar)
    ) @ anr imp_r_forall_disjoint @ univ_gene lc_lemma_3));

theorem freshness_irrelevance_var (exp_pred exp_suff_fresh: Pattern):
  $ is_var exp_suff_fresh ->
    |^ exp_suff_fresh ^| ->
    ((lc_var exp_suff_fresh) C= exp_pred) ->
    EV_pattern Var exp_pred ->
    ((lc_var Vars) C= exp_pred) $ =
    (named '(imim2 (imim2 @ imim2 @
      exists_generalization_disjoint @
      imim2 (rsyl (anr imp_r_forall_disjoint) @ imim2 ,(pointwise_decomposition_imp_subst 'appCtxRVar)) @ anr imp_r_forall_disjoint @ univ_gene lc_lemma_2_var
      ) lc_lmma_1_var));

theorem induction_principle (exp_pred exp_suff_fresh_var exp_suff_fresh_lam: Pattern):
  $ (is_var exp_suff_fresh_var) ->
    |^ exp_suff_fresh_var ^| ->
    (is_var exp_suff_fresh_lam) ->
    |^ exp_suff_fresh_lam ^| ->
    (is_exp exp_pred) ->
    (EV_pattern Var exp_pred) ->
    ((lc_var exp_suff_fresh_var) C= exp_pred) ->
    ((lc_app exp_pred exp_pred) C= exp_pred) ->
    ((lc_lam (abstraction exp_suff_fresh_lam exp_pred)) C= exp_pred) ->
    (Exps == exp_pred) $ =
    (named '(exp @ exp @ exp @ exp @ exp @ exp @ exp @ exp @
      syl (curry subset_to_eq) @
      iand (syl (subset_trans @ eq_imp_subset no_junk) @ rsyl (syl (anr floor_idem) @ 
        rsyl (anim (anim (anim (anim (anim (anim (anim (anim (anr floor_idem) (anr floor_ceil_ceil)) (anr floor_idem)) (anr floor_ceil_ceil)) (anr floor_idem)) (syl (anr forall_floor) @ forall_framing @ syl floor_imp_lemma @ imim2 @ syl (anr forall_floor) @ forall_framing @ syl floor_imp_lemma @ imim2 @ anr floor_idem)) (anr floor_idem)) (anr floor_idem)) (anr floor_idem)) @
        rsyl (anim1 (
        rsyl (anim1 (
        rsyl (anim1 (
        rsyl (anim1 (
        rsyl (anim1 (
        rsyl (anim1 (
        rsyl (anim1 (
        rsyl (anim1 id) @
        anr propag_and_floor)) @
        anr propag_and_floor)) @
        anr propag_and_floor)) @
        anr propag_and_floor)) @
        anr propag_and_floor)) @
        anr propag_and_floor)) @
        anr propag_and_floor)) @
        anr propag_and_floor
      ) @ framing_floor @ com12 @
        KT_subst
          (positive_in_or (positive_in_or positive_disjoint @ positive_in_app (positive_in_app positive_disjoint positive_in_same_sVar) positive_in_same_sVar) @ positive_in_app positive_disjoint @ positive_in_app positive_disjoint positive_in_same_sVar)
          ,(propag_s_subst_adv 'X $a \/ (app (app a (sVar X)) (sVar X)) \/ (app a (app a (sVar X)))$ (atom-map! '[a #t])) @
          eori (eori
          (com12 @ rsyl corollary_57_floor @ syl corollary_57_floor @
            prop_2 (prop_2 (prop_2 (prop_2 (prop_1 freshness_irrelevance_var) an8l) an7lr) anllr) an3lr
          )
          (syl imidm @ imim2 (imim2 @ syl imidm @ imim2 (imim2 @ com12 @ rsyl corollary_57_floor @ syl corollary_57_floor @
            anlr
          )
            ,(ceil_imp_in_appCtx_subst 'appCtxLRVar))
            ,(ceil_imp_in_appCtx_subst 'appCtxRVar)))
          (syl imidm @ imim2 (imim2 @ com12 @ rsyl corollary_57_floor @ syl corollary_57_floor @
            prop_2 (prop_2 (prop_2 (prop_2 (prop_2 (prop_1 freshness_irrelevance_lam) an6lr) an5lr) anr) an4lr) an3lr
          )
            ,(ceil_imp_in_appCtx_subst @ appCtx_constructor '[1 1]))
      )
      an4lr));


---- Substitution

-- base term and definition
term subst_sym: Symbol;
def subst (a phi1 phi2: Pattern): Pattern = $ (sym subst_sym) @@ a @@ phi1 @@ phi2 $;

-- subst axioms
axiom function_subst: $ ,(is_function '(sym subst_sym) '[Var Exp Exp] 'Exp) $;
axiom EV_subst {a b: EVar} (c phi plug: Pattern a b):
  $ s_forall Var a (s_forall Var b (
    (is_var c) ->
    (is_exp phi) ->
    (is_exp plug) ->
    ((swap (eVar a) (eVar b) (subst c phi plug)) == subst (swap (eVar a) (eVar b) c) (swap (eVar a) (eVar b) phi) (swap (eVar a) (eVar b) plug)))) $;
axiom subst_fresh {a: EVar} (phi plug: Pattern a):
  $ s_forall Var a (
    (is_exp phi) ->
    (is_exp plug) ->
    (fresh_for (eVar a) phi) ->
    ((subst (eVar a) phi plug) == phi)) $;
axiom subst_same_var {a: EVar} (plug: Pattern a):
  $ s_forall Var a (
    (is_exp plug) ->
    ((subst (eVar a) (lc_var (eVar a)) plug) == plug)) $;
axiom subst_diff_var {a b: EVar} (plug: Pattern a b):
  $ s_forall Var a (
    s_forall Var b (
    ((eVar a) != (eVar b)) -> 
    (is_exp plug) ->
    ((subst (eVar b) (lc_var (eVar a)) plug) == (lc_var (eVar a))))) $;
axiom subst_var {a b: EVar} (plug: Pattern a b):
  $ s_forall Var a (
    s_forall Var b (
    ((eVar a) == (eVar b)) -> 
    (is_exp plug) ->
    ((subst (eVar b) (lc_var (eVar a)) plug) == plug))) $;
axiom subst_app {a: EVar} (phi1 phi2 plug: Pattern a):
  $ s_forall Var a (
    (is_exp plug) ->
    (is_exp phi1) ->
    (is_exp phi2) ->
    ((subst (eVar a) (lc_app phi1 phi2) plug) == (lc_app (subst (eVar a) phi1 plug) (subst (eVar a) phi2 plug)))) $;
-- axiom subst_lam_same_var (a plug phi: Pattern):
--   $ (is_sorted_func Var a) ->
--     (is_exp plug) ->
--     (is_exp phi) ->
--     ((subst a (lc_lam (abstraction a phi)) plug) == (lc_lam (abstraction a phi))) $;
axiom subst_lam {a b: EVar} (plug phi: Pattern a b):
  $ s_forall Var a (
    s_forall Var b (
    ((eVar a) == (eVar b)) ->
    (is_exp plug) ->
    (is_exp phi) ->
    ((subst (eVar b) (lc_lam (abstraction (eVar a) phi)) plug) == (lc_lam (abstraction (eVar a) phi))))) $;
axiom subst_lam_diff_var {a b: EVar} (plug phi: Pattern a b):
  $ s_forall Var a (
    s_forall Var b (
    ((eVar a) != (eVar b)) ->
    (fresh_for (eVar a) plug) ->
    (is_exp plug) ->
    (is_exp phi) ->
    ((subst (eVar b) (lc_lam (abstraction (eVar a) phi)) plug) == (lc_lam (abstraction (eVar a) (subst (eVar b) phi plug)))))) $;

theorem Var_nominal_sort: $ is_nominal_sort Var $ =
  '(anim2 (com12 subset_trans atoms_nominal_sorts) Var_atom);

theorem S2_lam {a b: EVar} (phi: Pattern a b):
  $ (is_var (eVar a)) ->
    (is_var (eVar b)) ->
    (is_exp phi) ->
    ((swap (eVar a) (eVar b) (swap (eVar a) (eVar b) phi)) == phi) $ =
  '(mp ,(inst_foralls 2) @ S2 Var_atom Exp_sort);

theorem S2_lam_var {a b: EVar} (phi: Pattern a b):
  $ (is_var (eVar a)) ->
    (is_var (eVar b)) ->
    (is_var phi) ->
    ((swap (eVar a) (eVar b) (swap (eVar a) (eVar b) phi)) == phi) $ =
  '(mp ,(inst_foralls 2) @ S2 Var_atom Var_nominal_sort);

theorem EV_supp_lam {a b: EVar} (phi: Pattern a b):
  $ (is_var (eVar a)) ->
    (is_var (eVar b)) ->
    (is_exp phi) ->
    ((swap (eVar a) (eVar b) (supp phi)) == supp (swap (eVar a) (eVar b) phi)) $ =
    '(mp ,(inst_foralls 2) @ EV_supp Var_atom Exp_sort);

theorem EV_subst_lam {a b: EVar} (c phi plug: Pattern a b):
  $ (is_var (eVar a)) ->
    (is_var (eVar b)) ->
    (is_var c) ->
    (is_exp phi) ->
    (is_exp plug) ->
    ((swap (eVar a) (eVar b) (subst c phi plug)) == subst (swap (eVar a) (eVar b) c) (swap (eVar a) (eVar b) phi) (swap (eVar a) (eVar b) plug)) $ =
    '(mp ,(inst_foralls 2) EV_subst);

theorem subst_sorting (c phi plug: Pattern):
  $ (is_var c) ->
    (is_exp phi) ->
    (is_exp plug) ->
    (is_exp (subst c phi plug)) $ =
    (named (function_sorting 3 'function_subst));

-- induction proof
def subst_induction_pred (a b phi plug1 plug2: Pattern): Pattern =
  $ (subst b (subst a phi plug1) plug2) == (subst a (subst b phi plug2) (subst b plug1 plug2)) $;
def satisfying_exps {.x: EVar} (a b plug1 plug2: Pattern): Pattern =
  $ s_exists Exp x ((eVar x) /\ subst_induction_pred a b (eVar x) plug1 plug2) $;
def satisfying_exps2 {.x .a .b .plug1 .plug2: EVar}: Pattern =
  $ s_exists Exp x ((eVar x) /\ s_forall Var a (s_forall Var b (s_forall Exp plug1 (s_forall Exp plug2 ((fresh_for (eVar a) (eVar plug2)) /\ (eVar a != eVar b) -> subst_induction_pred (eVar a) (eVar b) (eVar x) (eVar plug1) (eVar plug2)))))) $;

theorem satisfying_exps2_sorting: $ is_exp satisfying_exps2 $ =
  (named '(imp_to_subset @ rsyl (exists_framing @ rsyl (anr anass) anl) @ syl lemma_62_forward @ exists_framing @ anim1 eVar_in_subset_reverse));

theorem curried_function_swap {a b t: EVar}:
  $ is_var (eVar a) /\ is_var (eVar b) /\ is_exp (eVar t) -> is_sorted_func Exp (swap (eVar a) (eVar b) (eVar t))$ =
  (named '(curry @ curry @ mp ,(inst_foralls 3) @ function_swap Var_atom Exp_sort));
theorem curried_function_swap_atom {a b c: EVar}:
  $ is_var (eVar a) /\ is_var (eVar b) /\ is_var (eVar c) -> is_sorted_func Var (swap (eVar a) (eVar b) (eVar c))$ =
  (named '(curry @ curry @ mp ,(inst_foralls 3) @ function_swap_atom Var_atom));



theorem satisfying_exps2_is_exp: $ is_exp satisfying_exps2 $ =
  (named '(imp_to_subset @ exists_generalization_disjoint @ rsyl (anim2 anl) @ curry subset_to_imp));

theorem EV_set: $ EV_pattern Var satisfying_exps2 $ =
  (named '(univ_gene @ anr imp_r_forall_disjoint @ univ_gene @ exp @ syl (curry subset_to_eq) @ syl
    (iand anr @ rsyl (anim
        (syl eq_imp_subset @ syl eq_sym @ com12 (curry S2_lam) satisfying_exps2_sorting)
        ,(imp_subset_framing_subst 'appCtxRVar)) @
      curry subset_trans) @
    iand id @
    syl (subset_trans @ imp_to_subset @ anl ,(ex_appCtx_subst 'appCtxRVar)) @
    rsyl (anl floor_of_floor_and) @
    framing_floor @
    exp @
    rsyl and_exists_disjoint_reverse @
    exists_generalization_disjoint @
    rsyl (anim2 ,(appCtx_floor_commute_b_subst 'appCtxRVar)) @
    sylc
      ,(func_subst_alt_thm_sorted 'x $(eVar x) /\ forall _ (_ -> forall _ (_ -> forall _ (_ -> forall _ (_ -> _ -> ((_ @@ _ @@ (_ @@ _ @@ (eVar x) @@ _) @@ _) == (_ @@ _ @@ (_ @@ _ @@ (eVar x) @@ _) @@ _))))))$)
      (rsyl (anim2 anl) curried_function_swap) @
    rsyl (anim2 @ anim2 ,(extract_pred_from_appCtx_r $s_forall _ _ (s_forall _ _ (s_forall _ _ (s_forall _ _ ((~ (_ == _)) /\ (~ (_ == _)) -> (_ == _)))))$ 'appCtxRVar)) @
    rsyl (anim2 @ anl anlass) @
    rsyl (anl anlass) @
    anim2 @
    mp ,(forall_imp_push 1) @ univ_gene @
    mp ,(forall_imp_push 2) @ univ_gene @
    mp ,(forall_imp_push 3) @ univ_gene @
    mp ,(forall_imp_push 4) @ univ_gene @
    expcom @ expcom @ expcom @ expcom @ expcom @
    rsyl (anr anass) @
    rsyl (anr anass) @
    rsyl (anr anass) @
    rsyl (anr anass) @
    rsyl (anr anass) @
    rsyl (anr anass) @
    rsyl (iand anl @ anim1 @ rsyl (iand anllr anlr) @ rsyl ancom curried_function_swap_atom) @
    rsyl (anim2 @ curry
      ,(func_subst_explicit_thm_sorted 'x1 $((eVar x1) C= bot) -> forall y (((eVar y) C= bot) -> forall y (bot -> forall y (bot -> ((~((eVar x1) C= bot)) /\ ~((eVar x1) == bot)) -> ((bot @@ bot @@ (bot @@ (eVar x1) @@ bot @@ bot) @@ bot) == (bot @@ (eVar x1) @@ bot @@ bot)))))$)) @
    rsyl (iand anl @ anim1 @ rsyl (iand an3lr anlr) @ rsyl ancom curried_function_swap_atom) @
    rsyl (anim2 @ curry
      ,(func_subst_explicit_thm_sorted 'x2 $((eVar x2) C= bot) -> forall y (bot -> forall y (bot -> (bot /\ ~(bot == (eVar x2))) -> ((bot @@ (eVar x2) @@ bot @@ bot) == (bot @@ bot @@ (bot @@ (eVar x2) @@ bot @@ bot) @@ (bot @@ (eVar x2) @@ bot @@ bot)))))$)) @
    rsyl (iand anl @ anim1 @ rsyl (iand an4lr anlr) @ rsyl ancom curried_function_swap) @
    rsyl (anim2 @ curry
      ,(func_subst_explicit_thm_sorted 'x3 $((eVar x3) C= bot) -> forall y (bot -> bot -> ((bot @@ bot @@ (bot @@ bot @@ bot @@ (eVar x3)) @@ bot) == (bot @@ bot @@ bot @@ (bot @@ bot @@ (eVar x3) @@ bot))))$)) @
    rsyl (iand anl @ anim1 @ rsyl (iand an5lr anlr) @ rsyl ancom curried_function_swap) @
    rsyl (anim2 @ curry
      ,(func_subst_explicit_thm_sorted 'x4 $((eVar x4) C= bot) -> ((~(bot C= (bot @@ (eVar x4)))) /\ bot) -> ((bot @@ bot @@ bot @@ (eVar x4)) == (bot @@ bot @@ (bot @@ (eVar x4)) @@ (bot @@ bot @@ bot @@ (eVar x4))))$)
      ) @
    curry @
    eimd (iand
      (rsyl
        (iand
          (iand
            (rsyl (iand anlr anllr) @ curry @ curry S2_lam_var)
            (rsyl (iand anlr an5lr) @ iand (curry @ curry S2_lam) (rsyl (iand anl @ curry @ curry swap_sorting) @ curry @ curry EV_supp_lam)))
          an7l) @
        curry @ syl con3 @ exp @
        rsyl (anim2 ,(subset_framing_imp_subst 'appCtxRVar)) @
        rsyl (anim1 @ anim (rsyl eq_sym eq_imp_subset) @ anim (syl ,(subset_framing_imp_subst 'appCtxRVar) eq_imp_subset) eq_imp_subset) @
        rsyl (iand (syl (curry subset_trans) @ iand anll anr) @ rsyl anlr @ rsyl ancom @ curry subset_trans) @
        curry subset_trans)
      (rsyl
        (iand (iand
          (rsyl (iand anlr anllr) @ curry @ curry S2_lam_var)
          (rsyl (iand anlr an3lr) @ curry @ curry S2_lam_var))
          an6lr) @
        curry @ syl con3 @ exp @
        rsyl (anl anass) @
        rsyl (anim eq_sym @ rsyl ancom @ rsyl (anim1 ,(eq_framing_imp_subst 'appCtxRVar)) @ curry eq_trans)
        @ curry eq_trans)) @
    exp @
    rsyl (anim2 ,(eq_framing_imp_subst 'appCtxRVar)) @
    rsyl (iand anl @ syl (curry eq_trans) @
      anim1 @ syl eq_sym @ syl (curry @ curry @ curry @ curry EV_subst_lam) @ iand (iand (iand anlr (syl (curry @ curry swap_sorting_var) @ iand anlr an3lr)) @ syl (curry @ curry subst_sorting) @ iand (iand (syl (curry @ curry swap_sorting_var) @ iand anlr anllr) anr) (syl (curry @ curry swap_sorting) @ iand anlr an4lr)) (syl (curry @ curry swap_sorting) @ iand anlr an5lr)) @
    rsyl (iand anl @ syl (curry eq_trans) @
      anim1 @ syl eq_sym @ syl ,(eq_framing_imp_subst @ appCtx_constructor '[0 0 1]) @ syl (curry @ curry S2_lam_var) @ iand anlr an3lr) @
    rsyl (iand anl @ syl (curry eq_trans) @
      anim1 @ syl eq_sym @ syl ,(eq_framing_imp_subst @ appCtx_constructor '[1]) @ syl (curry @ curry S2_lam) @ iand anlr an5lr) @
    rsyl (iand anl @ syl (curry eq_trans) @
      anim1 @ syl eq_sym @ syl ,(eq_framing_imp_subst @ appCtx_constructor '[0 1]) @ syl (curry @ curry @ curry @ curry EV_subst_lam) @ iand (iand (iand anlr @ syl (curry @ curry swap_sorting_var) @ iand anlr anllr) anr) @ syl (curry @ curry swap_sorting) @ iand anlr an4lr) @
    rsyl (iand anl @ syl (curry eq_trans) @
      anim1 @ syl eq_sym @ syl ,(eq_framing_imp_subst @ appCtx_constructor '[0 1]) @
        syl ,(eq_framing_imp_subst @ appCtx_constructor '[0 0 1]) @ syl (curry @ curry S2_lam_var) @ iand anlr anllr) @
    rsyl (iand anl @ syl (curry eq_trans) @
      anim1 @ syl eq_sym @ syl ,(eq_framing_imp_subst @ appCtx_constructor '[0 1]) @
        syl ,(eq_framing_imp_subst @ appCtx_constructor '[1]) @ syl (curry @ curry S2_lam) @ iand anlr an4lr) @
    curry @
    syl (com12 eq_trans) @
    sylc eq_trans (syl (curry @ curry @ curry @ curry EV_subst_lam) @ iand (iand (iand anlr @ syl (curry @ curry swap_sorting_var) @ iand anlr anllr) @ syl (curry @ curry subst_sorting) @ iand (iand (syl (curry @ curry swap_sorting_var) @ iand anlr an3lr) anr) @ syl (curry @ curry swap_sorting) @ iand anlr an5lr) @ syl (curry @ curry  subst_sorting) @ iand (iand (syl (curry @ curry swap_sorting_var) @ iand anlr an3lr) (syl (curry @ curry swap_sorting) @ iand anlr an4lr)) (syl (curry @ curry swap_sorting) @ iand anlr an5lr)) @
    sylc eq_trans (syl ,(eq_framing_imp_subst @ appCtx_constructor '[0 0 1]) @ syl (curry @ curry S2_lam_var) @ iand anlr anllr) @
    sylc eq_trans (syl ,(eq_framing_imp_subst @ appCtx_constructor '[0 1]) @
      sylc eq_trans
        (syl (curry @ curry @ curry @ curry EV_subst_lam) @ iand4 anlr (syl (curry @ curry swap_sorting_var) @ iand anlr an3lr) anr (syl (curry @ curry swap_sorting) @ iand anlr an5lr)) @
      sylc eq_trans
        (syl ,(eq_framing_imp_subst @ appCtx_constructor '[0 0 1]) @ syl (curry @ curry S2_lam_var) @ iand anlr an3lr)
        (syl ,(eq_framing_imp_subst @ appCtx_constructor '[1]) @ syl (curry @ curry S2_lam) @ iand anlr an5lr)) @
    sylc eq_trans (syl ,(eq_framing_imp_subst @ appCtx_constructor '[1]) @
      sylc eq_trans
        (syl (curry @ curry @ curry @ curry EV_subst_lam) @ iand4 anlr (syl (curry @ curry swap_sorting_var) @ iand anlr an3lr) (syl (curry @ curry swap_sorting) @ iand anlr an4lr) (syl (curry @ curry swap_sorting) @ iand anlr an5lr)) @
      sylc eq_trans
        (syl ,(eq_framing_imp_subst @ appCtx_constructor '[0 0 1]) @ syl (curry @ curry S2_lam_var) @ iand anlr an3lr) @
      sylc eq_trans
        (syl ,(eq_framing_imp_subst @ appCtx_constructor '[0 1]) @ syl (curry @ curry S2_lam) @ iand anlr an4lr)
        (syl ,(eq_framing_imp_subst @ appCtx_constructor '[1]) @ syl (curry @ curry S2_lam) @ iand anlr an5lr)) @
    a1i eq_refl));


theorem case_analysis_lemma:
  $ c -> a \/ (b \/ (c /\ ~a /\ ~b)) $ =
  '(rsyl lemma_60_helper_1 @ rsyl orcom @ orim anr @
    rsyl lemma_60_helper_1 @ rsyl orcom @ orim1 anr);

theorem case_analysis_var {x: EVar} (a b c: Pattern):
  $ (x in c) -> (x in a) \/ ((x in b) \/ (x in (c /\ ~a /\ ~b))) $ =
  '(rsyl (framing_def @ anim2 case_analysis_lemma) @
    rsyl (framing_def @ rsyl (anl andi) @ orim2 @ anl andi) @
    rsyl prop_43_or_def_rev @
    orim2 @
    prop_43_or_def_rev);

theorem func_var_atom
  (a_var: $ is_sorted_func Var a $):
  $ is_sorted_func Exp (lc_var a) $ =
  (named '(mp ,(func_subst 'x $(eVar x C= _) -> exists _ (_ /\ (_ == (_ @@ (eVar x))))$ '(var_subst_same_var function_lc_var) '(exists_framing anr a_var)) @ domain_func_sorting a_var));


theorem mem_func_lemma:
  $ (is_func phi) -> (x in phi) -> ((eVar x) == phi) $ =
  (named '(com12 ,(func_subst_explicit_thm 'y2 $(z in (eVar y2)) -> ((eVar z) == (eVar y2))$) @ univ_gene membership_var_forward));

theorem mem_func_lemma_neg:
  $ (is_func phi) -> ~(x in phi) -> ((eVar x) != phi) $ =
  (named '(com12 ,(func_subst_explicit_thm 'y2 $~(z in (eVar y2)) -> ~((eVar z) == (eVar y2))$) @ univ_gene @ con3 membership_var_reverse));

theorem subst_induction_var2: $ (lc_var Vars) C= satisfying_exps2 $ =
  (named '(imp_to_subset @ membership_elim @ forall_framing membership_imp_reverse @ univ_gene @
    syl (anr ,(propag_mem 'x $exists y (|_ _ _| /\ (eVar y /\ (forall _ (|_ _ _| -> forall _ (|_ _ _| -> forall _ (|_ _ _| -> forall _ (|_ _ _| -> ((~(|_ _ _|)) /\ ~(|_ _ _|)) -> |_ _ _|)))))))$)) @
    syl ,(exists_intro_subst @ propag_e_subst 'x $((eVar x) C= bot) /\ ((bot == (eVar x)) /\ (forall _ (bot -> (forall _ (bot -> (forall _ (bot -> (forall _ (bot -> bot -> ((app (app bot (app (app bot (eVar x)) bot)) bot) == (app (app bot (app (app bot (eVar x)) bot)) bot)))))))))))$) @
    iand (rsyl eVar_in_subset_forward @ com12 subset_trans @ mp ,(function_sorting_full 1) function_lc_var) @
    iand (a1i eq_refl) @
    anr ,(forall_extract $_ -> _$) @ univ_gene @
    anr ,(forall_extract $_ -> _ -> _$) @ univ_gene @
    anr ,(forall_extract $_ -> _ -> _ -> _$) @ univ_gene @
    anr ,(forall_extract $_ -> _ -> _ -> _ -> _$) @ univ_gene @
    rsyl case_analysis_var @
    eori
      (exp @ rsyl (iand (rsyl (anim2 @
        rsyl (var_subst_same_var function_lc_var) @
        rsyl (exists_framing anr) mem_func_lemma) appl) anr) @
      curry @
      mp ,(func_subst_imp_to_var 'y $bot -> bot -> bot -> bot -> bot -> ((bot @@ bot @@ (bot @@ bot @@ (eVar y) @@ bot) @@ bot) == (bot @@ bot @@ (bot @@ bot @@ (eVar y) @@ bot) @@ bot))$) @
      exp @ exp @ exp @ exp @
      sylc eq_trans (
        syl ,(imp_eq_framing_subst @ appCtx_constructor '[0 1]) @
        syl (curry @ var_subst_same_var subst_same_var) @
        iand an4l anllr) @
      syl eq_sym @
      sylc eq_trans (
        syl ,(imp_eq_framing_subst @ appCtx_constructor '[0 1]) @
        syl (curry @ curry @ curry @ mp ,(inst_foralls 2) @ subst_diff_var) @
        iand4 an4l an3lr anrr anlr) @
      syl (curry @ var_subst_same_var subst_same_var) @
      iand an4l @
      syl (curry @ curry subst_sorting) @
      iand3 an3lr anllr anlr)
    @ eori
      (exp @ exp @
      rsyl (iand4
        anll
          (rsyl anr @
          rsyl (var_subst_same_var function_lc_var) @
          rsyl (exists_framing anr) mem_func_lemma)
        anlr
        anr) @
      curry @ curry @
      rsyl appl @
      mp ,(func_subst_imp_to_var 'y $bot -> bot -> bot -> bot -> bot -> ((bot @@ bot @@ (bot @@ bot @@ (eVar y) @@ bot) @@ bot) == (bot @@ bot @@ (bot @@ bot @@ (eVar y) @@ bot) @@ bot))$) @
      exp @ exp @ exp @ exp @
      sylc eq_trans (
        syl ,(imp_eq_framing_subst @ appCtx_constructor '[0 1]) @
        syl (curry @ curry @ curry @ mp ,(inst_foralls 2) @ subst_diff_var) @
        iand4 an3lr an4l (rsyl anrr @ con3 eq_sym) anllr) @
      sylc eq_trans (
        syl (curry @ var_subst_same_var subst_same_var) @
        iand an3lr anlr) @
      syl eq_sym @
      sylc eq_trans (
        syl ,(imp_eq_framing_subst @ appCtx_constructor '[0 1]) @
        syl (curry @ var_subst_same_var subst_same_var) @
        iand an3lr anlr) @
      syl (curry @ curry @ curry @ var_subst_same_var @ subst_fresh) @
      iand4 an4l anlr
        (syl (curry @ curry subst_sorting) @ iand3 an3lr anllr anlr)
        anrl) @

        rsyl (anl ,(propag_mem _ $_ /\ (~ _) /\ (~ _)$)) @
        exp @ exp @
        rsyl (iand5 an4l (iand an3lr anlr) (iand anllr anr) anlr anr) @
        curry @ curry @
        rsyl (anim (anim2 @
          syl appl @ anim2 @ syl mem_func_lemma_neg @ rsyl (var_subst_same_var function_lc_var) @ exists_framing anr) @
          syl appl @ anim2 @ syl mem_func_lemma_neg @ rsyl (var_subst_same_var function_lc_var) @ exists_framing anr) @
        rsyl (anim1 @ anim1 @ anl ,(membership_appCtx_subst 'appCtxRVar)) @
        curry @ curry @
        exists_generalization_disjoint @
        rsyl (anim1 eVar_in_subset_forward) @
        rsyl (iand anl (iand anr anl)) @
        rsyl (anim2 @ syl appl @ anim2 @ syl mem_func_lemma @ rsyl (var_subst_same_var function_lc_var) @ exists_framing anr) @
        impcom @
        mp ,(func_subst_imp_to_var 'y3 $_ -> ~ (eVar y3 == bot) -> ~ (eVar y3 == bot) -> bot -> bot -> bot -> bot -> bot -> ((bot @@ bot @@ (bot @@ bot @@ (eVar y3) @@ bot) @@ bot) == (bot @@ bot @@ (bot @@ bot @@ (eVar y3) @@ bot) @@ bot))$) @
        syl (imim1 @ con3 ,(imp_eq_framing_subst 'appCtxRVar)) @
        syl (imim2 @ imim1 @ con3 ,(imp_eq_framing_subst 'appCtxRVar)) @
        exp @ exp @ exp @ exp @ exp @ exp @ exp @
        sylc eq_trans (
          syl ,(imp_eq_framing_subst @ appCtx_constructor '[0 1]) @
          syl (curry @ curry @ curry @ mp ,(inst_foralls 2) @ subst_diff_var) @
          iand4 an7l an4lr an6lr anllr) @
        sylc eq_trans (
          syl (curry @ curry @ curry @ mp ,(inst_foralls 2) @ subst_diff_var) @
          iand4 an7l an3lr an5lr anlr) @
        syl eq_sym @
        sylc eq_trans (
          syl ,(imp_eq_framing_subst @ appCtx_constructor '[0 1]) @
          syl (curry @ curry @ curry @ mp ,(inst_foralls 2) @ subst_diff_var) @
          iand4 an7l an3lr an5lr anlr) @
        sylc eq_trans (
          syl (curry @ curry @ curry @ mp ,(inst_foralls 2) @ subst_diff_var) @
          iand4 an7l an4lr an6lr @ syl (curry @ curry subst_sorting) @ iand3 an3lr anllr anlr) @
        a1i eq_refl));

theorem subst_induction_app2: $ (lc_app satisfying_exps2 satisfying_exps2) C= satisfying_exps2 $ =
  '(imp_to_subset _);

theorem subst_induction_app_lemma
  (a_var: $ is_sorted_func Var a $)
  (b_var: $ is_sorted_func Var b $)
  (plug1_exp: $ is_exp plug1 $)
  (plug2_exp: $ is_exp plug2 $):
  $ (is_exp (eVar x) /\ subst_induction_pred a b (eVar x) plug1 plug2) /\ (is_exp (eVar y) /\ subst_induction_pred a b (eVar y) plug1 plug2) -> subst_induction_pred a b (lc_app (eVar x) (eVar y)) plug1 plug2 $ =
  (named '(rsyl (anl an4) @ rsyl (anim2 @
    syl (curry eq_trans) @
    iand
      (rsyl anl @ eq_equiv_to_eq_eq ,(func_subst_explicit_helper 'z $_ @@ (eVar z) @@ _$))
      (rsyl anr @ eq_equiv_to_eq_eq ,(func_subst_explicit_helper 'z $_ @@ (eVar z)$))
  ) @
  rsyl (anim1 @ iand id id) @
  rsyl (anl anass) @
  rsyl (anim2 @ anim1 @ syl (curry @ subst_app b_var plug2_exp) (anim
    (mp (com12 @ mp ,(function_sorting 3 'function_subst) (domain_func_sorting a_var)) plug1_exp)
    (mp (com12 @ mp ,(function_sorting 3 'function_subst) (domain_func_sorting a_var)) plug1_exp)
    )) @
  rsyl (anim2 @ curry eq_trans) @
  rsyl (anim1 @ iand id id) @
  rsyl (anl anass) @
  rsyl (anim2 @ anim1 @ syl ,(imp_eq_framing_subst 'appCtxLRVar) @ curry @ subst_app a_var plug1_exp) @
  rsyl (anim2 @ curry eq_trans) @
  rsyl (anim1 @ iand id id) @
  rsyl (anl anass) @
  rsyl (anim2 @ anim1 @ syl eq_sym @ syl (curry @ subst_app a_var (mp (mp (mp ,(function_sorting 3 'function_subst) (domain_func_sorting b_var)) plug1_exp) plug2_exp)) (anim
    (mp (com12 @ mp ,(function_sorting 3 'function_subst) (domain_func_sorting b_var)) plug2_exp)
    (mp (com12 @ mp ,(function_sorting 3 'function_subst) (domain_func_sorting b_var)) plug2_exp)
    )) @
  rsyl (anim2 @ impcom eq_trans) @
  rsyl (anim1 @ iand id id) @
  rsyl (anl anass) @
  rsyl (anim2 @ anim1 @ syl eq_sym @ syl ,(imp_eq_framing_subst 'appCtxLRVar) @ curry @ subst_app b_var plug2_exp) @
  rsyl (anim2 @ impcom eq_trans) @
  anr));

theorem subst_induction_app (a b plug1 plug2: Pattern)
  (lemma: $ (is_exp (eVar x) /\ subst_induction_pred a b (eVar x) plug1 plug2) /\ (is_exp (eVar y) /\ subst_induction_pred a b (eVar y) plug1 plug2) -> subst_induction_pred a b (lc_app (eVar x) (eVar y)) plug1 plug2 $):
  $ (lc_app (satisfying_exps a b plug1 plug2) (satisfying_exps a b plug1 plug2)) C= (satisfying_exps a b plug1 plug2) $ =
  (named '(imp_to_subset @
    rsyl (anl ,(ex_appCtx_subst 'appCtxLRVar)) @
    exists_generalization_disjoint @
    rsyl (anl ,(ex_appCtx_subst 'appCtxRVar)) @
    exists_generalization_disjoint @
    rsyl ,(appCtx_floor_commute_b_subst 'appCtxLRVar) @
    rsyl (anim1 @ iand id id) @
    rsyl (anl anass) @
    rsyl (anim2 @
      rsyl (anim2 ,(appCtx_floor_commute_subst 'appCtxLRVar)) @
      rsyl (anim2 ancom) @
      rsyl (anr anass) @
      rsyl (anim2 @
        rsyl ,(appCtx_floor_commute_b_subst 'appCtxRVar) @
        rsyl (anim1 @ iand id id) @
        rsyl (anl anass) @
        anim2 @
        rsyl (anim2 ,(appCtx_floor_commute_subst 'appCtxRVar)) @
        rsyl (anim2 ancom) @
        anr anass
        ) @
      rsyl (anl anlass) @
      anim2 @
      anr anass) @
    rsyl (anr anass) @
    rsyl (anim2 @ anim1 lemma) @
    rsyl (anim2 @ ancom) @
    rsyl (anim1 @ curry @ mp ,(inst_foralls 2) function_lc_app) @
    curry ,(func_subst_alt_thm_sorted 'x $(eVar x) /\ ((app (app _ (app (app _ (eVar x)) _)) _) == (app (app _ (app (app _ (eVar x)) _)) _))$)
    ));

theorem subst_induction_lam_lemma (a b c plug1 plug2: Pattern)
  (diff_atoms_ab: $ a != b $)
  (diff_atoms_cb: $ c != b $)
  (diff_atoms_ca: $ c != a $)
  (a_var: $ is_sorted_func Var a $)
  (b_var: $ is_sorted_func Var b $)
  (c_var: $ is_sorted_func Var c $)
  (a_fresh: $ fresh_for a plug2 $)
  (c_fresh_in_plug1: $ fresh_for c plug1 $)
  (c_fresh_in_plug2: $ fresh_for c plug2 $)
  (phi_exp: $ is_exp phi $)
  (plug1_exp: $ is_exp plug1 $)
  (plug2_exp: $ is_exp plug2 $):
  $ is_exp (eVar x) /\ subst_induction_pred a b (eVar x) plug1 plug2 -> subst_induction_pred a b (lc_lam (abstraction c (eVar x))) plug1 plug2 $ =
  '(rsyl (anim1 @ iand id id) @
    rsyl (anl anass) @
    rsyl (anim2 @ anim1 @ syl (eq_equiv_to_eq_eq ,(func_subst_explicit_helper 'z $_ @@ (eVar z) @@ _$)) @
      subst_lam_diff_var diff_atoms_ca c_fresh_in_plug1 c_var a_var plug1_exp) @
    rsyl (anl anlass) @
    syl (curry eq_trans) @
    anim2 @
    rsyl (anim1 @ iand id id) @
    rsyl (anl anass) @
    rsyl (anim2 @ anim1 @ syl (subst_lam_diff_var diff_atoms_cb c_fresh_in_plug2 c_var b_var plug2_exp)
      (com12 (mp ,(function_sorting 3 'function_subst) (domain_func_sorting a_var)) plug1_exp)
      ) @
    rsyl (anl anlass) @
    syl (curry eq_trans) @
    anim2 @
    rsyl (anim2 @ rsyl (eq_equiv_to_eq_eq ,(func_subst_explicit_helper 'z $_ @@ (eVar z)$)) (eq_equiv_to_eq_eq ,(func_subst_explicit_helper 'z $_ @@ (eVar z)$))) @
    rsyl ancom @
    syl (curry eq_trans) @
    anim2 @
    rsyl (iand
      (syl eq_sym @ syl (subst_lam_diff_var diff_atoms_ca _ c_var a_var (mp (mp ,(function_sorting 3 'function_subst) (domain_func_sorting b_var)) plug1_exp plug2_exp)) (com12 (mp ,(function_sorting 3 'function_subst) (domain_func_sorting b_var)) plug2_exp))
      (syl eq_sym @ syl (eq_equiv_to_eq_eq ,(func_subst_explicit_helper 'z $_ @@ (eVar z) @@ _$)) (subst_lam_diff_var diff_atoms_cb c_fresh_in_plug2 c_var b_var plug2_exp))
    ) @
    curry eq_trans);

theorem subst_induction_lam (a b c plug1 plug2: Pattern)
  (c_sorting: $ is_sorted_func Var c $)
  (lemma: $ is_exp (eVar x) /\ subst_induction_pred a b (eVar x) plug1 plug2 -> subst_induction_pred a b (lc_lam (abstraction c (eVar x))) plug1 plug2 $):
  $ (lc_lam (abstraction c (satisfying_exps a b plug1 plug2))) C= (satisfying_exps a b plug1 plug2) $ =
  (named '(imp_to_subset @
    rsyl (anl ,(ex_appCtx_subst @ appCtx_constructor '[1 1])) @
    exists_generalization_disjoint @
    rsyl ,(appCtx_floor_commute_b_subst @ appCtx_constructor '[1 1]) @
    rsyl (anim2 ,(appCtx_floor_commute_subst @ appCtx_constructor '[1 1])) @
    rsyl (anim1 @ iand id id) @
    rsyl (anl anass) @
    rsyl (anim2 @ rsyl (anl anlass) @ anim2 lemma) @
    rsyl (anim1 @ rsyl (mp ,(inst_foralls 1) (swap_sorted_forall @ function_abstraction Var_atom Exp_sort))
      (rsyl (con1 @ anr imp_exists_disjoint (exists_framing (syl con3 @ syl anl ,(func_subst_explicit_helper 'x $((eVar x) C= _) -> exists _ (_ /\ (_ == (_ @@ (eVar x) @@ _)))$)) (exists_framing anr c_sorting))) @ rsyl (mpcom @ domain_func_sorting c_sorting) @
        exists_generalization_disjoint @ rsyl (anim1 @ var_subst_same_var function_lc_lam) @ impcom @ syl anl ,(func_subst_explicit_helper 'x $exists _ (_ /\ (_ == (_ @@ (eVar x))))$))
      ) @
    curry ,(func_subst_alt_thm_sorted 'x $(eVar x) /\ ((app (app _ (app (app _ (eVar x)) _)) _) == (app (app _ (app (app _ (eVar x)) _)) _))$)
    ));
  

theorem subst_induction_lemma:
  $ Exps == satisfying_exps2 $ =
  '(induction_principle
    subset_refl
    (nonempty_domain @ nominal_sorts_are_sorts Var_nominal_sort)
    _
    _
    satisfying_exps2_is_exp
    EV_set
    subst_induction_var2
    _
    _);

do {
  (def (satisfying_exps2_expanded) $((exists x (((eVar x) C= Exps) /\ (and (eVar x) (forall a (((eVar a) C= Vars) -> (forall b (((eVar b) C= Vars) -> (forall plug1 (((eVar plug1) C= Exps) -> (forall plug2 (((eVar plug2) C= Exps) -> (imp (and (~ ((eVar a) C= ((sym supp_sym) @@ (eVar plug2)))) (_neq (eVar a) (eVar b))) ((subst (eVar b) (subst (eVar a) (eVar x) (eVar plug1)) (eVar plug2)) == (subst (eVar a) (subst (eVar b) (eVar x) (eVar plug2)) (subst (eVar b) (eVar plug1) (eVar plug2)))))))))))))))))$)
};

theorem subst_induction (a b phi plug1 plug2: Pattern)
  (diff_atoms_ab: $ a != b $)
  (a_var: $ is_sorted_func Var a $)
  (b_var: $ is_sorted_func Var b $)
  (phi_exp: $ is_exp phi $)
  (plug1_exp: $ is_exp plug1 $)
  (plug2_exp: $ is_sorted_func Exp plug2 $)
  (a_fresh: $ fresh_for a plug2 $):
  $ (subst b (subst a phi plug1) plug2) == (subst a (subst b phi plug2) (subst b plug1 plug2)) $ =
  (named '(mp ,(s_forall_eq_lemma_subst (appCtx_constructor '[0 1 0 1]) (appCtx_constructor '[0 1 0 1])) @ univ_gene @
    mp (mp (exp @ com12 @
    imim2 (
      mp ,(func_subst_explicit_thm_sorted 'y1 $((eVar y1) C= bot) -> ((~ ((eVar y1) C= bot)) /\ ~ ((eVar y1) == bot)) ->
      ((bot @@
          bot @@
          (bot @@ (eVar y1) @@ bot @@ bot) @@
          bot) ==
        (bot @@
          (eVar y1) @@
          (bot @@ bot @@ bot @@ bot) @@
          (bot @@ bot @@ bot @@ bot)))$) a_var) @
    imim2 (forall_framing @ imim2 @
      mp ,(func_subst_explicit_thm_sorted 'y2 $((eVar y2) C= bot) -> (bot /\ ~ (bot == (eVar y2))) ->
      ((bot @@
          (eVar y2) @@
          bot @@
          bot) ==
        (bot @@
          bot @@
          (bot @@ (eVar y2) @@ bot @@ bot) @@
          (bot @@ (eVar y2) @@ bot @@ bot)))$) b_var) @
    imim2 (forall_framing @ imim2 @ forall_framing @ imim2 @
      rsyl (forall_framing @ rsyl (imim1 @ com12 subset_trans plug1_exp) @ anl com12b) @ rsyl (anr imp_r_forall_disjoint) @ imim2
      ,(s_forall_eq_lemma_subst (appCtx_constructor '[0 1 1]) (appCtx_constructor '[1 0 1]))) @
    imim2 (forall_framing @ imim2 @ forall_framing @ imim2 @ forall_framing @ imim2 @
      mp ,(func_subst_explicit_thm_sorted 'y $((eVar y) C= bot) -> ((~(bot C= (bot @@ eVar y))) /\ bot) ->
      ((bot @@
          bot @@
          bot @@
          eVar y) ==
        (bot @@
          bot @@
          (bot @@ bot @@ bot @@ eVar y) @@
          (bot @@ bot @@ bot @@ eVar y)))$) plug2_exp) @
    anrd @ syl exists_irrelevance @
    syl (exists_framing @ rsyl (anl anlass) ,(func_subst_imp_to_var_variant 'x
      $|_ eVar x -> dom Exp _| /\
      forall _
        (|_ eVar _ -> dom Var _| ->
          forall _
            (|_ eVar _ -> dom Var _| ->
              forall _
                (|_ eVar _ -> dom Exp _| ->
                  forall _
                    (|_ eVar _ -> dom Exp _| ->
                      ~|_ eVar _ -> (_ @@ (eVar _)) _| /\
                        (eVar _ != eVar _) ->
                      |_ (_ @@
                          (eVar _) @@
                          (_ @@ (eVar _) @@ (eVar x) @@ (eVar _)) @@
                          (eVar _)) <->
                        (_ @@
                          (eVar _) @@
                          (_ @@ (eVar _) @@ (eVar x) @@ (eVar _)) @@
                          (_ (eVar _) @@ (eVar _) @@ (eVar _))) _|))))$
      )) @ mp (anl @ bitr membership_imp_bi @ cong_of_equiv_imp eVar_in_subset ,(propag_mem 'y
      $((exists x (((eVar x) C= Exps) /\ (and (eVar x) (forall a (((eVar a) C= Vars) -> (forall b (((eVar b) C= Vars) -> (forall plug1 (((eVar plug1) C= Exps) -> (forall plug2 (((eVar plug2) C= Exps) -> (imp (and (~ ((eVar a) C= ((sym supp_sym) @@ (eVar plug2)))) (_neq (eVar a) (eVar b))) ((subst (eVar b) (subst (eVar a) (eVar x) (eVar plug1)) (eVar plug2)) == (subst (eVar a) (subst (eVar b) (eVar x) (eVar plug2)) (subst (eVar b) (eVar plug1) (eVar plug2)))))))))))))))))$
    )) @ membership_intro_implicit @ rsyl (subset_to_imp phi_exp) @ eq_to_intro subst_induction_lemma)
    a_fresh) diff_atoms_ab
    ));
