import "core.mm1";

term Var_sym: Symbol;
def Var: Pattern = $ sym Var_sym $;
def Vars: Pattern = $ dom Var $;
def is_var (p: Pattern): Pattern = $ is_of_sort p Var $;
axiom Var_atom: $ is_atom_sort Var $;

term Exp_sym: Symbol;
def Exp: Pattern = $ sym Exp_sym $;
def Exps: Pattern = $ dom Exp $;
def is_exp (p: Pattern): Pattern = $ is_of_sort p Exp $;
axiom Exp_sort: $ is_nominal_sort Exp $;

term lc_var_sym: Symbol;
def lc_var (phi: Pattern): Pattern = $ (sym lc_var_sym) @@ phi $;
axiom function_lc_var: $ ,(is_function '(sym lc_var_sym) '[Var] 'Exp) $;

term lc_app_sym: Symbol;
def lc_app (phi rho: Pattern): Pattern = $ (sym lc_app_sym) @@ phi @@ rho $;
axiom function_lc_app: $ ,(is_function '(sym lc_var_app) '[Exp Exp] 'Exp) $;

term lc_lam_sym: Symbol;
def lc_lam (phi: Pattern): Pattern = $ (sym lc_lam_sym) @@ phi $;
def lc_lam_a {a: EVar} (p: Pattern a): Pattern a = $ lc_lam (abstraction (eVar a) p) $;
axiom function_lc_lam: $ ,(is_function '(sym lc_lam_sym) '[(sort_abstraction Var Exp)] 'Exp) $;
axiom EV_lc_lam {a b: EVar} (phi: Pattern a b):
  $ (is_of_sort phi (sort_abstraction Var Exp)) ->
    (s_forall Var a (s_forall Var b ((swap a b (lc_lam phi)) == lc_lam (swap a b phi)))) $;

axiom no_junk {X: SVar}:
  $ Exps == mu X ( (lc_var Vars)
                \/ (lc_app (sVar X) (sVar X))
                \/ (lc_lam (abstraction Vars (sVar X)))) $;

--- no_confusion

theorem abstraction_sorting_lemma:
  $ is_of_sort (abstraction Vars Exps) (sort_abstraction Var Exp) $ =
  (named '(
    under_domain_forall
      ,(pointwise_decomposition_imp_subst 'appCtxRVar)
      ,(pointwise_decomposition_imp_subst 'appCtxLRVar) @
    under_domain_forall (
    under_domain_forall domain_func_sorting id
    ) id @
    function_abstraction Var_atom Exp_sort));

theorem abstraction_sorting (phi rho: Pattern):
  $ is_var phi -> is_exp rho -> is_of_sort (abstraction phi rho) (sort_abstraction Var Exp) $ =
  (named '(
    rsyl ,(framing_imp_subst 'appCtxLRVar) @
    rsyl subset_trans @
    imim ,(framing_imp_subst 'appCtxRVar) @
    com12 subset_trans abstraction_sorting_lemma));

theorem EV_lc_lam_abstraction {a b: EVar} (phi: Pattern a b):
  $ is_exp phi ->
    ((is_var (eVar a)) /\ (is_var (eVar b))) ->
    ((swap a b (lc_lam_a a phi)) == lc_lam_a b (swap a b phi)) $ =
  (named '(exp @
    sylc eq_trans (
      rsyl (anr anass) @
      curry @
      rsyl (iand (impcom abstraction_sorting) anr) @
      curry @
      --- unquantification of EV_lc_lam
      rsyl EV_lc_lam @
      rsyl var_subst_same_var @
      imim2i var_subst_same_var
    ) ( sylc eq_trans (
      syl ,(eq_imp_eq_framing_subst 'appCtxRVar) @
      rsyl (anr anass) @
      curry @
      rsyl (iand anr id) @
      rsyl (anr anass) @
      curry @
      curry @
      --- unquantification of EV_abstraction
      rsyl (EV_abstraction Var_atom Exp_sort) @
      imim2 @
      rsyl var_subst_same_var @
      imim2 var_subst_same_var
    ) (
      rsyl anr @
      syl ,(eq_imp_eq_framing_subst 'appCtxRLRVar) @
      curry @
      S3 Var_atom
    ))
  ));


theorem exp_pred_ev_unquantified {x y: EVar} (exp_pred: Pattern)
  (exp_pred_ev: $ EV_pattern Var exp_pred $):
  $ (is_var (eVar x)) /\ (is_var (eVar y)) -> ((swap x y exp_pred) == exp_pred) $ =
  '(curry @ syl var_subst_same_var @ var_subst_same_var exp_pred_ev);

theorem lc_lemma_1 {x: EVar} (exp_pred exp_suff_fresh: Pattern)
  (exp_suff_fresh_sorting: $ is_var exp_suff_fresh $)
  (exp_suff_fresh_nonempty: $ |^ exp_suff_fresh ^| $)
  (h_abs: $ (lc_lam (abstraction exp_suff_fresh exp_pred)) C= exp_pred $):
  $ s_exists Var x ((lc_lam_a x exp_pred) C= exp_pred) $ =
  (named '(exists_framing (rsyl (anl eVar_in_subset) @ iand
    (com12 subset_trans exp_suff_fresh_sorting)
    (rsyl (syl
        ,(subset_imp_subset_framing_subst 'appCtxRVar)
        ,(subset_imp_subset_framing_subst 'appCtxLRVar)
      ) @ com12 subset_trans h_abs))
    @ anl lemma_ceil_exists_membership exp_suff_fresh_nonempty));

theorem lc_lemma_2 {x y: EVar} (exp_pred: Pattern)
  (exp_pred_sorting: $ is_exp exp_pred $)
  (exp_pred_ev: $ EV_pattern Var exp_pred $):
  $ (((is_var (eVar x)) /\ (is_var (eVar y))) /\ ((lc_lam_a y exp_pred) C= exp_pred)) -> ((lc_lam_a x exp_pred) C= exp_pred) $ =
  (named '(
    rsyl (anim2 ,(subset_imp_subset_framing_subst 'appCtxRVar)) @
    rsyl (iand anl @ 
            rsyl (anim1 @
              rsyl ancom @
              rsyl (EV_lc_lam_abstraction exp_pred_sorting) @
              syl eq_imp_subset eq_sym) @
            curry subset_trans) @
    rsyl (anim1 @ rsyl ancom @ exp_pred_ev_unquantified exp_pred_ev) @
    curry @
    syl anl ,(func_subst_explicit_helper 'hole $(_ @@ (_ @@ (eVar hole))) C= (eVar hole)$)));

theorem lc_lemma_3 {y: EVar} (exp_pred: Pattern)
  (exp_pred_sorting: $ is_exp exp_pred $)
  (exp_suff_fresh_sorting: $ is_var exp_suff_fresh $)
  (exp_suff_fresh_nonempty: $ |^ exp_suff_fresh ^| $)
  (exp_pred_ev: $ EV_pattern Var exp_pred $)
  (h_abs: $ (lc_lam (abstraction exp_suff_fresh exp_pred)) C= exp_pred $):
  $ is_var (eVar y) -> ((lc_lam_a y exp_pred) C= exp_pred) $ =
  (named '(
    rsyl (ian2 @ lc_lemma_1 exp_suff_fresh_sorting exp_suff_fresh_nonempty h_abs) @
    rsyl and_exists_disjoint_reverse @
    exists_generalization_disjoint @
    rsyl (anr anass) @
    lc_lemma_2 exp_pred_sorting exp_pred_ev));
 
theorem freshness_irrelevance (exp_pred exp_suff_fresh: Pattern)
  (exp_pred_sorting: $ is_exp exp_pred $)
  (exp_suff_fresh_sorting: $ is_var exp_suff_fresh $)
  (exp_suff_fresh_nonempty: $ |^ exp_suff_fresh ^| $)
  (exp_pred_ev: $ EV_pattern Var exp_pred $)
  (h_abs: $ (lc_lam (abstraction exp_suff_fresh exp_pred)) C= exp_pred $):
  $ (lc_lam (abstraction Vars exp_pred)) C= exp_pred $ = (named
  '(norm (norm_subset appCtxRLRVar norm_refl) @
    pointwise_decomposition @
    norm (norm_sym @ norm_imp_r @ norm_subset appCtxRLRVar norm_refl) @
    rsyl (anl eVar_in_subset) @
    lc_lemma_3 exp_pred_sorting exp_suff_fresh_sorting exp_suff_fresh_nonempty exp_pred_ev h_abs));

theorem induction_principle (exp_pred exp_suff_fresh: Pattern)
  (exp_suff_fresh_sorting: $ is_var exp_suff_fresh $)
  (exp_suff_fresh_nonempty: $ |^ exp_suff_fresh ^| $)
  (exp_pred_sorting: $ is_exp exp_pred $)
  (exp_pred_ev: $ EV_pattern Var exp_pred $)
  (h_var: $ (lc_var Vars) C= exp_pred $)
  (h_app: $ (lc_app exp_pred exp_pred) C= exp_pred $)
  (h_abs: $ (lc_lam (abstraction exp_suff_fresh exp_pred)) C= exp_pred $):
  $ Exps == exp_pred $ = (named '(subset_to_eq (imp_to_subset @
    rsyl (corollary_57_floor @ eq_imp_subset no_junk) @
    KT_subst
      (positive_in_or (positive_in_or positive_disjoint @ positive_in_app (positive_in_app positive_disjoint positive_in_same_sVar) positive_in_same_sVar) @ positive_in_app positive_disjoint @ positive_in_app positive_disjoint positive_in_same_sVar)
      ,(propag_s_subst_adv 'X $a \/ (app (app a (sVar X)) (sVar X)) \/ (app a (app a (sVar X)))$ (atom-map! '[a #t])) @
      eori (eori
        (corollary_57_floor h_var)
        (corollary_57_floor h_app))
        @ corollary_57_floor @ freshness_irrelevance exp_pred_sorting exp_suff_fresh_sorting exp_suff_fresh_nonempty exp_pred_ev h_abs
  ) exp_pred_sorting));


term subst_sym: Symbol;
def subst (phi1 phi2 phi3: Pattern): Pattern = $ (sym subst_sym) @@ phi1 @@ phi2 @@ phi3 $;

axiom function_subst: $ ,(is_function '(sym subst_sym) '[Exp Var Exp] 'Exp) $;
axiom subst_same_var {a: EVar} (plug: Pattern a):
  $ (is_var (eVar a)) ->
    (is_exp plug) ->
    ((subst (lc_var (eVar a)) (eVar a) plug) == plug) $;
axiom subst_diff_var {a b: EVar} (plug: Pattern a b):
  $ (is_var (eVar a)) ->
    (is_var (eVar b)) ->
    (is_exp plug) ->
    ((subst (lc_var (eVar a)) (eVar b) plug) == (lc_var (eVar a))) $;
axiom subst_app {a: EVar} (plug phi1 phi2: Pattern a):
  $ (is_var (eVar a)) ->
    (is_exp plug) ->
    (is_exp phi1) ->
    (is_exp phi2) ->
    ((subst (lc_app phi1 phi2) (eVar a) plug) == (lc_app (subst phi1 (eVar a) plug) (subst phi2 (eVar a) plug))) $;
axiom subst_lam {a b: EVar} (plug phi: Pattern a b):
  $ (is_var (eVar a)) ->
    (is_var (eVar b)) ->
    (is_exp plug) ->
    (is_exp phi) ->
    (plug C= freshness a) ->
    ((subst (lc_lam_a a phi) (eVar b) plug) == (lc_lam_a a (subst phi (eVar b) plug))) $;
