import "core.mm1";

term Var_sym: Symbol;
def Var: Pattern = $ sym Var_sym $;
def Vars: Pattern = $ dom Var $;
def is_var (p: Pattern): Pattern = $ is_of_sort p Var $;
axiom Var_atom: $ is_atom_sort Var $;

term Exp_sym: Symbol;
def Exp: Pattern = $ sym Exp_sym $;
def Exps: Pattern = $ dom Exp $;
def is_exp (p: Pattern): Pattern = $ is_of_sort p Exp $;
axiom Exp_sort: $ is_nominal_sort Exp $;

term lc_var_sym: Symbol;
def lc_var (phi: Pattern): Pattern = $ (sym lc_var_sym) @@ phi $;
axiom function_lc_var: $ ,(is_function '(sym lc_var_sym) '[Var] 'Exp) $;

term lc_app_sym: Symbol;
def lc_app (phi rho: Pattern): Pattern = $ (sym lc_app_sym) @@ phi @@ rho $;
axiom function_lc_app: $ ,(is_function '(sym lc_var_app) '[Exp Exp] 'Exp) $;

term lc_lam_sym: Symbol;
def lc_lam (phi: Pattern): Pattern = $ (sym lc_lam_sym) @@ phi $;
def lc_lam_a {a: EVar} (p: Pattern a): Pattern a = $ lc_lam (abstraction (eVar a) p) $;
axiom function_lc_lam: $ ,(is_function '(sym lc_lam_sym) '[(sort_abstraction Var Exp)] 'Exp) $;
axiom EV_lc_lam {a b: EVar} (phi: Pattern a b):
  $ (is_of_sort phi (sort_abstraction Var Exp)) ->
    (s_forall Var a (s_forall Var b ((swap a b (lc_lam phi)) == lc_lam (swap a b phi)))) $;

axiom no_junk {X: SVar}:
  $ Exps == mu X ( (lc_var Vars)
                \/ (lc_app (sVar X) (sVar X))
                \/ (lc_lam (abstraction Vars (sVar X)))) $;

--- no_confusion

do {
  (def (subst_at_depth n) (if {n = 0} 'appCtxVar @ if {n = 1} 'appCtxRVar '(norm_trans appCtxL_disjoint @ norm_app ,(subst_at_depth {n - 1}) norm_refl)))
  (def (uncurry_n n) (if {n < 2} 'id '(rsyl (anl impexp) @ imim2 ,(uncurry_n {n - 1}))))
  (def (function_sorting_full n) (if {n = 0} 'domain_func_sorting '(syl ,(pointwise_decomposition_imp_subst (subst_at_depth n)) @ forall_framing @ imim2 ,(function_sorting_full {n - 1}))))
  (def (function_sorting_lemma n pf) (if {n = 0} pf @
    if {n = 1} '(rsyl ,(subset_imp_subset_framing_subst 'appCtxRVar) (mp (com12 subset_trans) ,pf))
    '(syl (curry subset_trans) @ anim ,(subset_imp_subset_framing_subst (subst_at_depth n)) ,(function_sorting_lemma {n - 1} pf))))
  (def (function_sorting n function_pf) '(mp ,(uncurry_n n) ,(function_sorting_lemma n '(mp ,(function_sorting_full n) ,function_pf)))) 
};

theorem abstraction_sorting_full:
  $ is_of_sort (abstraction Vars Exps) (sort_abstraction Var Exp) $ =
  (named '(mp ,(function_sorting_full 2) @
    function_abstraction Var_atom Exp_sort));

theorem abstraction_sorting (phi rho: Pattern):
  $ is_var phi -> is_exp rho -> is_of_sort (abstraction phi rho) (sort_abstraction Var Exp) $ =
  (named (function_sorting 2 '(function_abstraction Var_atom Exp_sort)));

theorem EV_lc_lam_abstraction {a b: EVar} (phi: Pattern a b):
  $ is_exp phi ->
    ((is_var (eVar a)) /\ (is_var (eVar b))) ->
    ((swap a b (lc_lam_a a phi)) == lc_lam_a b (swap a b phi)) $ =
  (named '(exp @
    sylc eq_trans (
      rsyl (anr anass) @
      curry @
      rsyl (iand (impcom abstraction_sorting) anr) @
      curry @
      --- unquantification of EV_lc_lam
      rsyl EV_lc_lam @
      rsyl var_subst_same_var @
      imim2i var_subst_same_var
    ) ( sylc eq_trans (
      syl ,(eq_imp_eq_framing_subst 'appCtxRVar) @
      rsyl (anr anass) @
      curry @
      rsyl (iand anr id) @
      rsyl (anr anass) @
      curry @
      curry @
      --- unquantification of EV_abstraction
      rsyl (EV_abstraction Var_atom Exp_sort) @
      imim2 @
      rsyl var_subst_same_var @
      imim2 var_subst_same_var
    ) (
      rsyl anr @
      syl ,(eq_imp_eq_framing_subst 'appCtxRLRVar) @
      curry @
      S3 Var_atom
    ))
  ));


theorem exp_pred_ev_unquantified {x y: EVar} (exp_pred: Pattern)
  (exp_pred_ev: $ EV_pattern Var exp_pred $):
  $ (is_var (eVar x)) /\ (is_var (eVar y)) -> ((swap x y exp_pred) == exp_pred) $ =
  '(curry @ syl var_subst_same_var @ var_subst_same_var exp_pred_ev);

theorem lc_lemma_1 {x: EVar} (exp_pred exp_suff_fresh: Pattern)
  (exp_suff_fresh_sorting: $ is_var exp_suff_fresh $)
  (exp_suff_fresh_nonempty: $ |^ exp_suff_fresh ^| $)
  (h_abs: $ (lc_lam (abstraction exp_suff_fresh exp_pred)) C= exp_pred $):
  $ s_exists Var x ((lc_lam_a x exp_pred) C= exp_pred) $ =
  '(exists_framing (rsyl (anl eVar_in_subset) @ iand
    (com12 subset_trans exp_suff_fresh_sorting)
    (rsyl (syl
        ,(subset_imp_subset_framing_subst 'appCtxRVar)
        ,(subset_imp_subset_framing_subst 'appCtxLRVar)
      ) @ com12 subset_trans h_abs))
    @ anl lemma_ceil_exists_membership exp_suff_fresh_nonempty);

theorem lc_lemma_2 {x y: EVar} (exp_pred: Pattern)
  (exp_pred_sorting: $ is_exp exp_pred $)
  (exp_pred_ev: $ EV_pattern Var exp_pred $):
  $ (((is_var (eVar x)) /\ (is_var (eVar y))) /\ ((lc_lam_a y exp_pred) C= exp_pred)) -> ((lc_lam_a x exp_pred) C= exp_pred) $ =
  '(
    rsyl (anim2 ,(subset_imp_subset_framing_subst 'appCtxRVar)) @
    rsyl (iand anl @ 
            rsyl (anim1 @
              rsyl ancom @
              rsyl (EV_lc_lam_abstraction exp_pred_sorting) @
              syl eq_imp_subset eq_sym) @
            curry subset_trans) @
    rsyl (anim1 @ rsyl ancom @ exp_pred_ev_unquantified exp_pred_ev) @
    curry @
    syl anl ,(func_subst_explicit_helper 'hole $(_ @@ (_ @@ (eVar hole))) C= (eVar hole)$));

theorem lc_lemma_3 {y: EVar} (exp_pred: Pattern)
  (exp_pred_sorting: $ is_exp exp_pred $)
  (exp_suff_fresh_sorting: $ is_var exp_suff_fresh $)
  (exp_suff_fresh_nonempty: $ |^ exp_suff_fresh ^| $)
  (exp_pred_ev: $ EV_pattern Var exp_pred $)
  (h_abs: $ (lc_lam (abstraction exp_suff_fresh exp_pred)) C= exp_pred $):
  $ is_var (eVar y) -> ((lc_lam_a y exp_pred) C= exp_pred) $ =
  (named '(
    rsyl (ian2 @ lc_lemma_1 exp_suff_fresh_sorting exp_suff_fresh_nonempty h_abs) @
    rsyl and_exists_disjoint_reverse @
    exists_generalization_disjoint @
    rsyl (anr anass) @
    lc_lemma_2 exp_pred_sorting exp_pred_ev));
 
theorem freshness_irrelevance (exp_pred exp_suff_fresh: Pattern)
  (exp_pred_sorting: $ is_exp exp_pred $)
  (exp_suff_fresh_sorting: $ is_var exp_suff_fresh $)
  (exp_suff_fresh_nonempty: $ |^ exp_suff_fresh ^| $)
  (exp_pred_ev: $ EV_pattern Var exp_pred $)
  (h_abs: $ (lc_lam (abstraction exp_suff_fresh exp_pred)) C= exp_pred $):
  $ (lc_lam (abstraction Vars exp_pred)) C= exp_pred $ = (named
  '(norm (norm_subset appCtxRLRVar norm_refl) @
    pointwise_decomposition @
    norm (norm_sym @ norm_imp_r @ norm_subset appCtxRLRVar norm_refl) @
    rsyl (anl eVar_in_subset) @
    lc_lemma_3 exp_pred_sorting exp_suff_fresh_sorting exp_suff_fresh_nonempty exp_pred_ev h_abs));

theorem induction_principle (exp_pred exp_suff_fresh: Pattern)
  (exp_suff_fresh_sorting: $ is_var exp_suff_fresh $)
  (exp_suff_fresh_nonempty: $ |^ exp_suff_fresh ^| $)
  (exp_pred_sorting: $ is_exp exp_pred $)
  (exp_pred_ev: $ EV_pattern Var exp_pred $)
  (h_var: $ (lc_var Vars) C= exp_pred $)
  (h_app: $ (lc_app exp_pred exp_pred) C= exp_pred $)
  (h_abs: $ (lc_lam (abstraction exp_suff_fresh exp_pred)) C= exp_pred $):
  $ Exps == exp_pred $ = (named '(subset_to_eq (imp_to_subset @
    rsyl (corollary_57_floor @ eq_imp_subset no_junk) @
    KT_subst
      (positive_in_or (positive_in_or positive_disjoint @ positive_in_app (positive_in_app positive_disjoint positive_in_same_sVar) positive_in_same_sVar) @ positive_in_app positive_disjoint @ positive_in_app positive_disjoint positive_in_same_sVar)
      ,(propag_s_subst_adv 'X $a \/ (app (app a (sVar X)) (sVar X)) \/ (app a (app a (sVar X)))$ (atom-map! '[a #t])) @
      eori (eori
        (corollary_57_floor h_var)
        (corollary_57_floor h_app))
        @ corollary_57_floor @ freshness_irrelevance exp_pred_sorting exp_suff_fresh_sorting exp_suff_fresh_nonempty exp_pred_ev h_abs
  ) exp_pred_sorting));



---- Substitution

-- base term and definition
term subst_sym: Symbol;
def subst (a phi1 phi2: Pattern): Pattern = $ (sym subst_sym) @@ a @@ phi1 @@ phi2 $;

-- subst axioms
axiom function_subst: $ ,(is_function '(sym subst_sym) '[Var Exp Exp] 'Exp) $;
axiom subst_same_var {a: EVar} (plug: Pattern a):
  $ (is_var (eVar a)) ->
    (is_exp plug) ->
    ((subst (eVar a) (lc_var (eVar a)) plug) == plug) $;
axiom subst_diff_var {a b: EVar} (plug: Pattern a b):
  $ (is_var (eVar a)) ->
    (is_var (eVar b)) ->
    ((eVar a) != (eVar b)) -> 
    (is_exp plug) ->
    ((subst (eVar b) (lc_var (eVar a)) plug) == (lc_var (eVar a))) $;
axiom subst_var {a b: EVar} (plug: Pattern a b):
  $ (is_var (eVar a)) ->
    (is_var (eVar b)) ->
    ((eVar a) == (eVar b)) -> 
    (is_exp plug) ->
    ((subst (eVar b) (lc_var (eVar a)) plug) == plug) $;
axiom subst_app (a phi1 phi2 plug: Pattern):
  $ (is_sorted_func Var a) ->
    (is_exp plug) ->
    (is_exp phi1) ->
    (is_exp phi2) ->
    ((subst a (lc_app phi1 phi2) plug) == (lc_app (subst a phi1 plug) (subst a phi2 plug))) $;
axiom subst_lam_same_var {a: EVar} (plug phi: Pattern a):
  $ (is_var (eVar a)) ->
    (is_exp plug) ->
    (is_exp phi) ->
    (fresh_for (eVar a) plug) ->
    ((subst (eVar a) (lc_lam_a a phi) plug) == (lc_lam_a a phi)) $;
axiom subst_lam_diff_var (a b plug phi: Pattern):
  $ (a != b) ->
    (fresh_for a plug) ->
    (is_sorted_func Var a) ->
    (is_sorted_func Var b) ->
    (is_exp plug) ->
    (is_exp phi) ->
    ((subst b (lc_lam (abstraction a phi)) plug) == (lc_lam (abstraction a (subst b phi plug)))) $;
axiom subst_lam {a b: EVar} (plug phi: Pattern a b):
  $ ((eVar a) == (eVar b)) ->
    (is_var (eVar a)) ->
    (is_var (eVar b)) ->
    (is_exp plug) ->
    (is_exp phi) ->
    (fresh_for (eVar a) plug) ->
    ((subst (eVar b) (lc_lam_a a phi) plug) == (lc_lam_a a phi)) $;


-- induction proof
def subst_induction_pred (a b phi plug1 plug2: Pattern): Pattern = $ (subst b (subst a phi plug1) plug2) == (subst a (subst b phi plug2) (subst b plug1 plug2)) $;
def satisfying_exps {.x: EVar} (a b plug1 plug2: Pattern): Pattern = $ s_exists Exp x ((eVar x) /\ subst_induction_pred a b (eVar x) plug1 plug2) $;

theorem subst_induction_app_lemma
  (a_var: $ is_sorted_func Var a $)
  (b_var: $ is_sorted_func Var b $)
  (plug1_exp: $ is_exp plug1 $)
  (plug2_exp: $ is_exp plug2 $):
  $ (is_exp (eVar x) /\ subst_induction_pred a b (eVar x) plug1 plug2) /\ (is_exp (eVar y) /\ subst_induction_pred a b (eVar y) plug1 plug2) -> subst_induction_pred a b (lc_app (eVar x) (eVar y)) plug1 plug2 $ =
  (named '(rsyl (anl an4) @ rsyl (anim2 @
    syl (curry eq_trans) @
    iand
      (rsyl anl @ eq_equiv_to_eq_eq ,(func_subst_explicit_helper 'z $_ @@ (eVar z) @@ _$))
      (rsyl anr @ eq_equiv_to_eq_eq ,(func_subst_explicit_helper 'z $_ @@ (eVar z)$))
  ) @
  rsyl (anim1 @ iand id id) @
  rsyl (anl anass) @
  rsyl (anim2 @ anim1 @ syl (curry @ subst_app b_var plug2_exp) (anim
    (mp (com12 @ mp ,(function_sorting 3 'function_subst) (domain_func_sorting a_var)) plug1_exp)
    (mp (com12 @ mp ,(function_sorting 3 'function_subst) (domain_func_sorting a_var)) plug1_exp)
    )) @
  rsyl (anim2 @ curry eq_trans) @
  rsyl (anim1 @ iand id id) @
  rsyl (anl anass) @
  rsyl (anim2 @ anim1 @ syl ,(eq_imp_eq_framing_subst 'appCtxLRVar) @ curry @ subst_app a_var plug1_exp) @
  rsyl (anim2 @ curry eq_trans) @
  rsyl (anim1 @ iand id id) @
  rsyl (anl anass) @
  rsyl (anim2 @ anim1 @ syl eq_sym @ syl (curry @ subst_app a_var (mp (mp (mp ,(function_sorting 3 'function_subst) (domain_func_sorting b_var)) plug1_exp) plug2_exp)) (anim
    (mp (com12 @ mp ,(function_sorting 3 'function_subst) (domain_func_sorting b_var)) plug2_exp)
    (mp (com12 @ mp ,(function_sorting 3 'function_subst) (domain_func_sorting b_var)) plug2_exp)
    )) @
  rsyl (anim2 @ impcom eq_trans) @
  rsyl (anim1 @ iand id id) @
  rsyl (anl anass) @
  rsyl (anim2 @ anim1 @ syl eq_sym @ syl ,(eq_imp_eq_framing_subst 'appCtxLRVar) @ curry @ subst_app b_var plug2_exp) @
  rsyl (anim2 @ impcom eq_trans) @
  anr));

theorem subst_induction_app (a b plug1 plug2: Pattern)
  (lemma: $ (is_exp (eVar x) /\ subst_induction_pred a b (eVar x) plug1 plug2) /\ (is_exp (eVar y) /\ subst_induction_pred a b (eVar y) plug1 plug2) -> subst_induction_pred a b (lc_app (eVar x) (eVar y)) plug1 plug2 $):
  $ (lc_app (satisfying_exps a b plug1 plug2) (satisfying_exps a b plug1 plug2)) C= (satisfying_exps a b plug1 plug2) $ =
  (named '(imp_to_subset @
    rsyl (anl ,(ex_appCtx_subst 'appCtxLRVar)) @
    exists_generalization_disjoint @
    rsyl (anl ,(ex_appCtx_subst 'appCtxRVar)) @
    exists_generalization_disjoint @
    rsyl ,(appCtx_floor_commute_b_subst 'appCtxLRVar) @
    rsyl (anim1 @ iand id id) @
    rsyl (anl anass) @
    rsyl (anim2 @
      rsyl (anim2 ,(appCtx_floor_commute_subst 'appCtxLRVar)) @
      rsyl (anim2 ancom) @
      rsyl (anr anass) @
      rsyl (anim2 @
        rsyl ,(appCtx_floor_commute_b_subst 'appCtxRVar) @
        rsyl (anim1 @ iand id id) @
        rsyl (anl anass) @
        anim2 @
        rsyl (anim2 ,(appCtx_floor_commute_subst 'appCtxRVar)) @
        rsyl (anim2 ancom) @
        anr anass
        ) @
      rsyl (anl anlass) @
      anim2 @
      anr anass) @
    rsyl (anr anass) @
    rsyl (anim2 @ anim1 lemma) @
    rsyl (anim2 @ ancom) @
    rsyl (anim1 @ curry @ mp ,(inst_foralls 2) function_lc_app) @
    curry ,(func_subst_alt_thm_sorted 'x $(eVar x) /\ ((app (app _ (app (app _ (eVar x)) _)) _) == (app (app _ (app (app _ (eVar x)) _)) _))$)
    ));

-- (lam c phi)[a / plug1][b / plug2] == lam

theorem subst_induction_lam_lemma (a b c plug1 plug2: Pattern)
  (diff_atoms_ab: $ a != b $)
  (diff_atoms_bc: $ b != c $)
  (diff_atoms_ca: $ c != a $)
  (a_var: $ is_sorted_func Var a $)
  (b_var: $ is_sorted_func Var b $)
  (c_var: $ is_sorted_func Var c $)
  (c_fresh_in_plug1: $ fresh_for c plug1 $)
  (phi_exp: $ is_exp phi $)
  (plug1_exp: $ is_exp plug1 $)
  (plug2_exp: $ is_exp plug2 $)
  (a_fresh: $ fresh_for a plug2 $):
  $ is_exp (eVar x) /\ subst_induction_pred a b (eVar x) plug1 plug2 -> subst_induction_pred a b (lc_lam (abstraction c (eVar x))) plug1 plug2 $ =
  '(rsyl (anim1 @ iand id id) @
    rsyl (anl anass) @
    rsyl (anim2 @ anim1 @ syl (subst_lam_diff_var diff_atoms_ca c_fresh_in_plug1 c_var a_var plug1_exp) @ rsyl (mp ,(function_sorting 2 '(function_abstraction Var_atom Exp_sort)) (domain_func_sorting c_var)) ,(function_sorting 1 'function_lc_lam)) @
    rsyl (anim2 @ _)
    _);

theorem subst_induction_lam (a b c plug1 plug2: Pattern)
  (c_sorting: $ is_sorted_func Var c $)
  (lemma: $ is_exp (eVar x) /\ subst_induction_pred a b (eVar x) plug1 plug2 -> subst_induction_pred a b (lc_lam (abstraction c (eVar x))) plug1 plug2 $):
  $ (lc_lam (abstraction c (satisfying_exps a b plug1 plug2))) C= (satisfying_exps a b plug1 plug2) $ =
  (named '(imp_to_subset @
    rsyl (anl ,(ex_appCtx_subst @ appCtx_constructor '[1 1])) @
    exists_generalization_disjoint @
    rsyl ,(appCtx_floor_commute_b_subst @ appCtx_constructor '[1 1]) @
    rsyl (anim2 ,(appCtx_floor_commute_subst @ appCtx_constructor '[1 1])) @
    rsyl (anim1 @ iand id id) @
    rsyl (anl anass) @
    rsyl (anim2 @ rsyl (anl anlass) @ anim2 lemma) @
    rsyl (anim1 @ rsyl (mp ,(inst_foralls 1) (swap_sorted_forall @ function_abstraction Var_atom Exp_sort))
      (rsyl (con1 @ anr imp_exists_disjoint (exists_framing (syl con3 @ syl anl ,(func_subst_explicit_helper 'x $((eVar x) C= _) -> exists _ (_ /\ (_ == (_ @@ (eVar x) @@ _)))$)) (exists_framing anr c_sorting))) @ rsyl (mpcom @ domain_func_sorting c_sorting) @
        exists_generalization_disjoint @ rsyl (anim1 @ var_subst_same_var function_lc_lam) @ impcom @ syl anl ,(func_subst_explicit_helper 'x $exists _ (_ /\ (_ == (_ @@ (eVar x))))$))
      ) @
    curry ,(func_subst_alt_thm_sorted 'x $(eVar x) /\ ((app (app _ (app (app _ (eVar x)) _)) _) == (app (app _ (app (app _ (eVar x)) _)) _))$)
    ));
  

theorem subst_induction_lemma (a b phi plug1 plug2: Pattern)
  (diff_atoms: $ a != b $)
  (a_var: $ is_sorted_func Var a $)
  (b_var: $ is_sorted_func Var b $)
  (phi_exp: $ is_exp phi $)
  (plug1_exp: $ is_exp plug1 $)
  (plug2_exp: $ is_exp plug2 $)
  (a_fresh: $ fresh_for a plug2 $):
  $ Exps == (satisfying_exps a b plug1 plug2) $ =
  '(induction_principle _ _ _ _ _ (subst_induction_app @ subst_induction_app_lemma a_var b_var plug1_exp plug2_exp) _);

theorem subst_induction (a b phi plug1 plug2: Pattern)
  (diff_atoms: $ a != b $)
  (a_var: $ is_sorted_func Var a $)
  (b_var: $ is_sorted_func Var b $)
  (phi_exp: $ is_exp phi $)
  (plug1_exp: $ is_exp plug1 $)
  (plug2_exp: $ is_exp plug2 $)
  (a_fresh: $ fresh_for a plug2 $):
  $ (subst b (subst a phi plug1) plug2) == (subst a (subst b phi plug2) (subst b plug1 plug2)) $ =
  (named '(mp (
    rsyl (com12 subset_trans @ eq_imp_subset @ subst_induction_lemma diff_atoms a_var b_var phi_exp plug1_exp plug2_exp a_fresh) @
    rsyl (subset_mem_disjoint_lemma eFresh_disjoint) @
    rsyl (forall_framing (rsyl
      (imim2 @ rsyl membership_exists_forward @ exists_generalization_disjoint @ rsyl (anl ,(propag_mem 'x $(_ C= _) /\ ((eVar _) /\ (_ == _))$)) @ rsyl anr (curry @ syl anr ,(func_subst_explicit_helper 'x $(app (app _ (app (app _ (eVar x)) _)) _) == (app (app _ (app (app _ (eVar x)) _)) _)$)))
      (rsyl (imim (anl floor_ceil_ceil) (anr ceil_floor_floor)) @ rsyl prop_43_or_def @ rsyl (anr floor_ceil_ceil) @ framing_floor @ rsyl prop_43_or_def_rev @ imim (anr floor_ceil_ceil) (anl ceil_floor_floor)))) @
    rsyl (anr forall_floor) @
    syl (rsyl
      (eq_trans @ equiv_to_eq ,(appCtx_pointwise_subst @ appCtx_constructor '[0 1 0 1])) @
      com12 eq_trans @ eq_sym @ equiv_to_eq ,(appCtx_pointwise_subst @ appCtx_constructor '[0 1 0 1])) @
    framing_floor @ eq_to_exists_bi_fresh eFresh_forall_same_var @ syl corollary_57_floor @ rsyl var_subst_same_var imp_eq_to_conj_in_eq) phi_exp));
