import "core.mm1";

term Var_sym: Symbol;
def Var: Pattern = $ sym Var_sym $;
def Vars: Pattern = $ dom Var $;
def is_var (p: Pattern): Pattern = $ is_of_sort p Var $;
axiom Var_atom: $ is_atom_sort Var $;

term Exp_sym: Symbol;
def Exp: Pattern = $ sym Exp_sym $;
def Exps: Pattern = $ dom Exp $;
def is_exp (p: Pattern): Pattern = $ is_of_sort p Exp $;
axiom Exp_sort: $ is_nominal_sort Exp $;

term lc_var_sym: Symbol;
def lc_var (phi: Pattern): Pattern = $ (sym lc_var_sym) @@ phi $;
axiom function_lc_var: $ ,(is_function '(sym lc_var_sym) '[Var] 'Exp) $;
axiom EV_lc_var {a b: EVar} (c: Pattern a b):
  $ s_forall Var a (s_forall Var b (
    (is_of_sort c Var) ->
    ((swap (eVar a) (eVar b) (lc_var c)) == lc_var (swap (eVar a) (eVar b) c)))) $;

term lc_app_sym: Symbol;
def lc_app (phi rho: Pattern): Pattern = $ (sym lc_app_sym) @@ phi @@ rho $;
axiom function_lc_app: $ ,(is_function '(sym lc_var_app) '[Exp Exp] 'Exp) $;

term lc_lam_sym: Symbol;
def lc_lam (phi: Pattern): Pattern = $ (sym lc_lam_sym) @@ phi $;
def lc_lam_a (a p: Pattern): Pattern = $ lc_lam (abstraction a p) $;
axiom function_lc_lam: $ ,(is_function '(sym lc_lam_sym) '[(sort_abstraction Var Exp)] 'Exp) $;
axiom EV_lc_lam {a b: EVar} (phi: Pattern a b):
  $ s_forall Var a (s_forall Var b (
    (is_of_sort phi (sort_abstraction Var Exp)) ->
    ((swap (eVar a) (eVar b) (lc_lam phi)) == lc_lam (swap (eVar a) (eVar b) phi)))) $;

axiom no_junk {X: SVar}:
  $ Exps == mu X ( (lc_var Vars)
                \/ (lc_app (sVar X) (sVar X))
                \/ (lc_lam (abstraction Vars (sVar X)))) $;

--- add no_confusion axioms for the symbols
--- add EV axioms for the symbols

do {
  (def (subst_at_depth n) (if {n = 0} 'appCtxVar @ if {n = 1} 'appCtxRVar '(norm_trans appCtxL_disjoint @ norm_app ,(subst_at_depth {n - 1}) norm_refl)))
  (def (uncurry_n n) (if {n < 2} 'id '(rsyl (anl impexp) @ imim2 ,(uncurry_n {n - 1}))))
  (def (function_sorting_full n) (if {n = 0} 'domain_func_sorting '(syl ,(pointwise_decomposition_imp_subst (subst_at_depth n)) @ forall_framing @ imim2 ,(function_sorting_full {n - 1}))))
  (def (function_sorting_lemma n pf) (if {n = 0} pf @
    if {n = 1} '(rsyl ,(imp_subset_framing_subst 'appCtxRVar) (mp (com12 subset_trans) ,pf))
    '(syl (curry subset_trans) @ anim ,(imp_subset_framing_subst (subst_at_depth n)) ,(function_sorting_lemma {n - 1} pf))))
  (def (function_sorting n function_pf) '(mp ,(uncurry_n n) ,(function_sorting_lemma n '(mp ,(function_sorting_full n) ,function_pf)))) 
};

theorem abstraction_sorting_full:
  $ is_of_sort (abstraction Vars Exps) (sort_abstraction Var Exp) $ =
  (named '(mp ,(function_sorting_full 2) @
    function_abstraction Var_atom Exp_sort));

theorem abstraction_sorting (phi rho: Pattern):
  $ is_var phi -> is_exp rho -> is_of_sort (abstraction phi rho) (sort_abstraction Var Exp) $ =
  (named (function_sorting 2 '(function_abstraction Var_atom Exp_sort)));

theorem swap_sorting {a b: EVar} (phi: Pattern a b):
  $ is_var (eVar a) -> is_var (eVar b) -> (is_exp phi) -> (is_exp (swap (eVar a) (eVar b) phi)) $ =
  (named (function_sorting 3 '(function_swap Var_atom Exp_sort)));
theorem swap_sorting_var {a b: EVar} (phi: Pattern a b):
  $ is_var (eVar a) -> is_var (eVar b) -> (is_var phi) -> (is_var (swap (eVar a) (eVar b) phi)) $ =
  (named (function_sorting 3 '(function_swap_atom Var_atom)));

theorem EV_lc_lam_abstraction {a b: EVar} (phi: Pattern a b):
  $ s_forall Var a (s_forall Var b (is_exp phi -> ((swap (eVar a) (eVar b) (lc_lam_a (eVar a) phi)) == lc_lam_a (eVar b) (swap (eVar a) (eVar b) phi)))) $ =
  (named '(
    univ_gene @
    anr imp_forall @
    univ_gene @
    syl (anl impexp) @
    exp @
    rsyl (anr anass) @
    rsyl ancom @
    sylc eq_trans (
      rsyl (anr anass) @
      curry @
      rsyl (iand (impcom abstraction_sorting) anr) @
      curry @
      com12 @
      imim2 (anl com12b) @
      -- unquantification of EV_lc_lam
      var_subst_same_var @
      anl imp_forall @
      var_subst_same_var EV_lc_lam
    )
    ( sylc eq_trans (
      syl ,(imp_eq_framing_subst 'appCtxRVar) @
      rsyl (anr anass) @
      curry @
      rsyl (iand anr id) @
      rsyl (anr anass) @
      curry @
      curry @
      --- unquantification of EV_abstraction
      rsyl (var_subst_same_var @ anl imp_forall @ var_subst_same_var @ EV_abstraction Var_atom Exp_sort) @
      rsyl (imim2 @ anl com12b) @
      rsyl (anl com12b) @
      imim2 @
      anl com12b
    ) (
      rsyl anr @
      syl ,(imp_eq_framing_subst 'appCtxRLRVar) @
      curry @
      var_subst_same_var @
      anl imp_forall @
      var_subst_same_var @
      S3 Var_atom
    ))
  ));

theorem EV_lc_var_lemma {a b: EVar} (phi: Pattern a b):
  $ s_forall Var a (s_forall Var b (is_var phi -> ((swap (eVar a) (eVar b) (lc_var phi)) == lc_var (swap (eVar a) (eVar b) phi)))) $ =
  '(
    univ_gene @
    anr imp_forall @
    univ_gene @
    syl (anl impexp) @
    exp @
    rsyl (anr anass) @
    rsyl ancom @
    rsyl (anr anass) @
    curry @
    curry @
    com12 @
    imim2 (anl com12b) @
    -- unquantification of EV_lc_var
    var_subst_same_var @
    anl imp_forall @
    var_subst_same_var EV_lc_var
    );
  

theorem exp_pred_ev_unquantified {x y: EVar} (exp_pred: Pattern):
  $ EV_pattern Var exp_pred -> (is_var (eVar x)) /\ (is_var (eVar y)) -> ((swap (eVar x) (eVar y) exp_pred) == exp_pred) $ =
  '(rsyl var_subst_same_var @ rsyl (imim2 var_subst_same_var) @ anr impexp);

theorem lc_lemma_1 {x: EVar} (exp_pred exp_suff_fresh: Pattern):
  $ is_var exp_suff_fresh ->
    |^ exp_suff_fresh ^| ->
    ((lc_lam (abstraction exp_suff_fresh exp_pred)) C= exp_pred) ->
    s_exists Var x ((lc_lam_a (eVar x) exp_pred) C= exp_pred) $ =
  '(exp @ exp @
    rsyl (anim1 @ anim2 @ anl lemma_ceil_exists_membership) @
    rsyl (anim1 and_exists_disjoint_reverse) @
    rsyl and_exists_disjoint_r_reverse @
    exists_framing @
    rsyl (anim1 @ iand anr @ rsyl (anim2 @ anl eVar_in_subset) @ impcom subset_trans) @
    rsyl (anl anass) @
    rsyl (anl anlass) @
    anim2 @
    curry @
    syl subset_trans @
    rsyl (anl eVar_in_subset) @
    syl ,(imp_subset_framing_subst 'appCtxRVar)
    ,(imp_subset_framing_subst 'appCtxLRVar));

theorem lc_lmma_1_var {x: EVar} (exp_pred exp_suff_fresh: Pattern):
  $ is_var exp_suff_fresh ->
    |^ exp_suff_fresh ^| ->
    ((lc_var exp_suff_fresh) C= exp_pred) ->
    s_exists Var x ((lc_var (eVar x)) C= exp_pred) $ =
  '(exp @ exp @
    rsyl (anim1 @ anim2 @ anl lemma_ceil_exists_membership) @
    rsyl (anim1 and_exists_disjoint_reverse) @
    rsyl and_exists_disjoint_r_reverse @
    exists_framing @
    rsyl (anim1 @ iand anr @ rsyl (anim2 @ anl eVar_in_subset) @ impcom subset_trans) @
    rsyl (anl anass) @
    rsyl (anl anlass) @
    anim2 @
    curry @
    syl subset_trans @
    rsyl (anl eVar_in_subset)
    ,(imp_subset_framing_subst 'appCtxRVar)
  );

theorem lc_lemma_2 {x y: EVar} (exp_pred: Pattern):
  $ (is_exp exp_pred) ->
    (EV_pattern Var exp_pred) ->
    ((is_var (eVar x)) /\ (is_var (eVar y)) /\ ((lc_lam_a (eVar y) exp_pred) C= exp_pred)) ->
    ((lc_lam_a (eVar x) exp_pred) C= exp_pred) $ =
  '(exp @ exp @
    rsyl (anim2 @ anim2 ,(imp_subset_framing_subst 'appCtxRVar)) @
    rsyl (anim1 ancom) @
    rsyl (anl anass) @
    rsyl (anim2 @ iand (rsyl anr anl) @
      syl (curry subset_trans) @
      rsyl (anr anass) @
      anim1 @
      rsyl (anim2 ancom) @
      rsyl (curry @ com12 @ curry @ var_subst_same_var @ anl imp_forall @ var_subst_same_var EV_lc_lam_abstraction) @
      rsyl eq_sym
      eq_imp_subset) @
    rsyl (anr anass) @
    rsyl (anim1 @ anim2 ancom) @
    rsyl (anim1 @ curry exp_pred_ev_unquantified) @
    curry @
    syl anl ,(func_subst_explicit_helper 'hole $(_ @@ (_ @@ (eVar hole))) C= (eVar hole)$));

theorem lc_lemma_2_var {x y: EVar} (exp_pred: Pattern):
  $ is_var (eVar y) /\ ((lc_var (eVar y)) C= exp_pred) ->
    (EV_pattern Var exp_pred) ->
    (is_var (eVar x)) ->
    ((lc_var (eVar x)) C= exp_pred) $ =
  '(com12 @ exp @ exp @
    rsyl (anl anass) @
    rsyl (anim2 @ rsyl ancom @ anr anass) @
    rsyl (anim2 @ anim2 ,(imp_subset_framing_subst 'appCtxRVar)) @
    rsyl (anim2 @ anim1 @ iand id @ rsyl (anim2 @ iand id id) @ rsyl (anr anass) @ rsyl (anim1 ancom) @ curry @ curry @ var_subst_same_var @ anl imp_forall @ var_subst_same_var EV_lc_var_lemma) @
    rsyl (anim2 @ anl anass) @
    rsyl (anim2 @ anim2 @ anim1 @ rsyl eq_sym eq_imp_subset) @
    rsyl (anim2 @ anim2 @ curry subset_trans) @
    rsyl (anr anass) @
    rsyl (anim1 ancom) @
    rsyl (iand anl id) @
    rsyl (anim2 @ anim1 @ anim1 ancom) @
    rsyl (anim2 @ anim1 @ syl eq_imp_subset @ rsyl (anim2 @ rsyl (syl var_subst_same_var @ syl (anl imp_forall) var_subst_same_var) @ anr impexp) appl) @
    rsyl (anim2 @ impcom subset_trans) @
    rsyl (anim1 @ rsyl anl @ rsyl ancom @ curry @ var_subst_same_var @ anl imp_forall @ var_subst_same_var @ S3 Var_atom) @
    rsyl (anim1 @ rsyl eq_sym eq_imp_subset) @
    rsyl (anim1 ,(imp_subset_framing_subst 'appCtxRVar)) @
    curry subset_trans
    );

theorem lc_lemma_3 {y: EVar} (exp_pred: Pattern):
  $ is_var exp_suff_fresh ->
    |^ exp_suff_fresh ^| ->
    ((lc_lam (abstraction exp_suff_fresh exp_pred)) C= exp_pred) ->
    is_exp exp_pred ->
    EV_pattern Var exp_pred ->
    is_var (eVar y) ->
    ((lc_lam_a (eVar y) exp_pred) C= exp_pred) $ = (named
  '(imim2 (imim2 @ imim2 @
    exp @ rsyl and_exists_disjoint_r_reverse @
    exp @ rsyl and_exists_disjoint_r_reverse @
    exp @ rsyl and_exists_disjoint_r_reverse @
    exists_generalization_disjoint @
    rsyl (anl anass) @
    rsyl (anl anass) @
    rsyl ancom @
    rsyl (anim1 @ anr anass) @
    rsyl (anl anass) @
    rsyl (anim2 @ anr anass) @
    curry @ curry lc_lemma_2
  ) lc_lemma_1));
 
theorem freshness_irrelevance_lam (exp_pred exp_suff_fresh: Pattern):
  $ is_var exp_suff_fresh ->
    |^ exp_suff_fresh ^| ->
    ((lc_lam (abstraction exp_suff_fresh exp_pred)) C= exp_pred) ->
    is_exp exp_pred ->
    EV_pattern Var exp_pred ->
    ((lc_lam (abstraction Vars exp_pred)) C= exp_pred) $ = (named
  '(imim2 (
    rsyl (anr imp_forall) @ imim2 @
    rsyl (anr imp_forall) @ imim2 @
    rsyl (anr imp_forall) @ imim2 @
    rsyl (anr imp_forall) @ imim2
    ,(pointwise_decomposition_imp_subst 'appCtxRLRVar)
    ) @ anr imp_forall @ univ_gene lc_lemma_3));

theorem freshness_irrelevance_var (exp_pred exp_suff_fresh: Pattern):
  $ is_var exp_suff_fresh ->
    |^ exp_suff_fresh ^| ->
    ((lc_var exp_suff_fresh) C= exp_pred) ->
    EV_pattern Var exp_pred ->
    ((lc_var Vars) C= exp_pred) $ =
    (named '(imim2 (imim2 @ imim2 @
      exists_generalization_disjoint @
      imim2 (rsyl (anr imp_forall) @ imim2 ,(pointwise_decomposition_imp_subst 'appCtxRVar)) @ anr imp_forall @ univ_gene lc_lemma_2_var
      ) lc_lmma_1_var));

theorem induction_principle (exp_pred exp_suff_fresh_var exp_suff_fresh_lam: Pattern):
  $ (is_var exp_suff_fresh_var) ->
    |^ exp_suff_fresh_var ^| ->
    (is_var exp_suff_fresh_lam) ->
    |^ exp_suff_fresh_lam ^| ->
    (is_exp exp_pred) ->
    (EV_pattern Var exp_pred) ->
    ((lc_var exp_suff_fresh_var) C= exp_pred) ->
    ((lc_app exp_pred exp_pred) C= exp_pred) ->
    ((lc_lam (abstraction exp_suff_fresh_lam exp_pred)) C= exp_pred) ->
    (Exps == exp_pred) $ =
    (named '(exp @ exp @ exp @ exp @ exp @ exp @ exp @ exp @
      syl (curry subset_to_eq) @
      iand (syl (subset_trans @ eq_imp_subset no_junk) @ rsyl (syl (anr floor_idem) @ 
        rsyl (anim (anim (anim (anim (anim (anim (anim (anim (anr floor_idem) (anr floor_ceil_ceil)) (anr floor_idem)) (anr floor_ceil_ceil)) (anr floor_idem)) (syl (anr forall_floor) @ forall_framing @ syl floor_imp_lemma @ imim2 @ syl (anr forall_floor) @ forall_framing @ syl floor_imp_lemma @ imim2 @ anr floor_idem)) (anr floor_idem)) (anr floor_idem)) (anr floor_idem)) @
        rsyl (anim1 (
        rsyl (anim1 (
        rsyl (anim1 (
        rsyl (anim1 (
        rsyl (anim1 (
        rsyl (anim1 (
        rsyl (anim1 (
        rsyl (anim1 id) @
        anr propag_and_floor)) @
        anr propag_and_floor)) @
        anr propag_and_floor)) @
        anr propag_and_floor)) @
        anr propag_and_floor)) @
        anr propag_and_floor)) @
        anr propag_and_floor)) @
        anr propag_and_floor
      ) @ framing_floor @ com12 @
        KT_subst
          (positive_in_or (positive_in_or positive_disjoint @ positive_in_app (positive_in_app positive_disjoint positive_in_same_sVar) positive_in_same_sVar) @ positive_in_app positive_disjoint @ positive_in_app positive_disjoint positive_in_same_sVar)
          ,(propag_s_subst_adv 'X $a \/ (app (app a (sVar X)) (sVar X)) \/ (app a (app a (sVar X)))$ (atom-map! '[a #t])) @
          eori (eori
          (com12 @ rsyl corollary_57_floor @ syl corollary_57_floor @
            prop_2 (prop_2 (prop_2 (prop_2 (prop_1 freshness_irrelevance_var) an8l) an7lr) anllr) an3lr
          )
          (syl imidm @ imim2 (imim2 @ syl imidm @ imim2 (imim2 @ com12 @ rsyl corollary_57_floor @ syl corollary_57_floor @
            anlr
          )
            ,(ceil_imp_in_appCtx_subst 'appCtxLRVar))
            ,(ceil_imp_in_appCtx_subst 'appCtxRVar)))
          (syl imidm @ imim2 (imim2 @ com12 @ rsyl corollary_57_floor @ syl corollary_57_floor @
            prop_2 (prop_2 (prop_2 (prop_2 (prop_2 (prop_1 freshness_irrelevance_lam) an6lr) an5lr) anr) an4lr) an3lr
          )
            ,(ceil_imp_in_appCtx_subst @ appCtx_constructor '[1 1]))
      )
      an4lr));


---- Substitution

-- base term and definition
term subst_sym: Symbol;
def subst (a phi1 phi2: Pattern): Pattern = $ (sym subst_sym) @@ a @@ phi1 @@ phi2 $;

-- subst axioms
axiom function_subst: $ ,(is_function '(sym subst_sym) '[Var Exp Exp] 'Exp) $;
axiom EV_subst {a b: EVar} (c phi plug: Pattern a b):
  $ s_forall Var a (s_forall Var b (
    (is_var c) ->
    (is_exp phi) ->
    (is_exp plug) ->
    ((swap (eVar a) (eVar b) (subst c phi plug)) == subst (swap (eVar a) (eVar b) c) (swap (eVar a) (eVar b) phi) (swap (eVar a) (eVar b) plug)))) $;
axiom subst_fresh(a phi plug: Pattern):
  $ (is_sorted_func Var a) ->
    (is_exp phi) ->
    (is_exp plug) ->
    (fresh_for a phi) ->
    ((subst a phi plug) == phi) $;
axiom subst_same_var (a plug: Pattern):
  $ (is_sorted_func Var a) ->
    (is_exp plug) ->
    ((subst a (lc_var a) plug) == plug) $;
axiom subst_diff_var (a b plug: Pattern):
  $ (is_sorted_func Var a) ->
    (is_sorted_func Var b) ->
    (a != b) -> 
    (is_exp plug) ->
    ((subst b (lc_var a) plug) == (lc_var a)) $;
axiom subst_var (a b plug: Pattern):
  $ (is_sorted_func Var a) ->
    (is_sorted_func Var b) ->
    (a == b) -> 
    (is_exp plug) ->
    ((subst b (lc_var a) plug) == plug) $;
axiom subst_app (a phi1 phi2 plug: Pattern):
  $ (is_sorted_func Var a) ->
    (is_exp plug) ->
    (is_exp phi1) ->
    (is_exp phi2) ->
    ((subst a (lc_app phi1 phi2) plug) == (lc_app (subst a phi1 plug) (subst a phi2 plug))) $;
-- axiom subst_lam_same_var (a plug phi: Pattern):
--   $ (is_sorted_func Var a) ->
--     (is_exp plug) ->
--     (is_exp phi) ->
--     ((subst a (lc_lam (abstraction a phi)) plug) == (lc_lam (abstraction a phi))) $;
axiom subst_lam (a b plug phi: Pattern):
  $ (a == b) ->
    (is_sorted_func Var a) ->
    (is_sorted_func Var b) ->
    (is_exp plug) ->
    (is_exp phi) ->
    ((subst b (lc_lam (abstraction a phi)) plug) == (lc_lam (abstraction a phi))) $;
axiom subst_lam_diff_var (a b plug phi: Pattern):
  $ (a != b) ->
    (fresh_for a plug) ->
    (is_sorted_func Var a) ->
    (is_sorted_func Var b) ->
    (is_exp plug) ->
    (is_exp phi) ->
    ((subst b (lc_lam (abstraction a phi)) plug) == (lc_lam (abstraction a (subst b phi plug)))) $;

theorem Var_sort: $ is_nominal_sort Var $ =
  '(anim2 (com12 subset_trans atoms_nominal_sorts) Var_atom);

theorem S2_lam {a b: EVar} (phi: Pattern a b):
  $ (is_var (eVar a)) ->
    (is_var (eVar b)) ->
    (is_exp phi) ->
    ((swap (eVar a) (eVar b) (swap (eVar a) (eVar b) phi)) == phi) $ =
  '(mp ,(inst_foralls 2) @ S2 Var_atom Exp_sort);

theorem S2_lam_var {a b: EVar} (phi: Pattern a b):
  $ (is_var (eVar a)) ->
    (is_var (eVar b)) ->
    (is_var phi) ->
    ((swap (eVar a) (eVar b) (swap (eVar a) (eVar b) phi)) == phi) $ =
  '(mp ,(inst_foralls 2) @ S2 Var_atom Var_sort);

theorem EV_supp_lam {a b: EVar} (phi: Pattern a b):
  $ (is_var (eVar a)) ->
    (is_var (eVar b)) ->
    (is_exp phi) ->
    ((swap (eVar a) (eVar b) (supp phi)) == supp (swap (eVar a) (eVar b) phi)) $ =
    '(mp ,(inst_foralls 2) @ EV_supp Var_atom Exp_sort);

theorem EV_subst_lam {a b: EVar} (c phi plug: Pattern a b):
  $ (is_var (eVar a)) ->
    (is_var (eVar b)) ->
    (is_var c) ->
    (is_exp phi) ->
    (is_exp plug) ->
    ((swap (eVar a) (eVar b) (subst c phi plug)) == subst (swap (eVar a) (eVar b) c) (swap (eVar a) (eVar b) phi) (swap (eVar a) (eVar b) plug)) $ =
    '(mp ,(inst_foralls 2) EV_subst);

theorem subst_sorting (c phi plug: Pattern):
  $ (is_var c) ->
    (is_exp phi) ->
    (is_exp plug) ->
    (is_exp (subst c phi plug)) $ =
    (named (function_sorting 3 'function_subst));

-- induction proof
def subst_induction_pred (a b phi plug1 plug2: Pattern): Pattern =
  $ (subst b (subst a phi plug1) plug2) == (subst a (subst b phi plug2) (subst b plug1 plug2)) $;
def satisfying_exps {.x: EVar} (a b plug1 plug2: Pattern): Pattern =
  $ s_exists Exp x ((eVar x) /\ subst_induction_pred a b (eVar x) plug1 plug2) $;
def satisfying_exps2 {.x .a .b .plug1 .plug2: EVar}: Pattern =
  $ s_exists Exp x ((eVar x) /\ s_forall Var a (s_forall Var b (s_forall Exp plug1 (s_forall Exp plug2 ((fresh_for (eVar a) (eVar plug2)) /\ (eVar a != eVar b) -> subst_induction_pred (eVar a) (eVar b) (eVar x) (eVar plug1) (eVar plug2)))))) $;

theorem satisfying_exps2_sorting: $ is_exp satisfying_exps2 $ =
  (named '(imp_to_subset @ rsyl (exists_framing @ rsyl (anr anass) anl) @ syl lemma_62_forward @ exists_framing @ anim1 eVar_in_subset_reverse));

theorem curried_function_swap {a b t: EVar}:
  $ is_var (eVar a) /\ is_var (eVar b) /\ is_exp (eVar t) -> is_sorted_func Exp (swap (eVar a) (eVar b) (eVar t))$ =
  (named '(curry @ curry @ mp ,(inst_foralls 3) @ function_swap Var_atom Exp_sort));
theorem curried_function_swap_atom {a b c: EVar}:
  $ is_var (eVar a) /\ is_var (eVar b) /\ is_var (eVar c) -> is_sorted_func Var (swap (eVar a) (eVar b) (eVar c))$ =
  (named '(curry @ curry @ mp ,(inst_foralls 3) @ function_swap_atom Var_atom));

theorem EV_set: $ EV_pattern Var satisfying_exps2 $ =
  (named '(univ_gene @ anr imp_forall @ univ_gene @ exp @ syl (curry subset_to_eq) @ syl
    (iand anr @ rsyl (anim
        (syl eq_imp_subset @ syl eq_sym @ com12 (curry S2_lam) satisfying_exps2_sorting)
        ,(imp_subset_framing_subst 'appCtxRVar)) @
      curry subset_trans) @
    iand id @
    syl (subset_trans @ imp_to_subset @ anl ,(ex_appCtx_subst 'appCtxRVar)) @
    rsyl (anl floor_of_floor_and) @
    framing_floor @
    exp @
    rsyl and_exists_disjoint_reverse @
    exists_generalization_disjoint @
    rsyl (anim2 ,(appCtx_floor_commute_b_subst 'appCtxRVar)) @
    sylc
      ,(func_subst_alt_thm_sorted 'x $(eVar x) /\ forall _ (_ -> forall _ (_ -> forall _ (_ -> forall _ (_ -> _ -> ((_ @@ _ @@ (_ @@ _ @@ (eVar x) @@ _) @@ _) == (_ @@ _ @@ (_ @@ _ @@ (eVar x) @@ _) @@ _))))))$)
      (rsyl (anim2 anl) curried_function_swap) @
    rsyl (anim2 @ anim2 ,(extract_pred_from_appCtx_r $s_forall _ _ (s_forall _ _ (s_forall _ _ (s_forall _ _ ((~ (_ == _)) /\ (~ (_ == _)) -> (_ == _)))))$ 'appCtxRVar)) @
    rsyl (anim2 @ anl anlass) @
    rsyl (anl anlass) @
    anim2 @
    mp ,(forall_imp_push 1) @ univ_gene @
    mp ,(forall_imp_push 2) @ univ_gene @
    mp ,(forall_imp_push 3) @ univ_gene @
    mp ,(forall_imp_push 4) @ univ_gene @
    expcom @ expcom @ expcom @ expcom @ expcom @
    rsyl (anr anass) @
    rsyl (anr anass) @
    rsyl (anr anass) @
    rsyl (anr anass) @
    rsyl (anr anass) @
    rsyl (anr anass) @
    rsyl (iand anl @ anim1 @ rsyl (iand anllr anlr) @ rsyl ancom curried_function_swap_atom) @
    rsyl (anim2 @ curry
      ,(func_subst_explicit_thm_sorted 'x1 $((eVar x1) C= bot) -> forall y (((eVar y) C= bot) -> forall y (bot -> forall y (bot -> ((~((eVar x1) C= bot)) /\ ~((eVar x1) == bot)) -> ((bot @@ bot @@ (bot @@ (eVar x1) @@ bot @@ bot) @@ bot) == (bot @@ (eVar x1) @@ bot @@ bot)))))$)) @
    rsyl (iand anl @ anim1 @ rsyl (iand an3lr anlr) @ rsyl ancom curried_function_swap_atom) @
    rsyl (anim2 @ curry
      ,(func_subst_explicit_thm_sorted 'x2 $((eVar x2) C= bot) -> forall y (bot -> forall y (bot -> (bot /\ ~(bot == (eVar x2))) -> ((bot @@ (eVar x2) @@ bot @@ bot) == (bot @@ bot @@ (bot @@ (eVar x2) @@ bot @@ bot) @@ (bot @@ (eVar x2) @@ bot @@ bot)))))$)) @
    rsyl (iand anl @ anim1 @ rsyl (iand an4lr anlr) @ rsyl ancom curried_function_swap) @
    rsyl (anim2 @ curry
      ,(func_subst_explicit_thm_sorted 'x3 $((eVar x3) C= bot) -> forall y (bot -> bot -> ((bot @@ bot @@ (bot @@ bot @@ bot @@ (eVar x3)) @@ bot) == (bot @@ bot @@ bot @@ (bot @@ bot @@ (eVar x3) @@ bot))))$)) @
    rsyl (iand anl @ anim1 @ rsyl (iand an5lr anlr) @ rsyl ancom curried_function_swap) @
    rsyl (anim2 @ curry
      ,(func_subst_explicit_thm_sorted 'x4 $((eVar x4) C= bot) -> ((~(bot C= (bot @@ (eVar x4)))) /\ bot) -> ((bot @@ bot @@ bot @@ (eVar x4)) == (bot @@ bot @@ (bot @@ (eVar x4)) @@ (bot @@ bot @@ bot @@ (eVar x4))))$)
      ) @
    curry @
    eimd (iand
      (rsyl
        (iand
          (iand
            (rsyl (iand anlr anllr) @ curry @ curry S2_lam_var)
            (rsyl (iand anlr an5lr) @ iand (curry @ curry S2_lam) (rsyl (iand anl @ curry @ curry swap_sorting) @ curry @ curry EV_supp_lam)))
          an7l) @
        curry @ syl con3 @ exp @
        rsyl (anim2 ,(subset_framing_imp_subst 'appCtxRVar)) @
        rsyl (anim1 @ anim (rsyl eq_sym eq_imp_subset) @ anim (syl ,(subset_framing_imp_subst 'appCtxRVar) eq_imp_subset) eq_imp_subset) @
        rsyl (iand (syl (curry subset_trans) @ iand anll anr) @ rsyl anlr @ rsyl ancom @ curry subset_trans) @
        curry subset_trans)
      (rsyl
        (iand (iand
          (rsyl (iand anlr anllr) @ curry @ curry S2_lam_var)
          (rsyl (iand anlr an3lr) @ curry @ curry S2_lam_var))
          an6lr) @
        curry @ syl con3 @ exp @
        rsyl (anl anass) @
        rsyl (anim eq_sym @ rsyl ancom @ rsyl (anim1 ,(eq_framing_imp_subst 'appCtxRVar)) @ curry eq_trans)
        @ curry eq_trans)) @
    exp @
    rsyl (anim2 ,(eq_framing_imp_subst 'appCtxRVar)) @
    rsyl (iand anl @ syl (curry eq_trans) @
      anim1 @ syl eq_sym @ syl (curry @ curry @ curry @ curry EV_subst_lam) @ iand (iand (iand anlr (syl (curry @ curry swap_sorting_var) @ iand anlr an3lr)) @ syl (curry @ curry subst_sorting) @ iand (iand (syl (curry @ curry swap_sorting_var) @ iand anlr anllr) anr) (syl (curry @ curry swap_sorting) @ iand anlr an4lr)) (syl (curry @ curry swap_sorting) @ iand anlr an5lr)) @
    rsyl (iand anl @ syl (curry eq_trans) @
      anim1 @ syl eq_sym @ syl ,(eq_framing_imp_subst @ appCtx_constructor '[0 0 1]) @ syl (curry @ curry S2_lam_var) @ iand anlr an3lr) @
    rsyl (iand anl @ syl (curry eq_trans) @
      anim1 @ syl eq_sym @ syl ,(eq_framing_imp_subst @ appCtx_constructor '[1]) @ syl (curry @ curry S2_lam) @ iand anlr an5lr) @
    rsyl (iand anl @ syl (curry eq_trans) @
      anim1 @ syl eq_sym @ syl ,(eq_framing_imp_subst @ appCtx_constructor '[0 1]) @ syl (curry @ curry @ curry @ curry EV_subst_lam) @ iand (iand (iand anlr @ syl (curry @ curry swap_sorting_var) @ iand anlr anllr) anr) @ syl (curry @ curry swap_sorting) @ iand anlr an4lr) @
    rsyl (iand anl @ syl (curry eq_trans) @
      anim1 @ syl eq_sym @ syl ,(eq_framing_imp_subst @ appCtx_constructor '[0 1]) @
        syl ,(eq_framing_imp_subst @ appCtx_constructor '[0 0 1]) @ syl (curry @ curry S2_lam_var) @ iand anlr anllr) @
    rsyl (iand anl @ syl (curry eq_trans) @
      anim1 @ syl eq_sym @ syl ,(eq_framing_imp_subst @ appCtx_constructor '[0 1]) @
        syl ,(eq_framing_imp_subst @ appCtx_constructor '[1]) @ syl (curry @ curry S2_lam) @ iand anlr an4lr) @
    curry @
    syl (com12 eq_trans) @
    sylc eq_trans (syl (curry @ curry @ curry @ curry EV_subst_lam) @ iand (iand (iand anlr @ syl (curry @ curry swap_sorting_var) @ iand anlr anllr) @ syl (curry @ curry subst_sorting) @ iand (iand (syl (curry @ curry swap_sorting_var) @ iand anlr an3lr) anr) @ syl (curry @ curry swap_sorting) @ iand anlr an5lr) @ syl (curry @ curry  subst_sorting) @ iand (iand (syl (curry @ curry swap_sorting_var) @ iand anlr an3lr) (syl (curry @ curry swap_sorting) @ iand anlr an4lr)) (syl (curry @ curry swap_sorting) @ iand anlr an5lr)) @
    sylc eq_trans (syl ,(eq_framing_imp_subst @ appCtx_constructor '[0 0 1]) @ syl (curry @ curry S2_lam_var) @ iand anlr anllr) @
    sylc eq_trans (syl ,(eq_framing_imp_subst @ appCtx_constructor '[0 1]) @
      sylc eq_trans
        (syl (curry @ curry @ curry @ curry EV_subst_lam) @ iand4 anlr (syl (curry @ curry swap_sorting_var) @ iand anlr an3lr) anr (syl (curry @ curry swap_sorting) @ iand anlr an5lr)) @
      sylc eq_trans
        (syl ,(eq_framing_imp_subst @ appCtx_constructor '[0 0 1]) @ syl (curry @ curry S2_lam_var) @ iand anlr an3lr)
        (syl ,(eq_framing_imp_subst @ appCtx_constructor '[1]) @ syl (curry @ curry S2_lam) @ iand anlr an5lr)) @
    sylc eq_trans (syl ,(eq_framing_imp_subst @ appCtx_constructor '[1]) @
      sylc eq_trans
        (syl (curry @ curry @ curry @ curry EV_subst_lam) @ iand4 anlr (syl (curry @ curry swap_sorting_var) @ iand anlr an3lr) (syl (curry @ curry swap_sorting) @ iand anlr an4lr) (syl (curry @ curry swap_sorting) @ iand anlr an5lr)) @
      sylc eq_trans
        (syl ,(eq_framing_imp_subst @ appCtx_constructor '[0 0 1]) @ syl (curry @ curry S2_lam_var) @ iand anlr an3lr) @
      sylc eq_trans
        (syl ,(eq_framing_imp_subst @ appCtx_constructor '[0 1]) @ syl (curry @ curry S2_lam) @ iand anlr an4lr)
        (syl ,(eq_framing_imp_subst @ appCtx_constructor '[1]) @ syl (curry @ curry S2_lam) @ iand anlr an5lr)) @
    a1i eq_refl));


theorem case_analysis_lemma:
  $ c -> a \/ (b \/ (c /\ ~a /\ ~b)) $ =
  '(rsyl lemma_60_helper_1 @ rsyl orcom @ orim anr @
    rsyl lemma_60_helper_1 @ rsyl orcom @ orim1 anr);

theorem case_analysis_var {x: EVar} (a b c: Pattern):
  $ (x in c) -> (x in a) \/ ((x in b) \/ (x in (c /\ ~a /\ ~b))) $ =
  '(rsyl (framing_def @ anim2 case_analysis_lemma) @
    rsyl (framing_def @ rsyl (anl andi) @ orim2 @ anl andi) @
    rsyl prop_43_or_def_rev @
    orim2 @
    prop_43_or_def_rev);

theorem func_var_atom
  (a_var: $ is_sorted_func Var a $):
  $ is_sorted_func Exp (lc_var a) $ =
  (named '(mp ,(func_subst 'x $(eVar x C= _) -> exists _ (_ /\ (_ == (_ @@ (eVar x))))$ '(var_subst_same_var function_lc_var) '(exists_framing anr a_var)) @ domain_func_sorting a_var));

theorem subst_induction_var
  (diff_atoms_ab: $ a != b $)
  (a_var: $ is_sorted_func Var a $)
  (b_var: $ is_sorted_func Var b $)
  (plug1_exp: $ is_exp plug1 $)
  (plug2_exp: $ is_exp plug2 $)
  (a_fresh: $ fresh_for a plug2 $):
  $ (lc_var Vars) C= (satisfying_exps a b plug1 plug2) $ =
  '(imp_to_subset @ membership_elim @ forall_framing membership_imp_reverse @
    univ_gene @
    rsyl (! case_analysis_var _ (lc_var a) (lc_var b)) @ eori
      (rsyl ,(func_subst 'x $(_ in (eVar x)) -> (_ == eVar x)$ 'membership_var_forward '(exists_framing anr @ func_var_atom a_var)) @
        syl (anr ,(propag_mem 'x $exists _ ((_ C= _) /\ ((eVar _) /\ (_ == _)))$)) @
        mp ,(func_subst_imp_to_var 'x $exists _ ((_ C= _) /\ ((eVar x == _) /\ (_ == _)))$) @
        mp ,(func_subst_alt 'x $(eVar x C= _) /\ ((_ == eVar x) /\ ((app (app _ (app (app _ (eVar x)) _)) _) == (app (app _ (app (app _ (eVar x)) _)) _)))$ '(exists_framing anr @ func_var_atom a_var)) @
        iani (domain_func_sorting @ func_var_atom a_var) @
        iani eq_refl @
        eq_trans (mp ,(imp_eq_framing_subst 'appCtxLRVar) @ subst_same_var a_var plug1_exp) @
        eq_sym @
        eq_trans (mp ,(imp_eq_framing_subst 'appCtxLRVar) @ subst_diff_var a_var b_var diff_atoms_ab plug2_exp) @
        subst_same_var a_var (mp ,(function_sorting 3 'function_subst) (domain_func_sorting b_var) plug1_exp plug2_exp)
      )
      @ eori
      (rsyl ,(func_subst 'x $(_ in (eVar x)) -> (_ == eVar x)$ 'membership_var_forward '(exists_framing anr @ func_var_atom b_var)) @
        syl (anr ,(propag_mem 'x $exists _ ((_ C= _) /\ ((eVar _) /\ (_ == _)))$)) @
        mp ,(func_subst_imp_to_var 'x $exists _ ((_ C= _) /\ ((eVar x == _) /\ (_ == _)))$) @
        mp ,(func_subst_alt 'x $(eVar x C= _) /\ ((_ == eVar x) /\ ((app (app _ (app (app _ (eVar x)) _)) _) == (app (app _ (app (app _ (eVar x)) _)) _)))$ '(exists_framing anr @ func_var_atom b_var)) @
        iani (domain_func_sorting @ func_var_atom b_var) @
        iani eq_refl @
        eq_trans (mp ,(imp_eq_framing_subst 'appCtxLRVar) @ subst_diff_var b_var a_var (con3 eq_sym diff_atoms_ab) plug1_exp) @
        eq_trans (subst_same_var b_var plug2_exp) @
        eq_sym @
        eq_trans (mp ,(imp_eq_framing_subst 'appCtxLRVar) @ subst_same_var b_var plug2_exp) @
        subst_fresh a_var plug2_exp (mp ,(function_sorting 3 'function_subst) (domain_func_sorting b_var) plug1_exp plug2_exp) a_fresh
      )
      (rsyl eVar_in_subset_forward @
        rsyl (framing_floor @ anl imandi) @
        rsyl (anl propag_and_floor) @
        rsyl (anim1 @ framing_floor @ anl imandi) @
        rsyl (anim1 @ anl propag_and_floor)
        _)
    );

theorem subst_induction_app_lemma
  (a_var: $ is_sorted_func Var a $)
  (b_var: $ is_sorted_func Var b $)
  (plug1_exp: $ is_exp plug1 $)
  (plug2_exp: $ is_exp plug2 $):
  $ (is_exp (eVar x) /\ subst_induction_pred a b (eVar x) plug1 plug2) /\ (is_exp (eVar y) /\ subst_induction_pred a b (eVar y) plug1 plug2) -> subst_induction_pred a b (lc_app (eVar x) (eVar y)) plug1 plug2 $ =
  (named '(rsyl (anl an4) @ rsyl (anim2 @
    syl (curry eq_trans) @
    iand
      (rsyl anl @ eq_equiv_to_eq_eq ,(func_subst_explicit_helper 'z $_ @@ (eVar z) @@ _$))
      (rsyl anr @ eq_equiv_to_eq_eq ,(func_subst_explicit_helper 'z $_ @@ (eVar z)$))
  ) @
  rsyl (anim1 @ iand id id) @
  rsyl (anl anass) @
  rsyl (anim2 @ anim1 @ syl (curry @ subst_app b_var plug2_exp) (anim
    (mp (com12 @ mp ,(function_sorting 3 'function_subst) (domain_func_sorting a_var)) plug1_exp)
    (mp (com12 @ mp ,(function_sorting 3 'function_subst) (domain_func_sorting a_var)) plug1_exp)
    )) @
  rsyl (anim2 @ curry eq_trans) @
  rsyl (anim1 @ iand id id) @
  rsyl (anl anass) @
  rsyl (anim2 @ anim1 @ syl ,(imp_eq_framing_subst 'appCtxLRVar) @ curry @ subst_app a_var plug1_exp) @
  rsyl (anim2 @ curry eq_trans) @
  rsyl (anim1 @ iand id id) @
  rsyl (anl anass) @
  rsyl (anim2 @ anim1 @ syl eq_sym @ syl (curry @ subst_app a_var (mp (mp (mp ,(function_sorting 3 'function_subst) (domain_func_sorting b_var)) plug1_exp) plug2_exp)) (anim
    (mp (com12 @ mp ,(function_sorting 3 'function_subst) (domain_func_sorting b_var)) plug2_exp)
    (mp (com12 @ mp ,(function_sorting 3 'function_subst) (domain_func_sorting b_var)) plug2_exp)
    )) @
  rsyl (anim2 @ impcom eq_trans) @
  rsyl (anim1 @ iand id id) @
  rsyl (anl anass) @
  rsyl (anim2 @ anim1 @ syl eq_sym @ syl ,(imp_eq_framing_subst 'appCtxLRVar) @ curry @ subst_app b_var plug2_exp) @
  rsyl (anim2 @ impcom eq_trans) @
  anr));

theorem subst_induction_app (a b plug1 plug2: Pattern)
  (lemma: $ (is_exp (eVar x) /\ subst_induction_pred a b (eVar x) plug1 plug2) /\ (is_exp (eVar y) /\ subst_induction_pred a b (eVar y) plug1 plug2) -> subst_induction_pred a b (lc_app (eVar x) (eVar y)) plug1 plug2 $):
  $ (lc_app (satisfying_exps a b plug1 plug2) (satisfying_exps a b plug1 plug2)) C= (satisfying_exps a b plug1 plug2) $ =
  (named '(imp_to_subset @
    rsyl (anl ,(ex_appCtx_subst 'appCtxLRVar)) @
    exists_generalization_disjoint @
    rsyl (anl ,(ex_appCtx_subst 'appCtxRVar)) @
    exists_generalization_disjoint @
    rsyl ,(appCtx_floor_commute_b_subst 'appCtxLRVar) @
    rsyl (anim1 @ iand id id) @
    rsyl (anl anass) @
    rsyl (anim2 @
      rsyl (anim2 ,(appCtx_floor_commute_subst 'appCtxLRVar)) @
      rsyl (anim2 ancom) @
      rsyl (anr anass) @
      rsyl (anim2 @
        rsyl ,(appCtx_floor_commute_b_subst 'appCtxRVar) @
        rsyl (anim1 @ iand id id) @
        rsyl (anl anass) @
        anim2 @
        rsyl (anim2 ,(appCtx_floor_commute_subst 'appCtxRVar)) @
        rsyl (anim2 ancom) @
        anr anass
        ) @
      rsyl (anl anlass) @
      anim2 @
      anr anass) @
    rsyl (anr anass) @
    rsyl (anim2 @ anim1 lemma) @
    rsyl (anim2 @ ancom) @
    rsyl (anim1 @ curry @ mp ,(inst_foralls 2) function_lc_app) @
    curry ,(func_subst_alt_thm_sorted 'x $(eVar x) /\ ((app (app _ (app (app _ (eVar x)) _)) _) == (app (app _ (app (app _ (eVar x)) _)) _))$)
    ));

theorem subst_induction_lam_lemma (a b c plug1 plug2: Pattern)
  (diff_atoms_ab: $ a != b $)
  (diff_atoms_cb: $ c != b $)
  (diff_atoms_ca: $ c != a $)
  (a_var: $ is_sorted_func Var a $)
  (b_var: $ is_sorted_func Var b $)
  (c_var: $ is_sorted_func Var c $)
  (a_fresh: $ fresh_for a plug2 $)
  (c_fresh_in_plug1: $ fresh_for c plug1 $)
  (c_fresh_in_plug2: $ fresh_for c plug2 $)
  (phi_exp: $ is_exp phi $)
  (plug1_exp: $ is_exp plug1 $)
  (plug2_exp: $ is_exp plug2 $):
  $ is_exp (eVar x) /\ subst_induction_pred a b (eVar x) plug1 plug2 -> subst_induction_pred a b (lc_lam (abstraction c (eVar x))) plug1 plug2 $ =
  '(rsyl (anim1 @ iand id id) @
    rsyl (anl anass) @
    rsyl (anim2 @ anim1 @ syl (eq_equiv_to_eq_eq ,(func_subst_explicit_helper 'z $_ @@ (eVar z) @@ _$)) @
      subst_lam_diff_var diff_atoms_ca c_fresh_in_plug1 c_var a_var plug1_exp) @
    rsyl (anl anlass) @
    syl (curry eq_trans) @
    anim2 @
    rsyl (anim1 @ iand id id) @
    rsyl (anl anass) @
    rsyl (anim2 @ anim1 @ syl (subst_lam_diff_var diff_atoms_cb c_fresh_in_plug2 c_var b_var plug2_exp)
      (com12 (mp ,(function_sorting 3 'function_subst) (domain_func_sorting a_var)) plug1_exp)
      ) @
    rsyl (anl anlass) @
    syl (curry eq_trans) @
    anim2 @
    rsyl (anim2 @ rsyl (eq_equiv_to_eq_eq ,(func_subst_explicit_helper 'z $_ @@ (eVar z)$)) (eq_equiv_to_eq_eq ,(func_subst_explicit_helper 'z $_ @@ (eVar z)$))) @
    rsyl ancom @
    syl (curry eq_trans) @
    anim2 @
    rsyl (iand
      (syl eq_sym @ syl (subst_lam_diff_var diff_atoms_ca _ c_var a_var (mp (mp ,(function_sorting 3 'function_subst) (domain_func_sorting b_var)) plug1_exp plug2_exp)) (com12 (mp ,(function_sorting 3 'function_subst) (domain_func_sorting b_var)) plug2_exp))
      (syl eq_sym @ syl (eq_equiv_to_eq_eq ,(func_subst_explicit_helper 'z $_ @@ (eVar z) @@ _$)) (subst_lam_diff_var diff_atoms_cb c_fresh_in_plug2 c_var b_var plug2_exp))
    ) @
    curry eq_trans);

theorem subst_induction_lam (a b c plug1 plug2: Pattern)
  (c_sorting: $ is_sorted_func Var c $)
  (lemma: $ is_exp (eVar x) /\ subst_induction_pred a b (eVar x) plug1 plug2 -> subst_induction_pred a b (lc_lam (abstraction c (eVar x))) plug1 plug2 $):
  $ (lc_lam (abstraction c (satisfying_exps a b plug1 plug2))) C= (satisfying_exps a b plug1 plug2) $ =
  (named '(imp_to_subset @
    rsyl (anl ,(ex_appCtx_subst @ appCtx_constructor '[1 1])) @
    exists_generalization_disjoint @
    rsyl ,(appCtx_floor_commute_b_subst @ appCtx_constructor '[1 1]) @
    rsyl (anim2 ,(appCtx_floor_commute_subst @ appCtx_constructor '[1 1])) @
    rsyl (anim1 @ iand id id) @
    rsyl (anl anass) @
    rsyl (anim2 @ rsyl (anl anlass) @ anim2 lemma) @
    rsyl (anim1 @ rsyl (mp ,(inst_foralls 1) (swap_sorted_forall @ function_abstraction Var_atom Exp_sort))
      (rsyl (con1 @ anr imp_exists_disjoint (exists_framing (syl con3 @ syl anl ,(func_subst_explicit_helper 'x $((eVar x) C= _) -> exists _ (_ /\ (_ == (_ @@ (eVar x) @@ _)))$)) (exists_framing anr c_sorting))) @ rsyl (mpcom @ domain_func_sorting c_sorting) @
        exists_generalization_disjoint @ rsyl (anim1 @ var_subst_same_var function_lc_lam) @ impcom @ syl anl ,(func_subst_explicit_helper 'x $exists _ (_ /\ (_ == (_ @@ (eVar x))))$))
      ) @
    curry ,(func_subst_alt_thm_sorted 'x $(eVar x) /\ ((app (app _ (app (app _ (eVar x)) _)) _) == (app (app _ (app (app _ (eVar x)) _)) _))$)
    ));
  

theorem subst_induction_lemma (a b c phi plug1 plug2: Pattern)
  (diff_atoms_ab: $ a != b $)
  (diff_atoms_cb: $ c != b $)
  (diff_atoms_ca: $ c != a $)
  (a_var: $ is_sorted_func Var a $)
  (b_var: $ is_sorted_func Var b $)
  (c_var: $ is_sorted_func Var c $)
  (c_nonempty: $ |^ c ^| $)
  (phi_exp: $ is_exp phi $)
  (plug1_exp: $ is_exp plug1 $)
  (plug2_exp: $ is_exp plug2 $)
  (a_fresh: $ fresh_for a plug2 $)
  (c_fresh_in_plug1: $ fresh_for c plug1 $)
  (c_fresh_in_plug2: $ fresh_for c plug2 $):
  $ Exps == (satisfying_exps a b plug1 plug2) $ =
  '(induction_principle
    (domain_func_sorting c_var)
    c_nonempty
    (imp_to_subset @ exists_generalization_disjoint @ rsyl (anim corollary_57_floor anl) @ curry id)
    _
    (subst_induction_var diff_atoms_ab a_var b_var plug1_exp plug2_exp a_fresh)
    (subst_induction_app @ subst_induction_app_lemma a_var b_var plug1_exp plug2_exp)
    (subst_induction_lam c_var @ subst_induction_lam_lemma diff_atoms_ab diff_atoms_cb diff_atoms_ca a_var b_var c_var a_fresh c_fresh_in_plug1 c_fresh_in_plug2 phi_exp plug1_exp plug2_exp));

theorem subst_induction (a b phi plug1 plug2: Pattern)
  (diff_atoms_ab: $ a != b $)
  (diff_atoms_cb: $ c != b $)
  (diff_atoms_ca: $ c != a $)
  (a_var: $ is_sorted_func Var a $)
  (b_var: $ is_sorted_func Var b $)
  (c_var: $ is_sorted_func Var c $)
  (c_nonempty: $ |^ c ^| $)
  (phi_exp: $ is_exp phi $)
  (plug1_exp: $ is_exp plug1 $)
  (plug2_exp: $ is_exp plug2 $)
  (a_fresh: $ fresh_for a plug2 $)
  (c_fresh_in_plug1: $ fresh_for c plug1 $)
  (c_fresh_in_plug2: $ fresh_for c plug2 $):
  $ (subst b (subst a phi plug1) plug2) == (subst a (subst b phi plug2) (subst b plug1 plug2)) $ =
  (named '(mp (
    rsyl (com12 subset_trans @ eq_imp_subset @ subst_induction_lemma diff_atoms_ab diff_atoms_cb diff_atoms_ca a_var b_var c_var c_nonempty phi_exp plug1_exp plug2_exp a_fresh c_fresh_in_plug1 c_fresh_in_plug2) @
    rsyl subset_mem_lemma @
    rsyl (forall_framing (rsyl
      (imim2 @ rsyl membership_exists_forward @ exists_generalization_disjoint @ rsyl (anl ,(propag_mem 'x $(_ C= _) /\ ((eVar _) /\ (_ == _))$)) @ rsyl anr (curry @ syl anr ,(func_subst_explicit_helper 'x $(app (app _ (app (app _ (eVar x)) _)) _) == (app (app _ (app (app _ (eVar x)) _)) _)$)))
      (rsyl (imim (anl floor_ceil_ceil) (anr ceil_floor_floor)) @ rsyl prop_43_or_def @ rsyl (anr floor_ceil_ceil) @ framing_floor @ rsyl prop_43_or_def_rev @ imim (anr floor_ceil_ceil) (anl ceil_floor_floor)))) @
    rsyl (anr forall_floor) @
    syl (rsyl
      (eq_trans @ equiv_to_eq ,(appCtx_pointwise_subst @ appCtx_constructor '[0 1 0 1])) @
      com12 eq_trans @ eq_sym @ equiv_to_eq ,(appCtx_pointwise_subst @ appCtx_constructor '[0 1 0 1])) @
    framing_floor @ eq_to_exists_bi_fresh eFresh_forall_same_var @ syl corollary_57_floor @ rsyl var_subst_same_var imp_eq_to_conj_in_eq) phi_exp));
