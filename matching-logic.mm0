delimiter $ ( ~ $ $ ) $;

strict provable sort Pattern;
pure sort EVar;
pure sort SVar;
sort Symbol;

strict provable sort Positivity;
strict provable sort Substitution;
strict provable sort Normalization;

-- Standard Matching Logic Pattern constructors
term eVar {x: EVar}: Pattern x;
term sVar {X: SVar}: Pattern X;
term sym: Symbol > Pattern;
term bot: Pattern;
term imp: Pattern > Pattern > Pattern;
term app: Pattern > Pattern > Pattern;
term exists {x: EVar} (p: Pattern x): Pattern;
term mu {X: SVar} (p: Pattern X): Pattern;

term evSubst {x: EVar}: Pattern x > Pattern x > Pattern x;
notation evSubst {x: EVar} (phi psi: Pattern x): Pattern x =
  ($e[$:41) psi ($/$:0) x ($]$:0) phi;
term svSubst {X: SVar}: Pattern X > Pattern X > Pattern X;
notation svSubst {X: SVar} (phi psi: Pattern X): Pattern X =
  ($s[$:41) psi ($/$:0) X ($]$:0) phi;
term ctxApp {box: SVar} (ctx: Pattern box): Pattern > Pattern;
notation ctxApp {box: SVar} (ctx psi: Pattern X): Pattern X =
  ($app[$:41) psi ($/$:0) box ($]$:0) ctx;

-- Definitions of common logical connectives
infixr imp: $->$ prec 25;
def not (phi: Pattern): Pattern = $ phi -> bot $;
prefix not: $~$ prec 41;
def top: Pattern = $ ~bot $;
def or (phi1 phi2: Pattern): Pattern = $ ~phi1 -> phi2 $;
infixl or: $\/$ prec 30;
def and (phi1 phi2: Pattern): Pattern = $ ~(phi1 -> ~phi2) $;
infixl and: $/\$ prec 34;
def equiv (phi1 phi2: Pattern): Pattern = $ (phi1 -> phi2) /\ (phi2 -> phi1) $;
infixl equiv: $<->$ prec 20;
def forall {x: EVar} (phi: Pattern x): Pattern = $ ~(exists x (~phi)) $;
def nu {X: SVar} (phi: Pattern X): Pattern = $ ~(mu X (~phi)) $;

-- Positivity definitions
term _Positive: SVar > Pattern > Positivity;
term _Negative: SVar > Pattern > Positivity;

axiom positive_in_eVar {X: SVar} {x: EVar}: $ _Positive X (eVar x) $;
axiom positive_in_sVar {X: SVar} {Y: SVar}: $ _Positive X (sVar Y) $;
axiom positive_in_same_sVar {X: SVar}: $ _Positive X (sVar X) $;
axiom positive_in_sym {X: SVar} (s: Symbol): $ _Positive X (sym s) $;
axiom positive_in_bot {X: SVar}: $ _Positive X bot $;
axiom positive_in_imp {X: SVar} (phi1 phi2: Pattern X):
  $ _Negative X phi1 $ > $ _Positive X phi2 $ > $ _Positive X (phi1 -> phi2) $;
axiom positive_in_app {X: SVar} (phi1 phi2: Pattern X):
  $ _Positive X phi1 $ > $ _Positive X phi2 $ > $ _Positive X (app phi1 phi2) $;
axiom positive_in_exists {X: SVar} {x: EVar} (phi: Pattern x X):
  $ _Positive X phi $ > $ _Positive X (exists x phi) $;
axiom positive_in_mu {X: SVar} {Y: SVar} (phi: Pattern X Y):
  $ _Positive X phi $ > $ _Positive X (mu Y phi) $;
axiom positive_in_same_mu {X: SVar} (phi: Pattern X): $ _Positive X (mu X phi) $;

axiom negative_in_eVar {X: SVar} {x: EVar}: $ _Negative X (eVar x) $;
axiom negative_in_sVar {X: SVar} {Y: SVar}: $ _Negative X (sVar Y) $;
axiom negative_in_sym {X: SVar} (s: Symbol): $ _Negative X (sym s) $;
axiom negative_in_bot {X: SVar}: $ _Negative X bot $;
axiom negative_in_imp {X: SVar} (phi1 phi2: Pattern X):
  $ _Positive X phi1 $ > $ _Negative X phi2 $ > $ _Negative X (phi1 -> phi2) $;
axiom negative_in_app {X: SVar} (phi1 phi2: Pattern X):
  $ _Negative X phi1 $ > $ _Negative X phi2 $ > $ _Negative X (app phi1 phi2) $;
axiom negative_in_exists {X: SVar} {x: EVar} (phi: Pattern x X):
  $ _Negative X phi $ > $ _Negative X (exists x phi) $;
axiom negative_in_mu {X: SVar} {Y: SVar} (phi: Pattern X Y):
  $ _Negative X phi $ > $ _Negative X (mu Y phi) $;
axiom negative_in_same_mu {X: SVar} (phi: Pattern X): $ _Negative X (mu X phi) $;

-- Definition of substitutions and application contexts as meta-level relations
term Norm : Pattern > Pattern > Substitution;
term AppCtx : Pattern > Pattern > Substitution;

axiom eSubstitution_in_eVar {x: EVar} {y: EVar} (psi: Pattern x y): $ Norm (e[ psi / x ] eVar y) (eVar y) $;
axiom eSubstitution_in_same_eVar {x: EVar} (psi: Pattern x): $ Norm (e[ psi / x ] eVar x) psi $;
axiom eSubstitution_in_sVar {x: EVar} {X: SVar} (psi: Pattern x X): $ Norm (e[ psi / x ] sVar X) (sVar X) $;
axiom eSubstitution_in_sym {x: EVar} (psi: Pattern x) (s: Symbol): $ Norm (e[ psi / x ] sym s) (sym s) $;
axiom eSubstitution_in_bot {x: EVar} (psi: Pattern x): $ Norm (e[ psi / x ] bot) bot $;
axiom eSubstitution_in_imp {x: EVar} (psi phi1 phi2 phi1Norm phi2Norm: Pattern x):
  $ Norm (e[ psi / x ] phi1) phi1Norm $
> $ Norm (e[ psi / x ] phi2) phi2Norm $
> $ Norm (e[ psi / x ] (phi1 -> phi2)) (phi1Norm -> phi2Norm) $
  ;
axiom eSubstitution_in_app {x: EVar} (psi phi1 phi2 phi1Norm phi2Norm: Pattern x):
  $ Norm (e[ psi / x ] phi1) phi1Norm $
> $ Norm (e[ psi / x ] phi2) phi2Norm $
> $ Norm (e[ psi / x ] (app phi1 phi2)) (app phi1Norm phi2Norm) $
  ;
axiom eSubstitution_in_exists {x: EVar} (psi: Pattern x) {y: EVar} (phi phiNorm: Pattern x y):
  $ Norm (e[ psi / x ] phi) phiNorm $
> $ Norm (e[ psi / x ] exists y phi) (exists y phiNorm) $;
axiom eSubstitution_in_same_exists {x: EVar} (psi phi: Pattern x):
  $ Norm (e[ psi / x ] exists x phi) (exists x phi) $;
axiom eSubstitution_in_mu {x: EVar} (psi: Pattern x) {X: SVar} (phi phiNorm: Pattern x X):
  $ Norm (e[ psi / x ] phi) phiNorm $
> $ Norm (e[ psi / x ] mu X phi) (mu X phiNorm) $;
-- TODO: propagate substitutions through the substitution application terms as well

axiom sSubstitution_in_eVar {X: SVar} {x: EVar} (psi: Pattern X x): $ Norm (s[ psi / X ] eVar x) (eVar x) $;
axiom sSubstitution_in_sVar {X: SVar} {Y: SVar} (psi: Pattern X Y): $ Norm (s[ psi / X ] sVar Y) (sVar Y) $;
axiom sSubstitution_in_same_sVar {X: SVar} (psi: Pattern X): $ Norm (s[ psi / X ] sVar X) psi $;
axiom sSubstitution_in_sym {X: SVar} (psi: Pattern X) (s: Symbol): $ Norm (s[ psi / X ] sym s) (sym s) $;
axiom sSubstitution_in_bot {X: SVar} (psi: Pattern X): $ Norm (s[ psi / X ] bot) bot $;
axiom sSubstitution_in_imp {X: SVar} (psi phi1 phi2: Pattern X):
  $ Norm (s[ psi / X ] (phi1 -> phi2)) ((s[ psi / X ] phi1) -> (s[ psi / X ] phi2)) $;
axiom sSubstitution_in_app {X: SVar} (psi phi1 phi2: Pattern X):
  $ Norm (s[ psi / X ] app phi1 phi2) (app (s[ psi / X ] phi1) (s[ psi / X ] phi2)) $;
axiom sSubstitution_in_exists {X: SVar} (psi: Pattern X) {x: EVar} (phi: Pattern X x):
  $ Norm (s[ psi / X ] exists x phi) (exists x (s[ psi / X ] phi)) $;
axiom sSubstitution_in_mu {X: SVar} (psi: Pattern X) {Y: SVar} (phi: Pattern X Y):
  $ Norm (s[ psi / X ] mu Y phi) (mu Y (s[ psi / X ] phi)) $;
axiom sSubstitution_in_same_mu {X: SVar} (psi phi: Pattern X):
  $ Norm (s[ psi / X ] mu X phi) (mu X phi) $;
-- TODO: propagate substitutions through the substitution application terms as well

axiom appCtxVar {box: SVar} (phi: Pattern): $ AppCtx (app[ phi / box ] sVar box) phi $;
axiom appCtxL {box: SVar} (ctx: Pattern box) (phi1 phi2: Pattern):
  $ AppCtx (app[ phi1 / box ] (app ctx phi2)) (app (app[ phi1 / box ] ctx) phi2) $;
axiom appCtxR {box: SVar} (ctx: Pattern box) (phi1 phi2: Pattern):
  $ AppCtx (app[ phi2 / box ] (app phi1 ctx)) (app phi1 (app[ phi2 / box ] ctx)) $;

-- Normalization relation (used for normalizing terms with substitutions in them)
axiom norm_id (phi: Pattern): $ Norm phi phi $;
axiom norm_imp (phi psi phi2 psi2: Pattern):
  $ Norm phi phi2 $ >
  $ Norm psi psi2 $ >
  $ Norm (phi -> psi) (phi2 -> psi2) $;
axiom norm_app (phi psi phi2 psi2: Pattern):
  $ Norm phi phi2 $ >
  $ Norm psi psi2 $ >
  $ Norm (app phi psi) (app phi2 psi2) $;
axiom norm_exists {x: EVar} (phi phi2: Pattern x):
  $ Norm phi phi2 $ >
  $ Norm (exists x phi) (exists x phi2) $;
axiom norm_mu {X: SVar} (phi phi2: Pattern X):
  $ Norm phi phi2 $ >
  $ Norm (mu X phi) (mu X phi2) $;
-- pt stands for pass-through
axiom norm_evSubst_pt {x: EVar} (ctx ctx2 phi phi2: Pattern x):
  $ Norm ctx ctx2 $ >
  $ Norm phi phi2 $ >
  $ Norm (evSubst x ctx phi) (evSubst x ctx2 phi2) $;
axiom norm_svSubst_pt {X: SVar} (ctx ctx2 phi phi2: Pattern X):
  $ Norm ctx ctx2 $ >
  $ Norm phi phi2 $ >
  $ Norm (svSubst X ctx phi) (svSubst X ctx2 phi2) $;
axiom norm_ctxApp_pt {box: SVar} (ctx ctx2: Pattern box) (phi phi2: Pattern):
  $ Norm ctx ctx2 $ >
  $ Norm phi phi2 $ >
  $ Norm (ctxApp box ctx phi) (ctxApp box ctx2 phi2) $;
-- red stands for reduction
axiom norm_ctxApp_red (plug rho: Pattern):
  $ AppCtx plug rho $ > $ Norm plug rho $;

-- The Proof System of Matching Logic
axiom norm (phi psi: Pattern):
  $ Norm phi psi $ >
  $ phi $ >
  $ psi $;
axiom norm_rev (phi psi: Pattern):
  $ Norm phi psi $ >
  $ psi $ >
  $ phi $;

axiom prop_1 (phi1 phi2: Pattern):
  $ phi1 -> phi2 -> phi1 $;
axiom prop_2 (phi1 phi2 phi3: Pattern):
  $ (phi1 -> phi2 -> phi3) -> (phi1 -> phi2) -> (phi1 -> phi3) $;
axiom prop_3 (phi1 phi2: Pattern):
  $ (~phi1 -> ~phi2) -> phi2 -> phi1 $;
axiom mp (phi psi: Pattern):
  $ phi -> psi $ > $ phi $ > $ psi $;
axiom exists_intro {x y: EVar} (phi: Pattern x y):
  $ (e[ (eVar y) / x ] phi) -> exists x phi $;
axiom exists_intro_same_var {x: EVar} (phi: Pattern x):
  $ phi -> exists x phi $;
axiom exists_generalization {x: EVar} (phi1: Pattern x) (phi2: Pattern):
  $ phi1 -> phi2 $ > $ (exists x phi1) -> phi2 $;
axiom propag_bot {box: SVar} (ctx: Pattern box):
  $ (app[ bot / box ] ctx) -> bot $;
axiom propag_or {box: SVar} (ctx: Pattern box) (phi1 phi2: Pattern):
  $ app[ phi1 \/ phi2 / box ] ctx -> (app[ phi1 / box ] ctx \/ app[ phi2 / box ] ctx) $;
axiom propag_exists {box: SVar} {x: EVar} (ctx: Pattern box) (phi: Pattern x):
  $ app[ exists x phi / box ] ctx -> exists x (app[ phi / box ] ctx) $;
axiom framing {box: SVar} (ctx: Pattern box) (phi1 phi2: Pattern):
  $ phi1 -> phi2 $ >
  $ (app[ phi1 / box ] ctx) -> app[ phi2 / box ] ctx $;
axiom set_var_subst {X: SVar} (phi psi: Pattern X):
  $ phi $ > $ s[ psi / X ] phi $;
axiom pre_fixpoint {X: SVar} (phi: Pattern X):
  $ _Positive X phi $ >
  $ (s[ mu X phi / X ] phi) -> mu X phi $;
axiom KT {X: SVar} (phi psi: Pattern X):
  $ _Positive X phi $ >
  $ (s[ psi / X ] phi) -> psi $ >
  $ (mu X phi) -> psi $;
axiom existence {x: EVar}: $ exists x (eVar x) $;
axiom singleton {box1 box2: SVar} {x: EVar}
  (ctx1: Pattern box1 x) (ctx2: Pattern box2 x) (phi: Pattern x):
  $ ~(app[ (eVar x) /\ phi / box1 ] ctx1 /\ app[ (eVar x) /\ ~phi / box2 ] ctx2) $;