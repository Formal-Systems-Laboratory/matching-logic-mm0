delimiter $ ( ~ $ $ ) $;

strict provable sort Pattern;
pure sort EVar;
pure sort SVar;
sort Symbol;

strict provable sort Positivity;
-- strict provable sort Wellformedness;
strict provable sort Substitution;
strict provable sort ApplicationContext;

-- Standard Matching Logic Pattern constructors
term eVar {x: EVar}: Pattern x;
term sVar {X: SVar}: Pattern X;
term sym: Symbol > Pattern;
term bot: Pattern;
term imp: Pattern > Pattern > Pattern;
term app: Pattern > Pattern > Pattern;
term exists {x: EVar} (p: Pattern x): Pattern;
term mu {X: SVar} (p: Pattern X): Pattern;

-- Definitions of common logical connectives
infixr imp: $->$ prec 25;
def not (phi: Pattern): Pattern = $ phi -> bot $;
prefix not: $~$ prec 41;
def top: Pattern = $ ~bot $;
def or (phi1 phi2: Pattern): Pattern = $ ~phi1 -> phi2 $;
infixl or: $\/$ prec 30;
def and (phi1 phi2: Pattern): Pattern = $ ~(phi1 -> ~phi2) $;
infixl and: $/\$ prec 34;
def equiv (phi1 phi2: Pattern): Pattern = $ (phi1 -> phi2) /\ (phi2 -> phi1) $;
infixl equiv: $<->$ prec 20;
def forall {x: EVar} (phi: Pattern x): Pattern = $ ~(exists x (~phi)) $;
def nu {X: SVar} (phi: Pattern X): Pattern = $ ~(mu X (~phi)) $;

-- Positivity definitions
term _Positive: SVar > Pattern > Positivity;
term _Negative: SVar > Pattern > Positivity;

axiom positive_in_eVar {X: SVar} {x: EVar}: $ _Positive X (eVar x) $;
axiom positive_in_sVar {X: SVar} {Y: SVar}: $ _Positive X (sVar Y) $;
axiom positive_in_same_sVar {X: SVar}: $ _Positive X (sVar X) $;
axiom positive_in_sym {X: SVar} (s: Symbol): $ _Positive X (sym s) $;
axiom positive_in_bot {X: SVar}: $ _Positive X bot $;
axiom positive_in_imp {X: SVar} (phi1 phi2: Pattern X):
  $ _Negative X phi1 $ > $ _Positive X phi2 $ > $ _Positive X (phi1 -> phi2) $;
axiom positive_in_app {X: SVar} (phi1 phi2: Pattern X):
  $ _Positive X phi1 $ > $ _Positive X phi2 $ > $ _Positive X (app phi1 phi2) $;
axiom positive_in_exists {X: SVar} {x: EVar} (phi: Pattern x X):
  $ _Positive X phi $ > $ _Positive X (exists x phi) $;
axiom positive_in_mu {X: SVar} {Y: SVar} (phi: Pattern X Y):
  $ _Positive X phi $ > $ _Positive X (mu Y phi) $;
axiom positive_in_same_mu {X: SVar} (phi: Pattern X): $ _Positive X (mu X phi) $;

axiom negative_in_eVar {X: SVar} {x: EVar}: $ _Negative X (eVar x) $;
axiom negative_in_sVar {X: SVar} {Y: SVar}: $ _Negative X (sVar Y) $;
axiom negative_in_sym {X: SVar} (s: Symbol): $ _Negative X (sym s) $;
axiom negative_in_bot {X: SVar}: $ _Negative X bot $;
axiom negative_in_imp {X: SVar} (phi1 phi2: Pattern X):
  $ _Positive X phi1 $ > $ _Negative X phi2 $ > $ _Negative X (phi1 -> phi2) $;
axiom negative_in_app {X: SVar} (phi1 phi2: Pattern X):
  $ _Negative X phi1 $ > $ _Negative X phi2 $ > $ _Negative X (app phi1 phi2) $;
axiom negative_in_exists {X: SVar} {x: EVar} (phi: Pattern x X):
  $ _Negative X phi $ > $ _Negative X (exists x phi) $;
axiom negative_in_mu {X: SVar} {Y: SVar} (phi: Pattern X Y):
  $ _Negative X phi $ > $ _Negative X (mu Y phi) $;
axiom negative_in_same_mu {X: SVar} (phi: Pattern X): $ _Negative X (mu X phi) $;

-- Wellformedness
-- term wf: Pattern > Wellformedness;
-- 
-- axiom wf_eVar {x: EVar}: $ wf (eVar x) $;
-- axiom wf_sVar {X: SVar}: $ wf (sVar X) $;
-- axiom wf_sym {s: Symbol}: $ wf (sym s) $;
-- axiom wf_bot: $ wf bot $;
-- axiom wf_imp (phi1 phi2: Pattern):
--   $ wf phi1 $ > $ wf phi2 $ > $ wf (phi1 -> phi2) $;
-- axiom wf_app (phi1 phi2: Pattern):
--   $ wf phi1 $ > $ wf phi2 $ > $ wf (app phi1 phi2) $;
-- axiom wf_exists {x: EVar} (phi: Pattern x):
--   $ wf phi $ > $ wf (exists x phi) $;
-- axiom wf_mu {X: SVar} (phi: Pattern X):
--   $ wf phi $ > $ _Positive X phi $ > $ wf (mu X phi) $;

-- Definition of substitution as a meta-level relation
term _ESubst {x: EVar} (phi psi rho: Pattern x): Substitution;
notation _ESubst {x: EVar} (phi psi rho: Pattern x): Substitution =
  ($e[$:41) psi ($/$:0) x ($]$:0) phi ($==>$:0) rho;
-- "[psi/x] phi ==> rho" means "rho is the result of substituting psi for x in phi.

term _SSubst {X: SVar} (phi psi rho: Pattern X): Substitution;
notation _SSubst {X: SVar} (phi psi rho: Pattern X): Substitution =
  ($s[$:41) psi ($/$:0) X ($]$:0) phi ($==>$:0) rho;
-- "[psi/X] phi ==> rho" means "rho is the result of substituting psi for X in phi.

axiom eSubstitution_in_eVar {x: EVar} {y: EVar} (psi: Pattern x y): $ e[ psi / x ] eVar y ==> eVar y $;
axiom eSubstitution_in_same_eVar {x: EVar} (psi: Pattern x): $ e[ psi / x ] eVar x ==> psi $;
axiom eSubstitution_in_sVar {x: EVar} {X: SVar} (psi: Pattern x X): $ e[ psi / x ] sVar X ==> sVar X $;
axiom eSubstitution_in_sym {x: EVar} (psi: Pattern x) (s: Symbol): $ e[ psi / x ] sym s ==> sym s $;
axiom eSubstitution_in_bot {x: EVar} (psi: Pattern x): $ e[ psi / x ] bot ==> bot $;
axiom eSubstitution_in_imp {x: EVar} (psi phi1 phi2 rho1 rho2: Pattern x):
  $ e[ psi / x ] phi1 ==> rho1 $ >
  $ e[ psi / x ] phi2 ==> rho2 $ >
  $ e[ psi / x ] (phi1 -> phi2) ==> (rho1 -> rho2) $;
axiom eSubstitution_in_app {x: EVar} (psi phi1 phi2 rho1 rho2: Pattern x):
  $ e[ psi / x ] phi1 ==> rho1 $ >
  $ e[ psi / x ] phi2 ==> rho2 $ >
  $ e[ psi / x ] app phi1 phi2 ==> app rho1 rho2 $;
axiom eSubstitution_in_exists {x: EVar} (psi: Pattern x) {y: EVar} (phi rho: Pattern x y):
  $ e[ psi / x ] phi ==> rho $ >
  $ e[ psi / x ] exists y phi ==> exists y rho $;
axiom eSubstitution_in_same_exists {x: EVar} (psi phi: Pattern x):
  $ e[ psi / x ] exists x phi ==> exists x phi $;
axiom eSubstitution_in_mu {x: EVar} (psi: Pattern x) {X: SVar} (phi rho: Pattern x X):
  $ e[ psi / x ] phi ==> rho $ >
  $ e[ psi / x ] mu X phi ==> mu X rho $;

axiom sSubstitution_in_eVar {X: SVar} {x: EVar} (psi: Pattern X x): $ s[ psi / X ] eVar x ==> eVar x $;
axiom sSubstitution_in_sVar {X: SVar} {Y: SVar} (psi: Pattern X Y): $ s[ psi / X ] sVar Y ==> sVar Y $;
axiom sSubstitution_in_same_sVar {X: SVar} (psi: Pattern X): $ s[ psi / X ] sVar X ==> psi $;
axiom sSubstitution_in_sym {X: SVar} (psi: Pattern X) (s: Symbol): $ s[ psi / X ] sym s ==> sym s $;
axiom sSubstitution_in_bot {X: SVar} (psi: Pattern X): $ s[ psi / X ] bot ==> bot $;
axiom sSubstitution_in_imp {X: SVar} (psi phi1 phi2 rho1 rho2: Pattern X):
  $ s[ psi / X ] phi1 ==> rho1 $ >
  $ s[ psi / X ] phi2 ==> rho2 $ >
  $ s[ psi / X ] (phi1 -> phi2) ==> (rho1 -> rho2) $;
axiom sSubstitution_in_app {X: SVar} (psi phi1 phi2 rho1 rho2: Pattern X):
  $ s[ psi / X ] phi1 ==> rho1 $ >
  $ s[ psi / X ] phi2 ==> rho2 $ >
  $ s[ psi / X ] app phi1 phi2 ==> app rho1 rho2 $;
axiom sSubstitution_in_exists {X: SVar} (psi: Pattern X) {x: EVar} (phi rho: Pattern X x):
  $ s[ psi / X ] phi ==> rho $ >
  $ s[ psi / X ] exists x phi ==> exists x rho $;
axiom sSubstitution_in_mu {X: SVar} (psi: Pattern X) {Y: SVar} (phi rho: Pattern X Y):
  $ s[ psi / X ] phi ==> rho $ >
  $ s[ psi / X ] mu Y phi ==> mu Y rho $;
axiom sSubstitution_in_same_mu {X: SVar} (psi phi: Pattern X):
  $ s[ psi / X ] mu X phi ==> mu X phi $;

-- Necessary axioms (cannot be proved in the general case,
-- can only be proved for concrete phi)
-- Note that we can remove these as axioms if we decide to always
-- have these as assumptions in all theorems proved and resort to
-- constructing the proof on concrete phi's when using those theorems
-- axiom eSubstitution_id {x: EVar} (phi: Pattern x):
--   $ e[ eVar x / x ] phi ==> phi $;
-- axiom sSubstitution_id {X: SVar} (phi: Pattern X):
--   $ s[ sVar X / X ] phi ==> phi $;

-- Application Contexts
term _AppCtx (ctx phi rho: Pattern): ApplicationContext;
term _NestedAppCtx (ctx phi rho: Pattern): ApplicationContext;

axiom appCtxL {box: EVar} (phi psi: Pattern):
  $ _AppCtx (exists box (app (eVar box) psi)) phi (app phi psi) $;
axiom appCtxR {box: EVar} (phi psi: Pattern):
  $ _AppCtx (exists box (app psi (eVar box))) phi (app psi phi) $;

axiom nestedAppCtxVar {box: EVar} (phi: Pattern): $ _NestedAppCtx (exists box (eVar box)) phi phi $;
axiom nestedAppCtxL {box: EVar} (ctx: Pattern box) (phi1 phi2 rho: Pattern):
  $ _NestedAppCtx (exists box ctx) phi1 rho $ >
  $ _NestedAppCtx (exists box (app ctx phi2)) phi1 (app rho phi2) $;
axiom nestedAppCtxR {box: EVar} (ctx: Pattern box) (phi1 phi2 rho: Pattern):
  $ _NestedAppCtx (exists box ctx) phi2 rho $ >
  $ _NestedAppCtx (exists box (app phi1 ctx)) phi2 (app phi1 rho) $;

-- The Proof System of Matching Logic
axiom prop_1 (phi1 phi2: Pattern):
--  $ wf phi1 $ > $ wf phi2 $ >
  $ phi1 -> phi2 -> phi1 $;
axiom prop_2 (phi1 phi2 phi3: Pattern):
--  $ wf phi1 $ > $ wf phi2 $ > $ wf phi3 $ >
  $ (phi1 -> phi2 -> phi3) -> (phi1 -> phi2) -> (phi1 -> phi3) $;
axiom prop_3 (phi1 phi2: Pattern):
--  $ wf phi1 $ > $ wf phi2 $ >
  $ (~phi1 -> ~phi2) -> phi2 -> phi1 $;
axiom mp (phi1 phi2: Pattern):
--  $ wf phi1 $ > $ wf phi2 $ >
  $ phi1 -> phi2 $ > $ phi1 $ > $ phi2 $;
axiom exists_intro {x y: EVar} (phi: Pattern x y) (rho: Pattern y):
--  $ wf phi $ >
  $ e[ eVar y / x ] phi ==> rho $ > $ rho -> exists x phi $;
axiom exists_intro_same_var {x: EVar} (phi: Pattern x):
--  $ wf phi $ >
  $ phi -> exists x phi $;
axiom exists_generalization {x: EVar} (phi1: Pattern x) (phi2: Pattern):
--  $ wf phi1 $ > $ wf phi2 $ >
  $ phi1 -> phi2 $ > $ (exists x phi1) -> phi2 $;
axiom propag_bot (ctx rho: Pattern):
--  $ wf ctx $ >
  $ _AppCtx ctx bot rho $ >
  $ rho -> bot $;
axiom propag_or (ctx phi1 phi2 rho12 rho1 rho2: Pattern):
--  $ wf ctx $ > $ wf phi1 $ > $ wf phi2 $ >
  $ _AppCtx ctx (phi1 \/ phi2) rho12 $ >
  $ _AppCtx ctx phi1 rho1 $ >
  $ _AppCtx ctx phi2 rho2 $ >
  $ rho12 -> (rho1 \/ rho2) $;
axiom propag_exists (ctx rho2: Pattern) {x: EVar} (phi rho1: Pattern x):
--  $ wf ctx $ > $ wf phi $ >
  $ _AppCtx ctx phi rho1 $ >
  $ _AppCtx ctx (exists x phi) rho2 $ >
  $ rho2 -> (exists x rho1) $;
axiom framing (ctx phi1 phi2 rho1 rho2: Pattern):
--  $ wf ctx $ > $ wf phi1 $ > $ wf phi2 $ >
  $ _AppCtx ctx phi1 rho1 $ >
  $ _AppCtx ctx phi2 rho2 $ >
  $ phi1 -> phi2 $ >
  $ rho1 -> rho2 $;
axiom set_var_subst {X: SVar} (phi psi rho: Pattern X):
--  $ wf phi $ > $ wf psi $ > $ wf rho $ >
  $ s[ psi / X ] phi ==> rho $ > $ phi $ > $ rho $;
axiom pre_fixpoint {X: SVar} (phi: Pattern X) (rho: Pattern):
--  $ wf phi $ > $ wf rho $ >
  $ _Positive X phi $ >
  $ s[ mu X phi / X ] phi ==> rho $ >
  $ rho -> (mu X phi) $;
axiom KT {X: SVar} (phi psi rho: Pattern X):
--  $ wf phi $ > $ wf psi $ > $ wf rho $ >
  $ _Positive X phi $ >
  $ s[ psi / X ] phi ==> rho $ >
  $ rho -> psi $ >
  $ (mu X phi) -> psi $;
axiom existence {x: EVar}: $ exists x (eVar x) $;
axiom singleton (ctx1 ctx2: Pattern) {x: EVar} (phi rho1 rho2: Pattern x):
--  $ wf ctx1 $ > $ wf ctx2 $ > $ wf phi $ >
  $ _NestedAppCtx ctx1 ((eVar x) /\ phi) rho1 $ >
  $ _NestedAppCtx ctx2 ((eVar x) /\ ~phi) rho2 $ >
  $ ~(rho1 /\ rho2) $;