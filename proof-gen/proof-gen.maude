fmod MATCHING-LOGIC-SEXPR is
    including QID .

    --- Core Matching Logic Syntax
    ------------------------------

    sort Pattern EVar SVar .
    op [ eVar _ ] : EVar -> Pattern [ctor] .
    op [ sVar _ ] : SVar -> Pattern [ctor] .
    op [ sym  _ ] : Qid -> Pattern [ctor] .
    op   bot   : -> Pattern [ctor] .
    op [ imp _ _ ] : Pattern Pattern -> Pattern [ctor] .
    op [ exists _ _ ] : EVar Pattern -> Pattern [ctor] .
    op [ mu _ _ ] : SVar Pattern -> Pattern [ctor] .

    --- metavars
    ------------

    sort MetaVar .
    subsort MetaVar < Pattern .
    ops PHI PHI1 PHI2 : -> MetaVar .
    ops PSI PSI1 PSI2 : -> MetaVar .

    sort MetaSVar MetaEVar .
    subsort MetaSVar < SVar .
    subsort MetaEVar < EVar .
    ops MX MY : -> MetaSVar .
    ops Mx My : -> MetaEVar .

    --- Notation
    ------------

    --- The Notation sort subsorts Pattern, and provides the desugar operator .
    --- This operator peforms one step of desugaring.

    sort Notation .
    subsort Notation < Pattern .
    op desugar : Notation -> Pattern .

    --- Standard matching logic sugar
    ---------------------------------

    vars phi psi : Pattern .
    vars X Y : SVar .
    vars x y : EVar .

    op [not _] : Pattern -> Notation [ctor] .
    eq desugar([not phi]) = [imp phi bot] .

    op top : -> Notation [ctor] .
    eq desugar(top) = [not bot] .

    op [or _ _] : Pattern Pattern -> Notation [ctor] .
    eq desugar([or phi psi]) = [imp [not phi] psi] .

    op [and _ _] : Pattern Pattern -> Notation [ctor] .
    eq desugar([and phi psi]) = [imp [not phi] psi] .

    op [forall _ _] : EVar Pattern -> Notation [ctor] .
    eq desugar([forall x psi]) = [not [exists x psi] ] .

    op [nu _ _] : SVar Pattern -> Notation [ctor] .
    eq desugar([nu X psi]) = [not [mu X [not psi] ] ] .
endfm

fmod METAMATH-ZERO is
    protecting MATCHING-LOGIC-SEXPR .
    protecting META-LEVEL .
    protecting INT .

    including QID .
    sort MM0Decl MM0BinderList MM0Type MM0Formula .
    op none : -> MM0Decl .
    op _ _ : MM0Decl MM0Decl -> MM0Decl [assoc format(d n d)] .

    op no-binders : -> MM0BinderList .
    op { _ colon _ } : Qid MM0Type -> MM0BinderList .
    op [ _ colon _ ] : Qid MM0Type -> MM0BinderList .
    op _ _ : MM0BinderList MM0BinderList -> MM0BinderList [assoc] .

    ops EVar SVar Pattern : -> MM0Type . 
    op import _ ; : String -> MM0Decl .
    op def _ space _ colon _  = _ ; : Qid MM0BinderList MM0Type MM0Formula -> MM0Decl .

    subsort Pattern < MM0Formula .
    op $ _ $ : Pattern -> MM0Formula [ctor] .

    op prelude : -> MM0Decl .
    eq prelude
     = import "./00-matching-logic.mm0" ;
       defs-for-notation(top)
       defs-for-notation([not PHI]) 
       defs-for-notation([or PHI1 PHI2]) 
       defs-for-notation([and PHI1 PHI2]) 
       defs-for-notation([forall Mx PHI2]) 
       defs-for-notation([nu MX PHI2]) 
     .
    vars T : Term .
    vars Args Ts : TermList .
    vars Q : Qid .
    vars C : Constant .
    vars N : Notation .

    op notation-name : Notation -> Qid .
    op notation-name : Term -> Qid .
    eq notation-name(N) = notation-name(upTerm(N)) .
    eq notation-name(C) = getName(C) .
    --- This assumes all notation is in sexpr format.
    eq notation-name(Q[Args]) = qid(substr(string(Q), 2, find(string(Q), "_", 0) - 2) ) .

    op notation-binders      : Notation -> MM0BinderList .
    op notation-binders      : Term -> MM0BinderList .
    op notation-binders-args : TermList -> MM0BinderList .
    eq notation-binders(N) = notation-binders(upTerm(N)) .
    eq notation-binders(C) = no-binders .
    eq notation-binders(Q[Args]) = notation-binders-args(Args) . --- TODO: Parse out underscores?
    eq notation-binders-args(empty) = no-binders .
   ceq notation-binders-args((T , Ts)) = [ getName(T) colon Pattern ] notation-binders-args(Ts)
    if getType(T) == 'MetaVar .
   ceq notation-binders-args((T , Ts)) = { getName(T) colon SVar } notation-binders-args(Ts)
    if getType(T) == 'MetaSVar .
   ceq notation-binders-args((T , Ts)) = { getName(T) colon EVar } notation-binders-args(Ts)
    if getType(T) == 'MetaEVar
     .

    op defs-for-notation : Notation -> MM0Decl . 
    op defs-for-notation : Term -> MM0Decl . 
    eq defs-for-notation(N)
     = def notation-name(N) space notation-binders(N) colon Pattern = $ desugar(N) $ ; .

endfm
