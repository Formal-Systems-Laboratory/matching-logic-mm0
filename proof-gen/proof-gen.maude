fmod MATCHING-LOGIC-SEXPR is
    including QID .

    --- Core Matching Logic Syntax
    ------------------------------

    sort Pattern EVar SVar .
    op [ eVar _ ] : EVar -> Pattern [ctor] .
    op [ sVar _ ] : SVar -> Pattern [ctor] .
    op [ sym  _ ] : Qid -> Pattern [ctor] .
    op   bot   : -> Pattern [ctor] .
    op [ imp _ _ ] : Pattern Pattern -> Pattern [ctor] .
    op [ app _ _ ] : Pattern Pattern -> Pattern [ctor] .
    op [ exists _ _ ] : EVar Pattern -> Pattern [ctor] .
    op [ mu _ _ ] : SVar Pattern -> Pattern [ctor] .

    --- metavars
    ------------

    sort MetaVar .
    subsort MetaVar < Pattern .
    ops PHI PHI1 PHI2 : -> MetaVar .
    ops PSI PSI1 PSI2 : -> MetaVar .

    sort MetaSVar MetaEVar .
    subsort MetaSVar < SVar .
    subsort MetaEVar < EVar .
    ops MX MY : -> MetaSVar .
    ops Mx My : -> MetaEVar .

    --- Notation
    ------------

    --- The Notation sort subsorts Pattern, and provides the desugar operator .
    --- This operator peforms one step of desugaring.

    sort Notation .
    subsort Notation < Pattern .
    op desugar : Notation -> Pattern .

    --- Standard matching logic sugar
    ---------------------------------

    vars phi psi : Pattern .
    vars X Y : SVar .
    vars x y : EVar .

    op [not _] : Pattern -> Notation [ctor] .
    eq desugar([not phi]) = [imp phi bot] .

    op top : -> Notation [ctor] .
    eq desugar(top) = [not bot] .

    op [or _ _] : Pattern Pattern -> Notation [ctor] .
    eq desugar([or phi psi]) = [imp [not phi] psi] .

    op [and _ _] : Pattern Pattern -> Notation [ctor] .
    eq desugar([and phi psi]) = [imp [not phi] psi] .

    op [forall _ _] : EVar Pattern -> Notation [ctor] .
    eq desugar([forall x psi]) = [not [exists x psi] ] .

    op [nu _ _] : SVar Pattern -> Notation [ctor] .
    eq desugar([nu X psi]) = [not [mu X [not psi] ] ] .
endfm

fmod METAMATH-ZERO is
    protecting MATCHING-LOGIC-SEXPR .
    protecting META-LEVEL .
    protecting INT .

   --- MetaMathZero Syntax
   -----------------------

    including QID .
    sort MM0Decl MM0BinderList MM0Type MM0Formula MM0Proof .
    op none : -> MM0Decl .
    op _ _ : MM0Decl MM0Decl -> MM0Decl [assoc format(d n d)] .

    op no-binders : -> MM0BinderList .
    op { _ colon _ } : Qid MM0Type -> MM0BinderList .
    op [ _ colon _ ] : Qid MM0Type -> MM0BinderList .
    op _ _ : MM0BinderList MM0BinderList -> MM0BinderList [assoc] .

    ops EVar SVar Pattern : -> MM0Type . 
    op import _ ; : String -> MM0Decl .
    op def _ space _ colon _  = _ ; : Qid MM0BinderList MM0Type MM0Formula -> MM0Decl .
    op theorem _ space _ colon _  = quote _ ; : Qid MM0BinderList MM0Formula MM0Proof -> MM0Decl .

    subsort Qid < MM0Proof .
    op underscore : -> MM0Proof [ctor] .
    op [ _ space _ ]      : Qid MM0ProofList -> MM0Proof [ctor] . 

    sort MM0ProofList .
    subsort MM0Proof < MM0ProofList .
    op id : -> MM0ProofList [ctor] .
    op _ _ : MM0ProofList MM0ProofList -> MM0ProofList [ctor assoc id: nil prec 25] .
    eq [ Q space id ] = Q .

    subsort Pattern < MM0Formula .
    op $ _ $ : Pattern -> MM0Formula [ctor] .

   --- Matching Logic MM0 Prelude
   ------------------------------

    op prelude : -> MM0Decl .
    eq prelude
     = import "./00-matching-logic.mm0" ;
       prelude-for-notation(top)
       theorems-for-notation([not PHI]) 
       theorems-for-notation([or PHI1 PHI2]) 
       theorems-for-notation([and PHI1 PHI2]) 
       prelude-for-notation([forall Mx PHI2]) 
       prelude-for-notation([nu MX PHI2]) 
     .

    op prelude-for-notation : Notation -> MM0Decl .
    eq prelude-for-notation(N) = defs-for-notation(N) theorems-for-notation(N) .

   -----------------------------------------

    vars T : Term .
    vars Args Ts : TermList .
    vars Q : Qid .
    vars C : Constant .

    vars Phi Phi1 Phi2 : Pattern .
    vars N : Notation .

   --- Generating MM0 defs for each notation
   -----------------------------------------

    op defs-for-notation : Notation -> MM0Decl . 
    op defs-for-notation : Term -> MM0Decl . 
    eq defs-for-notation(N)
     = def notation-name(N) space notation-binders(N) colon Pattern = $ desugar(N) $ ; .

    op notation-name : Notation -> Qid .
    op notation-name : Term -> Qid .
    eq notation-name(N) = notation-name(upTerm(N)) .
    eq notation-name(C) = getName(C) .
    --- This assumes all notation is in sexpr format.
    --- TODO: Why multiple parses?
    eq notation-name(Q[Args]) = qid(substr(string(Q), 2, find(string(Q), "_", 2) - 2)) .

    op notation-binders      : Notation -> MM0BinderList .
    op notation-binders      : Term -> MM0BinderList .
    op notation-binders-args : TermList -> MM0BinderList .
    eq notation-binders(N) = notation-binders(upTerm(N)) .
    eq notation-binders(C) = no-binders .
    eq notation-binders(Q[Args]) = notation-binders-args(Args) . --- TODO: Parse out underscores?
    eq notation-binders-args(empty) = no-binders .
   ceq notation-binders-args((T , Ts)) = [ getName(T) colon Pattern ] notation-binders-args(Ts)
    if getType(T) == 'MetaVar .
   ceq notation-binders-args((T , Ts)) = { getName(T) colon SVar } notation-binders-args(Ts)
    if getType(T) == 'MetaSVar .
   ceq notation-binders-args((T , Ts)) = { getName(T) colon EVar } notation-binders-args(Ts)
    if getType(T) == 'MetaEVar
     .

   --- Generating MM0 theorems for each notation
   ---------------------------------------------

    op theorems-for-notation : Notation -> MM0Decl . 
    op theorems-for-notation : Term -> MM0Decl . 
    eq theorems-for-notation(N)
     = theorem-pos-in(N) . 

    op theorem-name : Qid Notation -> Qid .
    eq theorem-name(Q, N) = qid(string(Q) +  string(notation-name(N))) .

   --- Generating Proof: Positivity
    op theorem-pos-in : Notation -> MM0Decl .
    eq theorem-pos-in(N)
     = theorem theorem-name('pos_in_, N) space
               theorem-pos-in-binders(desugar(N)) colon
               $ underscorePositive MX N $
             = quote theorem-pos-in-proof(desugar(N)) ; .

    op theorem-pos-in-binders : Pattern -> MM0BinderList .

    op theorem-pos-in-proof : Pattern -> MM0Proof .
    eq theorem-pos-in-proof([imp Phi1 Phi2])
     = [ 'positive_in_imp space theorem-neg-in-proof(Phi1) theorem-pos-in-proof(Phi2) ] .
    eq theorem-pos-in-proof([app Phi1 Phi2])
     = [ 'positive_in_app space theorem-pos-in-proof(Phi1) theorem-pos-in-proof(Phi2) ] .

    eq theorem-pos-in-proof(N) = [ theorem-name('pos_in_, N) space underscore ] . 

    op $ underscorePositive _ _ $ : SVar Pattern -> MM0Formula .

    op theorem-neg-in-proof : Pattern -> MM0Proof .
endfm
