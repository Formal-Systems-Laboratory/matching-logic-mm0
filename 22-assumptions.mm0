import "20-theory-words.mm0";

--- This file contains unproven theorems as axioms for the theory of words.
--- As we prove them, we shall move them to an appropriate file.

axiom alpha_rename_ctximp_app {sBox: SVar} {eBox1 eBox2: EVar}
                              (phi: Pattern sBox) (psi: Pattern sBox)
  : $(ctximp_app sBox phi psi eBox1) <-> (ctximp_app sBox phi psi eBox2)$;

--- NB: This probably generalizes to any contextual implication.
axiom der_equality_forward_lemma (l phi psi: Pattern): $(l . psi) /\ phi -> l . derivative l phi$;

--- Derivative simplifications
axiom regex_eq_der_kleene_wrt_a  {X: SVar} (Alpha: Pattern X):
  $ (derivative a (kleene X Alpha)) <-> ((derivative a Alpha) . (kleene X Alpha)) $;
axiom regex_eq_der_kleene_wrt_b  {X: SVar} (Alpha: Pattern X):
  $ (derivative b (kleene X Alpha)) <-> ((derivative b Alpha) . (kleene X Alpha)) $;
axiom regex_eq_der_concat_wrt_a  (Alpha Beta: Pattern) :
  $ (derivative a (Alpha . Beta)) <-> ((derivative a Alpha) . Beta) \/  ((epsilon /\ Alpha) . (derivative a Beta)) $;
axiom regex_eq_der_concat_wrt_b  (Alpha Beta: Pattern) :
  $ (derivative b (Alpha . Beta)) <-> ((derivative b Alpha) . Beta) \/  ((epsilon /\ Alpha) . (derivative b Beta)) $;

--- Theorems that reduce the size of the automata/proof
axiom regex_eq_double_kleene {X: SVar} (Alpha: Pattern X): $ (kleene X (kleene X Alpha)) <-> (kleene X Alpha) $;

--- EWP related simplifications
axiom regex_eq_ewp_concat (Alpha Beta: Pattern):
  $ epsilon /\ (Alpha . Beta) <-> (epsilon /\ Alpha) /\ (epsilon /\ Beta) $;
axiom regex_eq_ewp_not_concat (Alpha Beta: Pattern):
  $ (epsilon /\ ~(Alpha . Beta)) <-> ((epsilon /\ ~ Alpha) \/ (epsilon /\ ~ Beta)) $;

--- top-implies-fp
axiom top_implies_fp_leaf {box: SVar} (phi : Pattern box) {dummy: EVar}
--- TODO: Add eFresh hypothesis? eFresh box phi
  : $( ctximp_app box (sVar box . top_letter) phi dummy) . top_letter -> phi $ ;
axiom top_implies_fp_interior  {X: SVar} {box: SVar} {dummy: EVar}
--- TODO: Add eFresh hypothesis? eFresh X { fp_unf_a fp_unf_b fp_ctximp_a fp_ctximp_b }
  (fp_unf_a fp_unf_b fp_ctximp_a fp_ctximp_b : Pattern X box dummy)

  (he_a: $epsilon -> s[ (mu X (epsilon \/ ((a . fp_unf_a) \/ (b . fp_unf_b)))) / X ] fp_unf_a$)
  (he_b: $epsilon -> s[ (mu X (epsilon \/ ((a . fp_unf_a) \/ (b . fp_unf_b)))) / X ] fp_unf_b$)
  (ha: $(s[ (ctximp_app box (sVar box . top_letter) (mu X (epsilon \/ ((a . fp_unf_a) \/ (b . fp_unf_b)))) dummy) / X ] (fp_ctximp_a . top_letter))
          -> (s[ (mu X (epsilon \/ ((a . fp_unf_a) \/ (b . fp_unf_b)))) / X ] fp_unf_a)$)
  (hb: $(s[ (ctximp_app box (sVar box . top_letter) (mu X (epsilon \/ ((a . fp_unf_a) \/ (b . fp_unf_b)))) dummy) / X ] (fp_ctximp_b . top_letter))
          -> (s[ (mu X (epsilon \/ ((a . fp_unf_a) \/ (b . fp_unf_b)))) / X ] fp_unf_b)$)
  : ------------------------
  $(mu X (epsilon \/ ((a . fp_ctximp_a) \/ (b . fp_ctximp_b)))) . top_letter -> (mu X (epsilon \/ ((a . fp_unf_a) \/ (b . fp_unf_b))))$;
