import "20-theory-words.mm0";

--- This file contains unproves theorems as axioms for the theory of words.
--- As we prove them, we shall move them to an appropriate file.

--- The following theorem can likely only be proved as a metatheorem, as we need
--- to induct on the context ctx. We should replace this a concrete proof for
--- derivatives.
axiom ctximp_in_ctx_reverse {box: SVar} {dummy: EVar} (ctx psi: Pattern box)
: $psi -> app[ (ctximp_app box ctx psi dummy) / box ] ctx$;

axiom eq_der_a_concat {box: SVar} {dummy: EVar} (psi phi: Pattern):
    $(derivative box dummy a (phi . psi)) <->   (derivative box dummy a phi) . psi
                                   \/ ((epsilon /\ phi) . (derivative box dummy a psi))$;
axiom eq_der_a_or {box: SVar} {dummy: EVar} (phi psi : Pattern):
    $(derivative box dummy a (phi \/ psi)) <-> (derivative box dummy a phi) \/ (derivative box dummy a psi)$;
axiom eq_der_a_kleene {box: SVar} {dummy: EVar} {X: SVar} (phi: Pattern X):
    $(derivative box dummy a (kleene X phi)) <-> (derivative box dummy a phi) . (kleene X phi)$;
axiom eq_der_a_not {box: SVar} {dummy: EVar} (phi: Pattern) :
    $(derivative box dummy a (~ phi)) <-> ~ (derivative box dummy a phi)$;
axiom eq_der_a_imp {box: SVar} {dummy: EVar} (psi phi: Pattern) :
    $(derivative box dummy a (phi -> psi)) <-> ((derivative box dummy a phi) -> (derivative box dummy a psi))$;


--- fp-implies-alpha
--------------------

axiom regex_eq_der_epsilon_wrt_a {box: SVar} {dummy: EVar} :
  $ (derivative box dummy a epsilon) <-> bot $;
axiom regex_eq_der_epsilon_wrt_b {box: SVar} {dummy: EVar} :
  $ (derivative box dummy b epsilon) <-> bot $;

axiom regex_eq_der_same_a_wrt_a {box: SVar} {dummy: EVar} :
  $ (derivative box dummy a a) <-> epsilon $;
axiom regex_eq_der_same_a_wrt_b {box: SVar} {dummy: EVar} :
  $ (derivative box dummy b b) <-> epsilon $;

axiom regex_eq_der_diff_a_wrt_a {box: SVar} {dummy: EVar} :
  $ (derivative box dummy a b) <-> bot $;
axiom regex_eq_der_diff_a_wrt_b {box: SVar} {dummy: EVar} :
  $ (derivative box dummy b a) <-> bot $;

axiom regex_eq_der_kleene_wrt_a {box: SVar} {dummy: EVar} {X: SVar} (Alpha: Pattern X): $ (derivative box dummy a (kleene X Alpha)) <-> ((derivative box dummy a Alpha) . (kleene X Alpha)) $;
axiom regex_eq_der_kleene_wrt_b {box: SVar} {dummy: EVar} {X: SVar} (Alpha: Pattern X): $ (derivative box dummy b (kleene X Alpha)) <-> ((derivative box dummy b Alpha) . (kleene X Alpha)) $;
axiom regex_eq_der_concat_wrt_a {box: SVar} {dummy: EVar} (Alpha Beta: Pattern) : $ (derivative box dummy a (Alpha . Beta)) <-> ((derivative box dummy a Alpha) . Beta) \/  ((epsilon /\ Alpha) . (derivative box dummy a Beta)) $;
axiom regex_eq_der_concat_wrt_b {box: SVar} {dummy: EVar} (Alpha Beta: Pattern) : $ (derivative box dummy b (Alpha . Beta)) <-> ((derivative box dummy b Alpha) . Beta) \/  ((epsilon /\ Alpha) . (derivative box dummy b Beta)) $;

axiom regex_eq_double_kleene {X: SVar} (Alpha: Pattern X): $ (kleene X (kleene X Alpha)) <-> (kleene X Alpha) $;

axiom regex_eq_eps_kleene { X: SVar }: $ (kleene X epsilon) <-> epsilon $;
