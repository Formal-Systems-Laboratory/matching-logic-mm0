import "20-theory-words.mm0";

--- This file contains unproves theorems as axioms for the theory of words.
--- As we prove them, we shall move them to an appropriate file.

--- The following theorem can likely only be proved as a metatheorem, as we need
--- to induct on the context ctx. We should replace this a concrete proof for
--- derivatives.
axiom ctximp_in_ctx_reverse {box: SVar} (ctx: Pattern box)
: $psi -> app[ (ctximp_app box ctx psi dummy) / box ] ctx$;

axiom eq_der_a_concat:
    $(derivative a (phi . psi)) <->   (derivative a phi) . psi
                                   \/ ((epsilon /\ phi) . (derivative a psi))$;
axiom eq_der_a_or:
    $(derivative a (phi \/ psi)) <-> (derivative a phi) \/ (derivative a psi)$;
axiom eq_der_a_kleene {X: SVar} (phi: Pattern X):
    $(derivative a (kleene X phi)) <-> (derivative a phi) . (kleene X phi)$;
axiom eq_der_a_not:
    $(derivative a (~ phi)) <-> ~ (derivative a phi)$;
axiom eq_der_a_imp:
    $(derivative a (phi -> psi)) <-> ((derivative a phi) -> (derivative a psi))$;


--- top-implies-fp
------------------

axiom top_implies_fp_init {X: SVar} (h: $phi . top_letter -> phi$)
    : $top_word X -> phi$;

axiom top_implies_fp_leaf (phi : Pattern box)
    : $( ctximp_app X (sVar X . top_letter) phi box ) . top_letter -> phi $ ;

axiom top_implies_fp_interior {X: SVar}
    (phi_a phi_b psi_a psi_b : Pattern X box)
    (he_a: $epsilon -> s[ (mu X (epsilon \/ ((a . phi_a) \/ (b . phi_b)))) / X ] phi_a$)
    (he_b: $epsilon -> s[ (mu X (epsilon \/ ((a . phi_a) \/ (b . phi_b)))) / X ] phi_b$)
                                --- ^^^ Together these give (letter -> rhs)
    (ha: $(s[ (ctximp_app Box (sVar Box . top_letter) (mu X (epsilon \/ ((a . phi_a) \/ (b . phi_b)))) box) / X ] (psi_a . top_letter))
            -> (s[ (mu X (epsilon \/ ((a . phi_a) \/ (b . phi_b)))) / X ] phi_a)$)
    (hb: $(s[ (ctximp_app Box (sVar Box . top_letter) (mu X (epsilon \/ ((a . phi_a) \/ (b . phi_b)))) box) / X ] (psi_b . top_letter))
            -> (s[ (mu X (epsilon \/ ((a . phi_a) \/ (b . phi_b)))) / X ] phi_b)$)
  : ------------------------
    $(mu X (epsilon \/ ((a . psi_a) \/ (b . psi_b)))) . top_letter -> (mu X (epsilon \/ ((a . phi_a) \/ (b . phi_b))))$;


--- fp-implies-alpha
--------------------

axiom regex_eq_der_epsilon_wrt_a:
  $ (derivative a epsilon) <-> bot $;
axiom regex_eq_der_epsilon_wrt_b:
  $ (derivative b epsilon) <-> bot $;

axiom regex_eq_der_same_a_wrt_a:
  $ (derivative a a) <-> epsilon $;
axiom regex_eq_der_same_a_wrt_b:
  $ (derivative b b) <-> epsilon $;

axiom regex_eq_der_diff_a_wrt_a:
  $ (derivative a b) <-> bot $;
axiom regex_eq_der_diff_a_wrt_b:
  $ (derivative b a) <-> bot $;

axiom regex_eq_der_kleene_wrt_a {X: SVar} (Alpha: Pattern X): $ (derivative a (kleene X Alpha)) <-> ((derivative a Alpha) . (kleene X Alpha)) $;
axiom regex_eq_der_kleene_wrt_b {X: SVar} (Alpha: Pattern X): $ (derivative b (kleene X Alpha)) <-> ((derivative b Alpha) . (kleene X Alpha)) $;
axiom regex_eq_der_concat_wrt_a: $ (derivative a (Alpha . Beta)) <-> ((derivative a Alpha) . Beta) \/  ((epsilon /\ Alpha) . (derivative a Beta)) $;
axiom regex_eq_der_concat_wrt_b: $ (derivative b (Alpha . Beta)) <-> ((derivative b Alpha) . Beta) \/  ((epsilon /\ Alpha) . (derivative b Beta)) $;

axiom regex_eq_double_kleene {X: SVar} (Alpha: Pattern X): $ (kleene X (kleene X Alpha)) <-> (kleene X Alpha) $;

axiom regex_eq_eps_kleene: $ (kleene X epsilon) <-> epsilon $;
