import "definedness-core.mm1";
import "propositional.mm1";

-- do (def (deduction-thm-lemma phi ppsi) (
--  ));

def defCtx {.x: EVar}: Pattern = $ exists x (|^ eVar x ^|) $;
theorem defAppCtx (phi: Pattern): $ _AppCtx defCtx phi (|^ phi ^|) $ = '(! appCtxR x);
theorem defNestedAppCtx (phi: Pattern): $ _NestedAppCtx defCtx phi (|^ phi ^|) $ = '(nestedAppCtxR (! nestedAppCtxVar x));
theorem singletonDef {x: EVar} (phi: Pattern x):
  $ ~(|^ eVar x /\ phi ^| /\ |^ eVar x /\ ~phi ^|) $ = '(singleton defNestedAppCtx defNestedAppCtx);
theorem framingDef (h: $ phi1 -> phi2 $):
  $ |^ phi1 ^| -> |^ phi2 ^| $ = '(framing defAppCtx defAppCtx h);

theorem prop_43_bot (rho: Pattern): $ bot -> rho $ = 'absurdum;
theorem prop_43_or (ctx phi1 phi2 rho12 rho1 rho2: Pattern)
  (h1: $ _AppCtx ctx (phi1 \/ phi2) rho12 $)
  (h2: $ _AppCtx ctx phi1 rho1 $)
  (h3: $ _AppCtx ctx phi2 rho2 $):
  $ (rho1 \/ rho2) -> rho12 $ = '(eori (framing h2 h1 orl) (framing h3 h1 orr));
theorem prop_43_exists (ctx rho2: Pattern) {x: EVar} (phi rho1: Pattern x)
  (h1: $ _AppCtx ctx phi rho1 $)
  (h2: $ _AppCtx ctx (exists x phi) rho2 $):
  $ (exists x rho1) -> rho2 $ =
    '(exists_generalization @ framing h1 h2 exists_intro_same_var);

theorem univ_gene {x: EVar} (phi: Pattern x)
  (p: $ phi $):
  $ forall x phi $ = '(exists_generalization @ notnot1 p);
theorem var_subst {x y: EVar} (phi: Pattern x y) (rho: Pattern y)
  (subst: $ e[ eVar y / x ] phi ==> rho $):
  $ (forall x phi) -> rho $ =
    '(con1 @ exists_intro @ eSubstitution_in_not subst);
theorem var_subst_same_var {x: EVar} (phi: Pattern x):
  $ (forall x phi) -> phi $ = '(con1 exists_intro_same_var);

theorem lemma_46
  (ctxp: $ _AppCtx ctx (~ phi) rhop $)
  (ctxb: $ _AppCtx ctx bot rhob $)
  (p : $ phi $):
  $ ~rhop $ = '(syl (propag_bot ctxb) (framing ctxp ctxb (notnot1 p)));

theorem eqiv_to_eq (h: $ phi <-> psi $):
  $ phi == psi $ = '(lemma_46 defAppCtx defAppCtx h);

theorem eq_intro: $ phi == phi $ = '(eqiv_to_eq biid);

theorem membership_intro {x: EVar} (phi: Pattern x)
  (h: $ phi $):
  $ forall x (x in phi) $ =
  '(univ_gene @ framingDef (iand id (a1i h)) definedness);

theorem membership_elim {x: EVar} (phi: Pattern)
  (h: $ forall x (x in phi) $):
  $ phi $ =
  '(dne @ exists_generalization (dne (dne (singleton defNestedAppCtx (! nestedAppCtxVar box)) (var_subst_same_var h))) existence);

theorem membership_var {x y: EVar}:
  $ (x in (eVar y)) == (eVar x == eVar y) $ = '(eqiv_to_eq @ iani
  (rsyl (iand (dne singletonDef) (imim1i (framingDef ancom) @ dne @ singleton defNestedAppCtx defNestedAppCtx)) @ rsyl (anri not_distr_or) @ rsyl (con3 @ propag_or defAppCtx defAppCtx defAppCtx) @ con3 @ framing defAppCtx defAppCtx @ anr lemma_51)
  (propag_or defAppCtx defAppCtx defAppCtx @ framingDef or_imp_xor_and @ prop_43_or defAppCtx defAppCtx defAppCtx @ orl definedness)
  );

theorem membership_not_lemma {x: EVar} (phi: Pattern x):
  $ (x in phi) \/ (x in ~phi) $ = '(propag_or defAppCtx defAppCtx defAppCtx @ framingDef (exp @ iand anl @ curry @ com12 dne) definedness);

theorem membership_not {x: EVar} (phi: Pattern x):
  $ (x in ~phi) == ~(x in phi) $ =
  '(eqiv_to_eq @ iani (con2 @ dne singletonDef) membership_not_lemma);

theorem framing_in {x: EVar} (phi1 phi2: Pattern x)
  (h: $ phi1 -> phi2 $): $ (x in phi1) -> (x in phi2)$ = '(framingDef @ anim2 h);

theorem membership_and {x: EVar} (phi1 phi2: Pattern x):
  $ x in (phi1 /\ phi2) == (x in phi1) /\ (x in phi2) $ =
  '(eqiv_to_eq @ iani
    (iand (framingDef @ iand anl anrl) (framingDef @ iand anl anrr))
    (syl dne @ con2 @ rsyl membership_not_lemma @ rsyl (framing_in @ anl notan) @ rsyl
      (framingDef @ anl andi)
      (rsyl (propag_or defAppCtx defAppCtx defAppCtx) @ rsyl (orim (con2 @ dne singletonDef) (con2 @ dne singletonDef)) (anr notan))));

-- theorem membership_exists {x y: EVar} (phi: Pattern x y):
--   $ (x in (exists y phi)) == (exists y (x in phi)) $ = '(eqiv_to_eq @ iani
--     (_)
--     (_));