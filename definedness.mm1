import "definedness-core.mm1";
import "propositional.mm1";

theorem exists_generalization_strict {x: EVar} (phi1: Pattern x) (phi2: Pattern)
  (h: $ phi1 -> phi2 $):
  $ (exists x phi1) -> phi2 $ =
  '(exists_generalization eFresh_triv h);
theorem propag_exists_strict {box: SVar} {x: EVar} (ctx: Pattern box) (phi: Pattern x):
  $ app[ exists x phi / box ] ctx -> exists x (app[ phi / box ] ctx) $ =
  '(propag_exists eFresh_triv);

theorem norm_not (phi phi2: Pattern)
  (h: $ Norm phi phi2 $):
  $ Norm (~phi) (~phi2) $ =
  '(norm_imp h norm_refl);
theorem norm_or (phi psi phi2 psi2: Pattern)
  (h1: $ Norm phi phi2 $)
  (h2: $ Norm psi psi2 $):
  $ Norm (phi \/ psi) (phi2 \/ psi2) $ =
  '(norm_imp (norm_not h1) h2);
theorem norm_and (phi psi phi2 psi2: Pattern)
  (h1: $ Norm phi phi2 $)
  (h2: $ Norm psi psi2 $):
  $ Norm (phi /\ psi) (phi2 /\ psi2) $ =
  '(norm_not @ norm_imp h1 (norm_not h2));

theorem framing_norm {box: SVar} (ctx: Pattern box) (phi1 phi2 rho1 rho2: Pattern)
  (h1: $ Norm (app[ phi1 / box ] ctx) rho1 $)
  (h2: $ Norm (app[ phi2 / box ] ctx) rho2 $)
  (h3: $ phi1 -> phi2 $):
  $ rho1 -> rho2 $ = '(norm (norm_imp h1 h2) @ framing h3);
theorem singleton_norm {box1 box2: SVar} {x: EVar}
  (ctx1: Pattern box1 x) (ctx2: Pattern box2 x)
  (phi rho1 rho2: Pattern x)
  (h1: $ Norm (app[ (eVar x) /\ phi / box1 ] ctx1) rho1 $)
  (h2: $ Norm (app[ (eVar x) /\ ~phi / box2 ] ctx2) rho2 $):
  $ ~(rho1 /\ rho2) $ =
  '(norm (norm_not @ norm_and h1 h2) singleton);

theorem eSubstitution_in_not {x: EVar} (psi phi: Pattern x):
  $ Norm (e[ psi / x ] ~phi) (~e[ psi / x ] phi) $ =
  '(norm_trans eSubstitution_in_imp @ norm_imp norm_refl eSubstitution_in_bot);

theorem sSubstitution_in_not {X: SVar} (psi phi: Pattern X):
  $ Norm (s[ psi / X ] ~phi) (~(s[ psi / X ] phi)) $ =
  '(norm_trans sSubstitution_in_imp @ norm_imp norm_refl sSubstitution_in_bot);

def defCtx {box: SVar}: Pattern box = $ (|^ sVar box ^|) $;
theorem defNorm {box: SVar} (phi: Pattern):
  $ Norm (app[ phi / box ] (defCtx box)) (|^ phi ^|) $ =
  '(norm_trans appCtxR @ norm_app norm_refl appCtxVar);
theorem singletonDef {x: EVar} (phi: Pattern x):
  $ ~(|^ eVar x /\ phi ^| /\ |^ eVar x /\ ~phi ^|) $ =
  '(singleton_norm (! defNorm box1) (! defNorm box2));
theorem framingDef (h: $ phi1 -> phi2 $):
  $ |^ phi1 ^| -> |^ phi2 ^| $ =
  '(framing_norm (! defNorm box) defNorm h);

theorem prop_43_bot (rho: Pattern): $ bot -> rho $ = 'absurdum;
theorem prop_43_or {box: SVar} (ctx: Pattern box) (phi1 phi2: Pattern):
  $ (app[ phi1 / box ] ctx \/ app[ phi2 / box ] ctx) -> app[ phi1 \/ phi2 / box ] ctx $ =
  '(eori (framing orl) (framing orr));
theorem prop_43_exists {box: SVar} {x: EVar} (ctx: Pattern box) (phi: Pattern x):
  $ (exists x (app[ phi / box ] ctx)) -> app[ exists x phi / box ] ctx $ =
  '(exists_generalization (eFresh_in_appCtx eFresh_triv eFresh_in_exists_same_var) (framing exists_intro_same_var));

theorem univ_gene {x: EVar} (phi: Pattern x)
  (p: $ phi $):
  $ forall x phi $ = '(exists_generalization_strict @ notnot1 p);
theorem var_subst {x y: EVar} (phi: Pattern x y):
  $ (forall x phi) -> e[ eVar y / x ] phi $ =
  '(con1 @ norm (norm_imp eSubstitution_in_not norm_refl) exists_intro);
theorem var_subst_same_var {x: EVar} (phi: Pattern x):
  $ (forall x phi) -> phi $ = '(con1 exists_intro_same_var);

theorem lemma_46 (phi: Pattern) {box: SVar} (ctx: Pattern box)
  (p : $ phi $):
  $ ~ (app[ (~ phi) / box ] ctx) $ = '(syl propag_bot @ framing @ notnot1 p);

theorem eqiv_to_eq (h: $ phi <-> psi $):
  $ phi == psi $ = '(norm (norm_not @ ! defNorm box) @ lemma_46 h);

theorem eq_intro: $ phi == phi $ = '(eqiv_to_eq biid);

theorem membership_intro {x: EVar} (phi: Pattern x)
  (h: $ phi $):
  $ forall x (x in phi) $ =
  '(univ_gene @ framingDef (iand id (a1i h)) definedness);

theorem membership_elim {x: EVar} (phi: Pattern)
  (h: $ forall x (x in phi) $):
  $ phi $ =
  '(dne @ exists_generalization_strict (dne @ dne (norm (norm_not @ norm_and (! defNorm box1) (! appCtxVar box2)) singleton) @ var_subst_same_var h) existence);

theorem membership_var {x y: EVar}:
  $ (x in (eVar y)) == (eVar x == eVar y) $ = '(eqiv_to_eq @ iani
  (rsyl (iand (dne singletonDef) (imim1i (framingDef ancom) @ dne @ norm (norm_not @ norm_and defNorm defNorm) (! singleton box1 box2))) @ rsyl (anri not_distr_or) @ rsyl (con3 @ norm (norm_imp norm_refl @ norm_or defNorm defNorm) propag_or) @ con3 @ norm (norm_imp defNorm norm_refl) (! framing box _ _ _ @ anr lemma_51))
  (norm (norm_or defNorm defNorm) @ propag_or @ norm (norm_sym (! defNorm box)) @ framingDef or_imp_xor_and @ norm defNorm @ prop_43_or @ norm (norm_sym @ norm_or defNorm (! defNorm box)) @ orl definedness)
  );

theorem membership_not_lemma {x: EVar} (phi: Pattern x):
  $ (x in phi) \/ (x in ~phi) $ =
  '(norm (norm_or defNorm defNorm) @ propag_or @ norm (norm_sym (! defNorm box)) @ framingDef (exp @ iand anl @ curry @ com12 dne) definedness);

theorem membership_not {x: EVar} (phi: Pattern x):
  $ (x in ~phi) == ~(x in phi) $ =
  '(eqiv_to_eq @ iani (con2 @ dne singletonDef) membership_not_lemma);

theorem framing_in {x: EVar} (phi1 phi2: Pattern x)
  (h: $ phi1 -> phi2 $): $ (x in phi1) -> (x in phi2)$ = '(framingDef @ anim2 h);

theorem membership_and {x: EVar} (phi1 phi2: Pattern x):
  $ x in (phi1 /\ phi2) == (x in phi1) /\ (x in phi2) $ =
  '(eqiv_to_eq @ iani
    (iand (framingDef @ iand anl anrl) (framingDef @ iand anl anrr))
    (syl dne @ con2 @ rsyl membership_not_lemma @ rsyl (framing_in @ anl notan) @ rsyl
      (framingDef @ anl andi)
      (rsyl (norm (norm_imp defNorm @ norm_or defNorm defNorm) (! propag_or box)) @ rsyl (orim (con2 @ dne singletonDef) (con2 @ dne singletonDef)) (anr notan))));

-- theorem membership_exists {x y: EVar} (phi: Pattern x y):
--   $ (x in (exists y phi)) == (exists y (x in phi)) $ = '(eqiv_to_eq @ iani
--     (_)
--     (_));